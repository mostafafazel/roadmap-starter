{
  "resolvedId": "/Users/mamthenebo/Me/Help/fuz/roadmap-starter/node_modules/.pnpm/@babel+parser@7.23.9/node_modules/@babel/parser/lib/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = ({\n  type,\n  prefix\n}) => type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  DynamicImportPhaseRequiresImportExpressions: ({\n    phase\n  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({\n    maxArgumentCount\n  }) => `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`,\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n};\nconst _excluded = [\"toMessage\"],\n  _excluded2 = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor(_ref) {\n  let {\n      toMessage\n    } = _ref,\n    properties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    Object.assign(error, properties, {\n      loc,\n      pos: loc.index\n    });\n    if (\"missingPlugin\" in details) {\n      Object.assign(error, {\n        missingPlugin: details.missingPlugin\n      });\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref2 = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref2,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = \"Literal\";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = \"ExpressionStatement\";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n    classBody.body.push(method);\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    return this.finishNode(node, \"MethodDefinition\");\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$, _node$arguments$2;\n        node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n        node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;\n      }\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 132;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 132;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 136;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[142].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (387 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 387) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1)) return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name);\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 387) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (387 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length != commentsLen) this.comments.length = commentsLen;\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  resetPreviousIdentifierLeadingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 139;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(value) {\n    if (value) {\n      this.flags |= 1;\n    } else {\n      this.flags &= ~1;\n    }\n  }\n  init({\n    strictMode,\n    sourceType,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(value) {\n    if (value) {\n      this.flags |= 2;\n    } else {\n      this.flags &= ~2;\n    }\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(value) {\n    if (value) {\n      this.flags |= 4;\n    } else {\n      this.flags &= ~4;\n    }\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(value) {\n    if (value) {\n      this.flags |= 8;\n    } else {\n      this.flags &= ~8;\n    }\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(value) {\n    if (value) {\n      this.flags |= 16;\n    } else {\n      this.flags &= ~16;\n    }\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(value) {\n    if (value) {\n      this.flags |= 32;\n    } else {\n      this.flags &= ~32;\n    }\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(value) {\n    if (value) {\n      this.flags |= 64;\n    } else {\n      this.flags &= ~64;\n    }\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(value) {\n    if (value) {\n      this.flags |= 128;\n    } else {\n      this.flags &= ~128;\n    }\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(value) {\n    if (value) {\n      this.flags |= 256;\n    } else {\n      this.flags &= ~256;\n    }\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(value) {\n    if (value) {\n      this.flags |= 512;\n    } else {\n      this.flags &= ~512;\n    }\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(value) {\n    if (value) {\n      this.flags |= 1024;\n    } else {\n      this.flags &= ~1024;\n    }\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(value) {\n    if (value) {\n      this.flags |= 2048;\n    } else {\n      this.flags &= ~2048;\n    }\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery) return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(139);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule && this.options.annexB) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule && this.options.annexB) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(138, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(138, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(137, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(135, str);\n      return;\n    }\n    this.finishToken(134, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(135, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(136, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(134, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(133, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule) {\n      paramFlags |= 2;\n    }\n    this.scope.enter(1);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n  finishToken(type, val) {\n    if (type !== 133 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(133)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n      body.push(bodyNode);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n    this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(142)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    var _startLoc;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 10:\n        this.next();\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 133:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(134)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        this.unexpected();\n        return;\n      case 134:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 135:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(2 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return node;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      if (!isExport) return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55)) this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(142) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 134:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 133:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(142);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(141, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(133, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(140, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(140)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 142:\n      case 133:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(143)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(143)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(143);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(143)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(143);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 142:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 141:\n            children.push(this.parseExprAtom());\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(141)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(142)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(142);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        this.finishToken(143);\n        return;\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        this.jsxReadString(code);\n        return;\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(142);\n      return;\n    }\n    super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 142) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 142) {\n      context.push(types.j_oTag);\n    } else if (type === 143) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags == 256) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags == 256) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type) scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, 1);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n        }\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 138) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseAssignableListItem(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  parseAssignableListItemTypes(param, flags) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    var _startLoc, _left;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    }, type);\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, {\n    in: ancestor,\n    binding = 64,\n    checkClashes = false,\n    strictModeChanged = false,\n    hasParenthesizedAncestor = false\n  }) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(133)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n    }\n    node.argument = super.parseExprAtom();\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(142)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const {\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const startLoc = this.state.startLoc;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAtNode(label);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAtNode(type);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 133:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 133:\n      case 134:\n      case 135:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 134 && nextToken.type !== 135) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(129);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(133)) {\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    node.isExport = isExport || false;\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(133)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let startType = this.state.type;\n    let kind;\n    if (this.isContextual(100)) {\n      startType = 74;\n      kind = \"let\";\n    }\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          nany.declare = true;\n          return super.parseFunctionStatement(nany, false, false);\n        case 80:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(nany, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            nany.declare = true;\n            return this.parseVarStatement(nany, kind || this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(nany, {\n            const: true,\n            declare: true\n          });\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true\n            });\n            if (result) return result;\n          }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(nany, this.state.value, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(256);\n          this.prodParam.enter(0);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(133)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseAssignableListItem(flags, decorators) {\n    const startLoc = this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11, false);\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {}\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(133)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      } else {\n        node.importKind = \"value\";\n      }\n      return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(126)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n      return expr;\n    }\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && !node.value.body) return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(142) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseAssignableListItemTypes(param, flags) {\n    if (!(flags & 2)) return param;\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree) {\n  if (estree) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(144)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(144);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(144, 2);\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const nextToken = this.lookahead();\n    if (nextToken.type === 144) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(144) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return plugin[1][option];\n  }\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = getPluginOption(plugins, \"decorators\", \"allowCallParenthesized\");\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\") || hasPlugin(plugins, \"importAttributes\")) {\n        throw new Error(\"Cannot combine importAssertions, importAttributes and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (hasPlugin(plugins, \"importAssertions\") && hasPlugin(plugins, \"importAttributes\")) {\n    throw new Error(\"Cannot combine importAssertions and importAttributes plugins.\");\n  }\n  if (hasPlugin(plugins, \"recordAndTuple\") && getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (hasPlugin(plugins, \"optionalChainingAssign\") && getPluginOption(plugins, \"optionalChainingAssign\", \"version\") !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is '2023-07'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowNewTargetOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createImportExpressions: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true,\n  annexB: true\n};\nfunction getOptions(opts) {\n  if (opts == null) {\n    return Object.assign({}, defaultOptions);\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  const options = {};\n  for (const key of Object.keys(defaultOptions)) {\n    var _opts$key;\n    options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];\n  }\n  return options;\n}\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      protoRef.used = true;\n    }\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(139)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(108)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(108)) {\n                throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n              }\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\")\n      });\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node, \"UpdateExpression\")\n      });\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(138)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n  expectImportAttributesPlugin() {\n    if (!this.hasPlugin(\"importAssertions\")) {\n      this.expectPlugin(\"importAttributes\");\n    }\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectImportAttributesPlugin();\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node, {\n          maxArgumentCount: this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAttributes\") && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (this.match(10)) {\n          if (this.options.createImportExpressions) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 134:\n        return this.parseNumericLiteral(this.state.value);\n      case 135:\n        return this.parseBigIntLiteral(this.state.value);\n      case 136:\n        return this.parseDecimalLiteral(this.state.value);\n      case 133:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, callee);\n          }\n        }\n      case 138:\n        {\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          }\n          this.unexpected();\n          break;\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          } else {\n            this.unexpected();\n          }\n          break;\n        }\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" : \"TopicReference\";\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);\n      }\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n    if (this.isContextual(101)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, id);\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      if (!isSource) this.unexpected();\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      if (!this.options.createImportExpressions) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {\n          phase: this.state.value\n        });\n      }\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    }\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 134:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 133:\n            key = this.parseStringLiteral(value);\n            break;\n          case 135:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 136:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case 138:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 138) {\n        prop.computed = false;\n      }\n    }\n    return prop.key;\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(2 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: 5,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 139:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n      node.options = null;\n    }\n    if (this.eat(12)) {\n      this.expectImportAttributesPlugin();\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        this.eat(12);\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: 1\n  },\n  switchLabel = {\n    kind: 2\n  };\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 138) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(132),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.comments;\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end = 139, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, at, {\n          localName\n        });\n      }\n    }\n    let finishedProgram;\n    if (end === 139) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifier() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n  startsUsingForOf() {\n    const {\n      type,\n      containsEsc\n    } = this.lookahead();\n    if (type === 102 && !containsEsc) {\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n  startsAwaitUsing() {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100:\n        {\n          if (this.state.containsEsc) {\n            break;\n          }\n          const next = this.nextTokenStart();\n          const nextCh = this.codePointAtPos(next);\n          if (nextCh !== 91) {\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n              break;\n            }\n          }\n        }\n      case 75:\n        {\n          if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n          }\n        }\n      case 74:\n        {\n          const kind = this.state.value;\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n          }\n          this.next();\n          let result;\n          if (starttype === 83) {\n            result = this.parseImport(node);\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node, decorators);\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (!allowDeclaration) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(138)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\n          return this.parseForIn(node, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(0);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: 9\n    });\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"const\"\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    this.checkLVal(id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? 5 : 8201\n    });\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(2);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(138);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(138);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(138);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate = this.match(138);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(138);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 133) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 138) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    return this.parsePropertyName(member);\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(64 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, key);\n      }\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(64 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(133);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(133)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport) return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.parseIdentifier(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return phaseIdentifier;\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(133)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(133)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      in: {\n        type\n      },\n      binding: bindingType\n    });\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(133)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(133)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(133)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    let useWith = false;\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      {\n        if (this.hasPlugin(\"moduleAttributes\")) {\n          attributes = this.parseModuleAttributes();\n        } else {\n          this.expectImportAttributesPlugin();\n          attributes = this.parseImportAttributes();\n        }\n      }\n      useWith = true;\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (this.hasPlugin(\"importAttributes\")) {\n        if (this.getPluginOption(\"importAttributes\", \"deprecatedAssertSyntax\") !== true) {\n          this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n        }\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      } else {\n        this.expectOnePlugin([\"importAttributes\", \"importAssertions\"]);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n      attributes = [];\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = [];\n      } else return;\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(133);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    file.comments.length = this.state.commentsLen;\n    return file;\n  }\n}\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n  return new cls(options, input);\n}\nconst parserClassCache = {};\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n",
      "start": 1727610130956,
      "end": 1727610130977,
      "sourcemaps": null
    },
    {
      "name": "unocss:transformers:pre",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "unocss:transformers:pre",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "unocss:global:build:scan",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "unocss:global:build:scan",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1727610130977,
      "end": 1727610130977,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1727610130977,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "unocss:transformers:undefined",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "unocss:transformers:undefined",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1727610130978,
      "end": 1727610130978,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1727610130978,
      "end": 1727610130979,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1727610130979,
      "end": 1727610130979,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = ({\n  type,\n  prefix: prefix2\n}) => type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  DynamicImportPhaseRequiresImportExpressions: ({\n    phase\n  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({\n    maxArgumentCount\n  }) => `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nconst UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`,\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n};\nconst _excluded = [\"toMessage\"], _excluded2 = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor(_ref) {\n  let {\n    toMessage\n  } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    Object.assign(error, properties, {\n      loc,\n      pos: loc.index\n    });\n    if (\"missingPlugin\" in details) {\n      Object.assign(error, {\n        missingPlugin: details.missingPlugin\n      });\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref2 = typeof template === \"string\" ? {\n      message: () => template\n    } : typeof template === \"function\" ? {\n      message: template\n    } : template, {\n      message\n    } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = (superClass) => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {\n    }\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = \"Literal\";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = \"ExpressionStatement\";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n    classBody.body.push(method);\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    return this.finishNode(node, \"MethodDefinition\");\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$, _node$arguments$2;\n        node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n        node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;\n      }\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = /* @__PURE__ */ new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 132;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 132;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 136;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = (context) => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = (context) => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[142].updateContext = (context) => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = \"------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\";\nlet nonASCIIidentifierChars = \"-----------------------------------------------------------------------------------------------------------------------------------------------------\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code2, set) {\n  let pos = 65536;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code2)\n      return false;\n    pos += set[i + 1];\n    if (pos >= code2)\n      return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code2) {\n  if (code2 < 65)\n    return code2 === 36;\n  if (code2 <= 90)\n    return true;\n  if (code2 < 97)\n    return code2 === 95;\n  if (code2 <= 122)\n    return true;\n  if (code2 <= 65535) {\n    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));\n  }\n  return isInAstralSet(code2, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code2) {\n  if (code2 < 48)\n    return code2 === 36;\n  if (code2 < 58)\n    return true;\n  if (code2 < 65)\n    return false;\n  if (code2 <= 90)\n    return true;\n  if (code2 < 97)\n    return code2 === 95;\n  if (code2 <= 122)\n    return true;\n  if (code2 <= 65535) {\n    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));\n  }\n  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = /* @__PURE__ */ new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = /* @__PURE__ */ new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = /* @__PURE__ */ new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (387 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 387)\n          break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1))\n      return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name);\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 387) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (387 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = /* @__PURE__ */ new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType))\n      return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === void 0) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === void 0) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === void 0) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename)\n      comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length != commentsLen)\n      this.comments.length = commentsLen;\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0)\n      return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default: {\n            setInnerComments(node, comments);\n          }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0)\n      return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  resetPreviousIdentifierLeadingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0)\n      return;\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0)\n      return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code2) {\n  switch (code2) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code2) {\n  switch (code2) {\n    case 9:\n    case 11:\n    case 12:\n    case 32:\n    case 160:\n    case 5760:\n    case 8192:\n    case 8193:\n    case 8194:\n    case 8195:\n    case 8196:\n    case 8197:\n    case 8198:\n    case 8199:\n    case 8200:\n    case 8201:\n    case 8202:\n    case 8239:\n    case 8287:\n    case 12288:\n    case 65279:\n      return true;\n    default:\n      return false;\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 139;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = /* @__PURE__ */ new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(value) {\n    if (value) {\n      this.flags |= 1;\n    } else {\n      this.flags &= ~1;\n    }\n  }\n  init({\n    strictMode,\n    sourceType,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(value) {\n    if (value) {\n      this.flags |= 2;\n    } else {\n      this.flags &= ~2;\n    }\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(value) {\n    if (value) {\n      this.flags |= 4;\n    } else {\n      this.flags &= ~4;\n    }\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(value) {\n    if (value) {\n      this.flags |= 8;\n    } else {\n      this.flags &= ~8;\n    }\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(value) {\n    if (value) {\n      this.flags |= 16;\n    } else {\n      this.flags &= ~16;\n    }\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(value) {\n    if (value) {\n      this.flags |= 32;\n    } else {\n      this.flags &= ~32;\n    }\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(value) {\n    if (value) {\n      this.flags |= 64;\n    } else {\n      this.flags &= ~64;\n    }\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(value) {\n    if (value) {\n      this.flags |= 128;\n    } else {\n      this.flags &= ~128;\n    }\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(value) {\n    if (value) {\n      this.flags |= 256;\n    } else {\n      this.flags &= ~256;\n    }\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(value) {\n    if (value) {\n      this.flags |= 512;\n    } else {\n      this.flags &= ~512;\n    }\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(value) {\n    if (value) {\n      this.flags |= 1024;\n    } else {\n      this.flags &= ~1024;\n    }\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(value) {\n    if (value) {\n      this.flags |= 2048;\n    } else {\n      this.flags &= ~2048;\n    }\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code2) {\n  return code2 >= 48 && code2 <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: (ch) => ch === 48 || ch === 49,\n  oct: (ch) => ch >= 48 && ch <= 55,\n  dec: (ch) => ch >= 48 && ch <= 57,\n  hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (; ; ) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = (ch2) => ({\n    pos,\n    ch: ch2,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120: {\n      let code2;\n      ({\n        code: code2,\n        pos\n      } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n      return res(code2 === null ? null : String.fromCharCode(code2));\n    }\n    case 117: {\n      let code2;\n      ({\n        code: code2,\n        pos\n      } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n      return res(code2 === null ? null : String.fromCodePoint(code2));\n    }\n    case 116:\n      return res(\"\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\v\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code2 = input.charCodeAt(pos);\n    let val;\n    if (code2 === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError)\n          return {\n            n: null,\n            pos\n          };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError)\n          return {\n            n: null,\n            pos\n          };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code2 >= 97) {\n      val = code2 - 97 + 10;\n    } else if (code2 >= 65) {\n      val = code2 - 65 + 10;\n    } else if (_isDigit(code2)) {\n      val = code2 - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code2;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code: code2,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code2 !== null && code2 > 1114111) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code: code2,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code: code2,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery)\n          return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 64512) === 55296 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 64512) === 56320) {\n        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead)\n      this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(139);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead)\n      startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead)\n      return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens)\n      this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead)\n      startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead)\n      return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens)\n      this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop:\n      while (this.state.pos < this.length) {\n        const ch = this.input.charCodeAt(this.state.pos);\n        switch (ch) {\n          case 32:\n          case 160:\n          case 9:\n            ++this.state.pos;\n            break;\n          case 13:\n            if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n              ++this.state.pos;\n            }\n          case 10:\n          case 8232:\n          case 8233:\n            ++this.state.pos;\n            ++this.state.curLine;\n            this.state.lineStart = this.state.pos;\n            break;\n          case 47:\n            switch (this.input.charCodeAt(this.state.pos + 1)) {\n              case 42: {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n                break;\n              }\n              case 47: {\n                const comment = this.skipLineComment(2);\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n                break;\n              }\n              default:\n                break loop;\n            }\n            break;\n          default:\n            if (isWhitespace(ch)) {\n              ++this.state.pos;\n            } else if (ch === 45 && !this.inModule && this.options.annexB) {\n              const pos = this.state.pos;\n              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n                const comment = this.skipLineComment(3);\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n              } else {\n                break loop;\n              }\n            } else if (ch === 60 && !this.inModule && this.options.annexB) {\n              const pos = this.state.pos;\n              if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n                const comment = this.skipLineComment(4);\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n              } else {\n                break loop;\n              }\n            } else {\n              break loop;\n            }\n        }\n      }\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(138, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(138, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2)\n      return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33)\n      return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code2) {\n    let type = code2 === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code2 === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code2) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code2 === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code2 === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code2 === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code2) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code2 === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code2 === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code2) {\n    switch (code2) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        if (next === 120 || next === 88) {\n          this.readRadixNumber(16);\n          return;\n        }\n        if (next === 111 || next === 79) {\n          this.readRadixNumber(8);\n          return;\n        }\n        if (next === 98 || next === 66) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code2);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code2);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code2);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code2);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code2);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code2)) {\n          this.readWord(code2);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code2)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(137, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(135, str);\n      return;\n    }\n    this.finishToken(134, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(135, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(136, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(134, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code: code2,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code2;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(133, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== void 0) {\n      this.state.pos += firstCode <= 65535 ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 65535 ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== void 0) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!this.options.errorRecovery)\n      throw error;\n    if (!this.isLookahead)\n      this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos)\n        break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {\n  }\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some((name) => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = /* @__PURE__ */ new Set();\n    this.loneAccessors = /* @__PURE__ */ new Map();\n    this.undefinedPrivateNames = /* @__PURE__ */ new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = /* @__PURE__ */ new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined)\n          loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name))\n        return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = /* @__PURE__ */ new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration())\n      return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node)\n      return;\n    const extra = node.extra = node.extra || {};\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13))\n      return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node2 = null) => {\n        abortSignal.node = node2;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors)\n      return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = /* @__PURE__ */ new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler2 = this.getScopeHandler();\n    this.scope = new ScopeHandler2(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule) {\n      paramFlags |= 2;\n    }\n    this.scope.enter(1);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges)\n      this.range = [pos, 0];\n    if (parser != null && parser.filename)\n      this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function() {\n    const newNode = new Node(void 0, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== void 0) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges)\n      node.range[1] = endLoc.index;\n    if (this.options.attachComment)\n      this.processComment(node);\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges)\n      node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges)\n      node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\nconst reservedTypes = /* @__PURE__ */ new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass) => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = void 0;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n  finishToken(type, val) {\n    if (type !== 133 && type !== 13 && type !== 28) {\n      if (this.flowPragma === void 0) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === void 0) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches)\n        ;\n      else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(133)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode2 = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        super.parseImport(bodyNode2);\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode2 = this.flowParseDeclare(bodyNode2, true);\n      }\n      body.push(bodyNode2);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach((bodyElement) => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n    this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word))\n      return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(142)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\")\n          this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    var _startLoc;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3))\n        break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 10:\n        this.next();\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 133:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(134)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        this.unexpected();\n        return;\n      case 134:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 135:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17))\n      return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node2 = stack.pop();\n      if (node2.type === \"ArrowFunctionExpression\") {\n        if (node2.typeParameters || !node2.returnType) {\n          this.finishArrowValidation(node2);\n        } else {\n          arrows.push(node2);\n        }\n        stack.push(node2.body);\n      } else if (node2.type === \"ConditionalExpression\") {\n        stack.push(node2.consequent);\n        stack.push(node2.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach((node2) => this.finishArrowValidation(node2));\n      return [arrows, []];\n    }\n    return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(2 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse2) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse2();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse2();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return node;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node))\n      return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code2 === 62 || code2 === 60)) {\n      this.finishOp(code2 === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code2 === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code2);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node2 = this.startNode();\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node2.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node2.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node2, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10))\n        this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport))\n      return true;\n    if (this.isContextual(130)) {\n      if (!isExport)\n        return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55))\n        this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx2;\n    if (this.hasPlugin(\"jsx\") && (this.match(142) || this.match(47))) {\n      state = this.state.clone();\n      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx2.error)\n        return jsx2.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse((abort) => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)\n          abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);\n        if (expr.type !== \"ArrowFunctionExpression\")\n          abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression2;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx2) != null && _jsx2.node) {\n        this.state = jsx2.failState;\n        return jsx2.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx2) != null && _jsx3.thrown)\n        throw jsx2.error;\n      if (arrow.thrown)\n        throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon())\n          this.unexpected();\n        if (!this.match(19))\n          this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown)\n        return null;\n      if (result.error)\n        this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted)\n        return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error)\n        return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error)\n          this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node))\n      return;\n    return super.parseArrowExpression(node, void 0, true);\n  }\n  readToken_mult_modulo(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code2);\n  }\n  readToken_pipe_amp(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code2);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 134: {\n        const literal = this.parseNumericLiteral(this.state.value);\n        if (endOfInit()) {\n          return {\n            type: \"number\",\n            loc: literal.loc.start,\n            value: literal\n          };\n        }\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n      }\n      case 133: {\n        const literal = this.parseStringLiteral(this.state.value);\n        if (endOfInit()) {\n          return {\n            type: \"string\",\n            loc: literal.loc.start,\n            value: literal\n          };\n        }\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n      }\n      case 85:\n      case 86: {\n        const literal = this.parseBooleanLiteral(this.match(85));\n        if (endOfInit()) {\n          return {\n            type: \"boolean\",\n            loc: literal.loc.start,\n            value: literal\n          };\n        }\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n      }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = /* @__PURE__ */ new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\": {\n          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n          memberNode.init = init.value;\n          members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n          break;\n        }\n        case \"number\": {\n          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n          memberNode.init = init.value;\n          members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n          break;\n        }\n        case \"string\": {\n          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n          memberNode.init = init.value;\n          members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n          break;\n        }\n        case \"invalid\": {\n          throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n        }\n        case \"none\": {\n          switch (explicitType) {\n            case \"boolean\":\n              this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n              break;\n            case \"number\":\n              this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n              break;\n            default:\n              members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n          }\n        }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102))\n      return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default: {\n        const empty = () => {\n          node.members = [];\n          this.expect(8);\n          return this.finishNode(node, \"EnumStringBody\");\n        };\n        node.explicitType = false;\n        const boolsLen = members.booleanMembers.length;\n        const numsLen = members.numberMembers.length;\n        const strsLen = members.stringMembers.length;\n        const defaultedLen = members.defaultedMembers.length;\n        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n          return empty();\n        } else if (!boolsLen && !numsLen) {\n          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n            enumName\n          });\n          this.expect(8);\n          return this.finishNode(node, \"EnumStringBody\");\n        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n          for (const member of members.defaultedMembers) {\n            this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n              enumName,\n              memberName: member.id.name\n            });\n          }\n          node.members = members.booleanMembers;\n          this.expect(8);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n          for (const member of members.defaultedMembers) {\n            this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n              enumName,\n              memberName: member.id.name\n            });\n          }\n          node.members = members.numberMembers;\n          this.expect(8);\n          return this.finishNode(node, \"EnumNumberBody\");\n        } else {\n          this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n            enumName\n          });\n          return empty();\n        }\n      }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: '\"',\n  amp: \"&\",\n  apos: \"'\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\",\n  iexcl: \"\",\n  cent: \"\",\n  pound: \"\",\n  curren: \"\",\n  yen: \"\",\n  brvbar: \"\",\n  sect: \"\",\n  uml: \"\",\n  copy: \"\",\n  ordf: \"\",\n  laquo: \"\",\n  not: \"\",\n  shy: \"\",\n  reg: \"\",\n  macr: \"\",\n  deg: \"\",\n  plusmn: \"\",\n  sup2: \"\",\n  sup3: \"\",\n  acute: \"\",\n  micro: \"\",\n  para: \"\",\n  middot: \"\",\n  cedil: \"\",\n  sup1: \"\",\n  ordm: \"\",\n  raquo: \"\",\n  frac14: \"\",\n  frac12: \"\",\n  frac34: \"\",\n  iquest: \"\",\n  Agrave: \"\",\n  Aacute: \"\",\n  Acirc: \"\",\n  Atilde: \"\",\n  Auml: \"\",\n  Aring: \"\",\n  AElig: \"\",\n  Ccedil: \"\",\n  Egrave: \"\",\n  Eacute: \"\",\n  Ecirc: \"\",\n  Euml: \"\",\n  Igrave: \"\",\n  Iacute: \"\",\n  Icirc: \"\",\n  Iuml: \"\",\n  ETH: \"\",\n  Ntilde: \"\",\n  Ograve: \"\",\n  Oacute: \"\",\n  Ocirc: \"\",\n  Otilde: \"\",\n  Ouml: \"\",\n  times: \"\",\n  Oslash: \"\",\n  Ugrave: \"\",\n  Uacute: \"\",\n  Ucirc: \"\",\n  Uuml: \"\",\n  Yacute: \"\",\n  THORN: \"\",\n  szlig: \"\",\n  agrave: \"\",\n  aacute: \"\",\n  acirc: \"\",\n  atilde: \"\",\n  auml: \"\",\n  aring: \"\",\n  aelig: \"\",\n  ccedil: \"\",\n  egrave: \"\",\n  eacute: \"\",\n  ecirc: \"\",\n  euml: \"\",\n  igrave: \"\",\n  iacute: \"\",\n  icirc: \"\",\n  iuml: \"\",\n  eth: \"\",\n  ntilde: \"\",\n  ograve: \"\",\n  oacute: \"\",\n  ocirc: \"\",\n  otilde: \"\",\n  ouml: \"\",\n  divide: \"\",\n  oslash: \"\",\n  ugrave: \"\",\n  uacute: \"\",\n  ucirc: \"\",\n  uuml: \"\",\n  yacute: \"\",\n  thorn: \"\",\n  yuml: \"\",\n  OElig: \"\",\n  oelig: \"\",\n  Scaron: \"\",\n  scaron: \"\",\n  Yuml: \"\",\n  fnof: \"\",\n  circ: \"\",\n  tilde: \"\",\n  Alpha: \"\",\n  Beta: \"\",\n  Gamma: \"\",\n  Delta: \"\",\n  Epsilon: \"\",\n  Zeta: \"\",\n  Eta: \"\",\n  Theta: \"\",\n  Iota: \"\",\n  Kappa: \"\",\n  Lambda: \"\",\n  Mu: \"\",\n  Nu: \"\",\n  Xi: \"\",\n  Omicron: \"\",\n  Pi: \"\",\n  Rho: \"\",\n  Sigma: \"\",\n  Tau: \"\",\n  Upsilon: \"\",\n  Phi: \"\",\n  Chi: \"\",\n  Psi: \"\",\n  Omega: \"\",\n  alpha: \"\",\n  beta: \"\",\n  gamma: \"\",\n  delta: \"\",\n  epsilon: \"\",\n  zeta: \"\",\n  eta: \"\",\n  theta: \"\",\n  iota: \"\",\n  kappa: \"\",\n  lambda: \"\",\n  mu: \"\",\n  nu: \"\",\n  xi: \"\",\n  omicron: \"\",\n  pi: \"\",\n  rho: \"\",\n  sigmaf: \"\",\n  sigma: \"\",\n  tau: \"\",\n  upsilon: \"\",\n  phi: \"\",\n  chi: \"\",\n  psi: \"\",\n  omega: \"\",\n  thetasym: \"\",\n  upsih: \"\",\n  piv: \"\",\n  ensp: \"\",\n  emsp: \"\",\n  thinsp: \"\",\n  zwnj: \"\",\n  zwj: \"\",\n  lrm: \"\",\n  rlm: \"\",\n  ndash: \"\",\n  mdash: \"\",\n  lsquo: \"\",\n  rsquo: \"\",\n  sbquo: \"\",\n  ldquo: \"\",\n  rdquo: \"\",\n  bdquo: \"\",\n  dagger: \"\",\n  Dagger: \"\",\n  bull: \"\",\n  hellip: \"\",\n  permil: \"\",\n  prime: \"\",\n  Prime: \"\",\n  lsaquo: \"\",\n  rsaquo: \"\",\n  oline: \"\",\n  frasl: \"\",\n  euro: \"\",\n  image: \"\",\n  weierp: \"\",\n  real: \"\",\n  trade: \"\",\n  alefsym: \"\",\n  larr: \"\",\n  uarr: \"\",\n  rarr: \"\",\n  darr: \"\",\n  harr: \"\",\n  crarr: \"\",\n  lArr: \"\",\n  uArr: \"\",\n  rArr: \"\",\n  dArr: \"\",\n  hArr: \"\",\n  forall: \"\",\n  part: \"\",\n  exist: \"\",\n  empty: \"\",\n  nabla: \"\",\n  isin: \"\",\n  notin: \"\",\n  ni: \"\",\n  prod: \"\",\n  sum: \"\",\n  minus: \"\",\n  lowast: \"\",\n  radic: \"\",\n  prop: \"\",\n  infin: \"\",\n  ang: \"\",\n  and: \"\",\n  or: \"\",\n  cap: \"\",\n  cup: \"\",\n  int: \"\",\n  there4: \"\",\n  sim: \"\",\n  cong: \"\",\n  asymp: \"\",\n  ne: \"\",\n  equiv: \"\",\n  le: \"\",\n  ge: \"\",\n  sub: \"\",\n  sup: \"\",\n  nsub: \"\",\n  sube: \"\",\n  supe: \"\",\n  oplus: \"\",\n  otimes: \"\",\n  perp: \"\",\n  sdot: \"\",\n  lceil: \"\",\n  rceil: \"\",\n  lfloor: \"\",\n  rfloor: \"\",\n  lang: \"\",\n  rang: \"\",\n  loz: \"\",\n  spades: \"\",\n  clubs: \"\",\n  hearts: \"\",\n  diams: \"\"\n};\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = (superClass) => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (; ; ) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(142);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(141, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (; ; ) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote)\n        break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(133, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, void 0, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(140, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(140)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14))\n      return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 142:\n      case 133:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(143)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(143)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(143);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(143)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(143);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents:\n        for (; ; ) {\n          switch (this.state.type) {\n            case 142:\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(56)) {\n                closingElement = this.jsxParseClosingElementAt(startLoc);\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startLoc));\n              break;\n            case 141:\n              children.push(this.parseExprAtom());\n              break;\n            case 5: {\n              const node2 = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node2));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node2, types.j_expr));\n              }\n              break;\n            }\n            default:\n              this.unexpected();\n          }\n        }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(141)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(142)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(142);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace)\n      super.skipSpace();\n  }\n  getTokenFromCode(code2) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code2)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code2 === 62) {\n        ++this.state.pos;\n        this.finishToken(143);\n        return;\n      }\n      if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {\n        this.jsxReadString(code2);\n        return;\n      }\n    }\n    if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(142);\n      return;\n    }\n    super.getTokenFromCode(code2);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 142) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 142) {\n      context.push(types.j_oTag);\n    } else if (type === 143) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = /* @__PURE__ */ new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(/* @__PURE__ */ new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags == 256) {\n      this.importsStack.push(/* @__PURE__ */ new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags == 256) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name))\n          return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type)\n      scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name))\n      return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nconst unwrapParenthesizedExpression = (node) => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = void 0;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\": {\n        const {\n          key,\n          value\n        } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n        }\n        this.toAssignable(value, isLHS);\n        break;\n      }\n      case \"SpreadElement\": {\n        throw new Error(\"Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.\");\n      }\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt)\n        continue;\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return node.properties.every((prop, i) => {\n          return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n        });\n      }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every((element) => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0: {\n        const node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(3, 93, 1);\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n        }\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 138) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseAssignableListItem(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  parseAssignableListItemTypes(param, flags) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    var _startLoc, _left;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29))\n      return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    }, type);\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, {\n    in: ancestor,\n    binding = 64,\n    checkClashes = false,\n    strictModeChanged = false,\n    hasParenthesizedAncestor = false\n  }) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression))\n      return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true)\n      return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern)\n          break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return void 0;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = (superClass) => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return void 0;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return void 0;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return void 0;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (; ; ) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier)\n        break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (; ; ) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return void 0;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return void 0;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(133)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n    }\n    node.argument = super.parseExprAtom();\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(142)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type)\n      node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17))\n      node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly)\n        property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type)\n        property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach((elementNode) => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const {\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const startLoc2 = this.state.startLoc;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAtNode(label);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAtNode(type);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract)\n        this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 133:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType)\n      return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 133:\n      case 134:\n      case 135:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 134 && nextToken.type !== 135) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default: {\n        const {\n          type\n        } = this.state;\n        if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n          const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n          if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, nodeType);\n          }\n          return this.tsParseTypeReference();\n        }\n      }\n    }\n    this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types2 = [];\n    do {\n      types2.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types2.length === 1 && !hasLeadingOperator) {\n      return types2[0];\n    }\n    node.types = types2;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon)\n        this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak())\n      return null;\n    this.expectContextual(129);\n    if (properties.declare)\n      node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookahead().type !== 16) {\n        const node2 = this.startNode();\n        this.next();\n        return this.finishNode(node2, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const)\n      node.const = true;\n    if (properties.declare)\n      node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(133)) {\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    node.isExport = isExport || false;\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(133)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse((abort) => f() || abort());\n    if (result.aborted || !result.node)\n      return;\n    if (result.error)\n      this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== void 0 && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let startType = this.state.type;\n    let kind;\n    if (this.isContextual(100)) {\n      startType = 74;\n      kind = \"let\";\n    }\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          nany.declare = true;\n          return super.parseFunctionStatement(nany, false, false);\n        case 80:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(nany, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            nany.declare = true;\n            return this.parseVarStatement(nany, kind || this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(nany, {\n            const: true,\n            declare: true\n          });\n        case 129: {\n          const result = this.tsParseInterfaceDeclaration(nany, {\n            declare: true\n          });\n          if (result)\n            return result;\n        }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(nany, this.state.value, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\": {\n        const declaration = this.tsTryParseDeclare(node);\n        if (declaration) {\n          declaration.declare = true;\n        }\n        return declaration;\n      }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(256);\n          this.prodParam.enter(0);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(133)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak())\n        return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47))\n      return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res)\n      return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47)\n      return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart())\n      return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseAssignableListItem(flags, decorators) {\n    const startLoc = this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility)\n        pp.accessibility = accessibility;\n      if (readonly)\n        pp.readonly = readonly;\n      if (override)\n        pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : void 0;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach((node) => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments)\n          return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result2.typeParameters = typeArguments;\n          return result2;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node2 = this.startNodeAt(startLoc);\n          node2.callee = base;\n          node2.arguments = this.parseCallExpressionArguments(11, false);\n          this.tsCheckForInvalidTypeCasts(node2.arguments);\n          node2.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node2.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node2, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport))\n      return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(133)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      } else {\n        node.importKind = \"value\";\n      }\n      return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result)\n        return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext)\n      return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init)\n        continue;\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(126)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result)\n        return result;\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some((modifier) => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional)\n      methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart())\n      return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n      return expr;\n    }\n    if (result.error)\n      this.state = result.failState;\n    return result.node;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration)\n      return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters)\n      node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type)\n      node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters)\n      method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters)\n      method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\")\n      return;\n    if (node.type === \"MethodDefinition\" && !node.value.body)\n      return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters)\n      prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters)\n      node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx2;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(142) || this.match(47))) {\n      state = this.state.clone();\n      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx2.error)\n        return jsx2.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state)\n      state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse((abort) => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters)\n        this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx2) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error)\n        return typeCast.node;\n    }\n    if ((_jsx2 = jsx2) != null && _jsx2.node) {\n      this.state = jsx2.failState;\n      return jsx2.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters)\n        this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse((abort) => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19))\n          abort();\n        return returnType;\n      });\n      if (result.aborted)\n        return;\n      if (!result.thrown) {\n        if (result.error)\n          this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseAssignableListItemTypes(param, flags) {\n    if (!(flags & 2))\n      return param;\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type)\n      param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code2) {\n    if (this.state.inType) {\n      if (code2 === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code2 === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code2);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every((expr) => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments)\n        node.typeParameters = typeArguments;\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\")\n    return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree2) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree2) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree2) {\n  if (estree2) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree2) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree2)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\")\n    return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(144)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(144);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n  getTokenFromCode(code2) {\n    if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(144, 2);\n    } else {\n      super.getTokenFromCode(code2);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== void 0) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const nextToken = this.lookahead();\n    if (nextToken.type === 144) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\")\n      return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(144) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder)\n      return super.parseExport(node, decorators);\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter((node2) => node2.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder)\n      return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport)\n        this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some((p) => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find((plugin2) => {\n    if (Array.isArray(plugin2)) {\n      return plugin2[0] === name;\n    } else {\n      return plugin2 === name;\n    }\n  });\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return plugin[1][option];\n  }\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = getPluginOption(plugins, \"decorators\", \"allowCallParenthesized\");\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map((p) => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map((t) => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\") || hasPlugin(plugins, \"importAttributes\")) {\n        throw new Error(\"Cannot combine importAssertions, importAttributes and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (hasPlugin(plugins, \"importAssertions\") && hasPlugin(plugins, \"importAttributes\")) {\n    throw new Error(\"Cannot combine importAssertions and importAttributes plugins.\");\n  }\n  if (hasPlugin(plugins, \"recordAndTuple\") && getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(\", \"));\n  }\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (hasPlugin(plugins, \"optionalChainingAssign\") && getPluginOption(plugins, \"optionalChainingAssign\", \"version\") !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: void 0,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowNewTargetOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createImportExpressions: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true,\n  annexB: true\n};\nfunction getOptions(opts) {\n  if (opts == null) {\n    return Object.assign({}, defaultOptions);\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  const options = {};\n  for (const key of Object.keys(defaultOptions)) {\n    var _opts$key;\n    options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];\n  }\n  return options;\n}\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      protoRef.used = true;\n    }\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(139)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(108)) {\n      if (this.prodParam.hasYield) {\n        let left2 = this.parseYield();\n        if (afterLeftParse) {\n          left2 = afterLeftParse.call(this, left2, startLoc);\n        }\n        return left2;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(108)) {\n                throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n              }\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr2 = this.parseAwait(startLoc);\n      if (!sawUnary)\n        this.checkExponentialAfterUnary(expr2);\n      return expr2;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr2 = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr2 && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\")\n      });\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false))\n      return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.operator = this.state.value;\n      node2.prefix = false;\n      node2.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node2, \"UpdateExpression\")\n      });\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(138)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n  expectImportAttributesPlugin() {\n    if (!this.hasPlugin(\"importAssertions\")) {\n      this.expectPlugin(\"importAttributes\");\n    }\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectImportAttributesPlugin();\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node, {\n          maxArgumentCount: this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAttributes\") && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (this.match(10)) {\n          if (this.options.createImportExpressions) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90: {\n        return this.parseDo(this.startNode(), false);\n      }\n      case 56:\n      case 31: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n      case 134:\n        return this.parseNumericLiteral(this.state.value);\n      case 135:\n        return this.parseBigIntLiteral(this.state.value);\n      case 136:\n        return this.parseDecimalLiteral(this.state.value);\n      case 133:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n      case 2:\n      case 1: {\n        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n      }\n      case 0: {\n        return this.parseArrayLike(3, true, false, refExpressionErrors);\n      }\n      case 6:\n      case 7: {\n        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n      }\n      case 5: {\n        return this.parseObjectLike(8, false, false, refExpressionErrors);\n      }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = node.callee = this.parseNoCallExpr();\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, callee);\n        }\n      }\n      case 138: {\n        this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n          identifierName: this.state.value\n        });\n        return this.parsePrivateName();\n      }\n      case 33: {\n        return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n      }\n      case 32: {\n        return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n      }\n      case 37:\n      case 38: {\n        return this.parseTopicReference(\"hack\");\n      }\n      case 44:\n      case 54:\n      case 27: {\n        const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        }\n        this.unexpected();\n        break;\n      }\n      case 47: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n        } else {\n          this.unexpected();\n        }\n        break;\n      }\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type: type2\n            } = this.state;\n            if (type2 === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type2)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type2 === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" : \"TopicReference\";\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);\n      }\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\"pipelineOperator\", {\n          topicToken: tokenLabelName(tokenType)\n        }]);\n      }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n    if (this.isContextual(101)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, id);\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      if (!isSource)\n        this.unexpected();\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      if (!this.options.createImportExpressions) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {\n          phase: this.state.value\n        });\n      }\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    }\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc)\n      this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc)\n      this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = /* @__PURE__ */ Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length)\n        this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern)\n        this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node)\n      this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 134:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 133:\n            key = this.parseStringLiteral(value);\n            break;\n          case 135:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 136:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case 138: {\n            const privateKeyLoc = this.state.startLoc;\n            if (refExpressionErrors != null) {\n              if (refExpressionErrors.privateKeyLoc === null) {\n                refExpressionErrors.privateKeyLoc = privateKeyLoc;\n              }\n            } else {\n              this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n            }\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 138) {\n        prop.computed = false;\n      }\n    }\n    return prop.key;\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(2 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i]))\n        return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: 5,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword2) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait)\n      return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak())\n      return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 139:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating)\n            break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n      node.options = null;\n    }\n    if (this.eat(12)) {\n      this.expectImportAttributesPlugin();\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        this.eat(12);\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parsePropertyNamePrefixOperator(prop) {\n  }\n}\nconst loopLabel = {\n  kind: 1\n}, switchLabel = {\n  kind: 2\n};\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 138) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(132),\n            value,\n            start: hashEndPos,\n            end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.comments;\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end = 139, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, at, {\n          localName\n        });\n      }\n    }\n    let finishedProgram;\n    if (end === 139) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifier() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n  startsUsingForOf() {\n    const {\n      type,\n      containsEsc\n    } = this.lookahead();\n    if (type === 102 && !containsEsc) {\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n  startsAwaitUsing() {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46)\n          break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration)\n          this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100: {\n        if (this.state.containsEsc) {\n          break;\n        }\n        const next = this.nextTokenStart();\n        const nextCh = this.codePointAtPos(next);\n        if (nextCh !== 91) {\n          if (!allowDeclaration && this.hasFollowingLineBreak())\n            break;\n          if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n            break;\n          }\n        }\n      }\n      case 75: {\n        if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n      }\n      case 74: {\n        const kind = this.state.value;\n        return this.parseVarStatement(node, kind);\n      }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n          break;\n        }\n      }\n      case 82: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n        }\n        this.next();\n        let result;\n        if (starttype === 83) {\n          result = this.parseImport(node);\n          if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(node, decorators);\n          if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n            this.sawUnambiguousESM = true;\n          }\n        }\n        this.assertModuleNodeAllowed(result);\n        return result;\n      }\n      default: {\n        if (this.isAsyncFunction()) {\n          if (!allowDeclaration) {\n            this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n          }\n          this.next();\n          return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n        }\n      }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\"))\n      return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode)\n        this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc2 = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc2, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node2 = this.startNodeAt(startLoc);\n          node2.object = expr;\n          if (this.match(138)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node2.property = this.parsePrivateName();\n          } else {\n            node2.property = this.parseIdentifier(true);\n          }\n          node2.computed = false;\n          expr = this.finishNode(node2, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak)\n          break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init2 = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init2);\n        }\n        if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {\n          return this.parseForIn(node, init2, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init2);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(0);\n    let cur;\n    for (let sawDefault; !this.match(8); ) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur)\n          this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur)\n      this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: 9\n    });\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind,\n      statementStart: this.state.start\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null)\n        this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (; ; ) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"const\"\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12))\n        break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    this.checkLVal(id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? 5 : 8201\n    });\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(2);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id)\n      return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(138);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(138);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate2 = this.match(138);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate2) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate2 = this.match(138);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate2) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate2 = this.match(138);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 133) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 138) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    return this.parsePropertyName(member);\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(64 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, void 0, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, key);\n      }\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n  }\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(64 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault)\n        this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers)\n        node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers)\n        node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95))\n      return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node2 = this.parseClass(this.startNode(), true, false);\n      return node2;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id)\n            throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8))\n          break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(133);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(133)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find((specifier) => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== void 0) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== void 0) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport)\n      return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.parseIdentifier(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return phaseIdentifier;\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(133)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar)\n      this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(133))\n      this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      in: {\n        type\n      },\n      binding: bindingType\n    });\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = /* @__PURE__ */ new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(133)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(133)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = /* @__PURE__ */ new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(133)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    let useWith = false;\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      {\n        if (this.hasPlugin(\"moduleAttributes\")) {\n          attributes = this.parseModuleAttributes();\n        } else {\n          this.expectImportAttributesPlugin();\n          attributes = this.parseImportAttributes();\n        }\n      }\n      useWith = true;\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (this.hasPlugin(\"importAttributes\")) {\n        if (this.getPluginOption(\"importAttributes\", \"deprecatedAssertSyntax\") !== true) {\n          this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n        }\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      } else {\n        this.expectOnePlugin([\"importAttributes\", \"importAssertions\"]);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n      attributes = [];\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = [];\n      } else\n        return;\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8))\n          break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(133);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, void 0);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    file.comments.length = this.state.commentsLen;\n    return file;\n  }\n}\nfunction pluginsMap(plugins) {\n  const pluginMap = /* @__PURE__ */ new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name))\n      pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {\n        }\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {\n      }\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes2 = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes2;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n  return new cls(options, input);\n}\nconst parserClassCache = {};\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n",
      "start": 1727610130979,
      "end": 1727610131412,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/mamthenebo/Me/Help/fuz/roadmap-starter/node_modules/.pnpm/@babel+parser@7.23.9/node_modules/@babel/parser/lib/index.js\"],\n  \"sourcesContent\": [\"'use strict';\\n\\nObject.defineProperty(exports, '__esModule', {\\n  value: true\\n});\\nfunction _objectWithoutPropertiesLoose(source, excluded) {\\n  if (source == null) return {};\\n  var target = {};\\n  var sourceKeys = Object.keys(source);\\n  var key, i;\\n  for (i = 0; i < sourceKeys.length; i++) {\\n    key = sourceKeys[i];\\n    if (excluded.indexOf(key) >= 0) continue;\\n    target[key] = source[key];\\n  }\\n  return target;\\n}\\nclass Position {\\n  constructor(line, col, index) {\\n    this.line = void 0;\\n    this.column = void 0;\\n    this.index = void 0;\\n    this.line = line;\\n    this.column = col;\\n    this.index = index;\\n  }\\n}\\nclass SourceLocation {\\n  constructor(start, end) {\\n    this.start = void 0;\\n    this.end = void 0;\\n    this.filename = void 0;\\n    this.identifierName = void 0;\\n    this.start = start;\\n    this.end = end;\\n  }\\n}\\nfunction createPositionWithColumnOffset(position, columnOffset) {\\n  const {\\n    line,\\n    column,\\n    index\\n  } = position;\\n  return new Position(line, column + columnOffset, index + columnOffset);\\n}\\nconst code = \\\"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\\\";\\nvar ModuleErrors = {\\n  ImportMetaOutsideModule: {\\n    message: `import.meta may appear only with 'sourceType: \\\"module\\\"'`,\\n    code\\n  },\\n  ImportOutsideModule: {\\n    message: `'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'`,\\n    code\\n  }\\n};\\nconst NodeDescriptions = {\\n  ArrayPattern: \\\"array destructuring pattern\\\",\\n  AssignmentExpression: \\\"assignment expression\\\",\\n  AssignmentPattern: \\\"assignment expression\\\",\\n  ArrowFunctionExpression: \\\"arrow function expression\\\",\\n  ConditionalExpression: \\\"conditional expression\\\",\\n  CatchClause: \\\"catch clause\\\",\\n  ForOfStatement: \\\"for-of statement\\\",\\n  ForInStatement: \\\"for-in statement\\\",\\n  ForStatement: \\\"for-loop\\\",\\n  FormalParameters: \\\"function parameter list\\\",\\n  Identifier: \\\"identifier\\\",\\n  ImportSpecifier: \\\"import specifier\\\",\\n  ImportDefaultSpecifier: \\\"import default specifier\\\",\\n  ImportNamespaceSpecifier: \\\"import namespace specifier\\\",\\n  ObjectPattern: \\\"object destructuring pattern\\\",\\n  ParenthesizedExpression: \\\"parenthesized expression\\\",\\n  RestElement: \\\"rest element\\\",\\n  UpdateExpression: {\\n    true: \\\"prefix operation\\\",\\n    false: \\\"postfix operation\\\"\\n  },\\n  VariableDeclarator: \\\"variable declaration\\\",\\n  YieldExpression: \\\"yield expression\\\"\\n};\\nconst toNodeDescription = ({\\n  type,\\n  prefix\\n}) => type === \\\"UpdateExpression\\\" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];\\nvar StandardErrors = {\\n  AccessorIsGenerator: ({\\n    kind\\n  }) => `A ${kind}ter cannot be a generator.`,\\n  ArgumentsInClass: \\\"'arguments' is only allowed in functions and class methods.\\\",\\n  AsyncFunctionInSingleStatementContext: \\\"Async functions can only be declared at the top level or inside a block.\\\",\\n  AwaitBindingIdentifier: \\\"Can not use 'await' as identifier inside an async function.\\\",\\n  AwaitBindingIdentifierInStaticBlock: \\\"Can not use 'await' as identifier inside a static block.\\\",\\n  AwaitExpressionFormalParameter: \\\"'await' is not allowed in async function parameters.\\\",\\n  AwaitUsingNotInAsyncContext: \\\"'await using' is only allowed within async functions and at the top levels of modules.\\\",\\n  AwaitNotInAsyncContext: \\\"'await' is only allowed within async functions and at the top levels of modules.\\\",\\n  AwaitNotInAsyncFunction: \\\"'await' is only allowed within async functions.\\\",\\n  BadGetterArity: \\\"A 'get' accessor must not have any formal parameters.\\\",\\n  BadSetterArity: \\\"A 'set' accessor must have exactly one formal parameter.\\\",\\n  BadSetterRestParameter: \\\"A 'set' accessor function argument must not be a rest parameter.\\\",\\n  ConstructorClassField: \\\"Classes may not have a field named 'constructor'.\\\",\\n  ConstructorClassPrivateField: \\\"Classes may not have a private field named '#constructor'.\\\",\\n  ConstructorIsAccessor: \\\"Class constructor may not be an accessor.\\\",\\n  ConstructorIsAsync: \\\"Constructor can't be an async function.\\\",\\n  ConstructorIsGenerator: \\\"Constructor can't be a generator.\\\",\\n  DeclarationMissingInitializer: ({\\n    kind\\n  }) => `Missing initializer in ${kind} declaration.`,\\n  DecoratorArgumentsOutsideParentheses: \\\"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\\\",\\n  DecoratorBeforeExport: \\\"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\\\",\\n  DecoratorsBeforeAfterExport: \\\"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\\\",\\n  DecoratorConstructor: \\\"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\\\",\\n  DecoratorExportClass: \\\"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\\\",\\n  DecoratorSemicolon: \\\"Decorators must not be followed by a semicolon.\\\",\\n  DecoratorStaticBlock: \\\"Decorators can't be used with a static block.\\\",\\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \\\"./module\\\"` is valid.',\\n  DeletePrivateField: \\\"Deleting a private field is not allowed.\\\",\\n  DestructureNamedImport: \\\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\\\",\\n  DuplicateConstructor: \\\"Duplicate constructor in the same class.\\\",\\n  DuplicateDefaultExport: \\\"Only one default export allowed per module.\\\",\\n  DuplicateExport: ({\\n    exportName\\n  }) => `\\\\`${exportName}\\\\` has already been exported. Exported identifiers must be unique.`,\\n  DuplicateProto: \\\"Redefinition of __proto__ property.\\\",\\n  DuplicateRegExpFlags: \\\"Duplicate regular expression flag.\\\",\\n  DynamicImportPhaseRequiresImportExpressions: ({\\n    phase\\n  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\\n  ElementAfterRest: \\\"Rest element must be last element.\\\",\\n  EscapedCharNotAnIdentifier: \\\"Invalid Unicode escape.\\\",\\n  ExportBindingIsString: ({\\n    localName,\\n    exportName\\n  }) => `A string literal cannot be used as an exported binding without \\\\`from\\\\`.\\\\n- Did you mean \\\\`export { '${localName}' as '${exportName}' } from 'some-module'\\\\`?`,\\n  ExportDefaultFromAsIdentifier: \\\"'from' is not allowed as an identifier after 'export default'.\\\",\\n  ForInOfLoopInitializer: ({\\n    type\\n  }) => `'${type === \\\"ForInStatement\\\" ? \\\"for-in\\\" : \\\"for-of\\\"}' loop variable declaration may not have an initializer.`,\\n  ForInUsing: \\\"For-in loop may not start with 'using' declaration.\\\",\\n  ForOfAsync: \\\"The left-hand side of a for-of loop may not be 'async'.\\\",\\n  ForOfLet: \\\"The left-hand side of a for-of loop may not start with 'let'.\\\",\\n  GeneratorInSingleStatementContext: \\\"Generators can only be declared at the top level or inside a block.\\\",\\n  IllegalBreakContinue: ({\\n    type\\n  }) => `Unsyntactic ${type === \\\"BreakStatement\\\" ? \\\"break\\\" : \\\"continue\\\"}.`,\\n  IllegalLanguageModeDirective: \\\"Illegal 'use strict' directive in function with non-simple parameter list.\\\",\\n  IllegalReturn: \\\"'return' outside of function.\\\",\\n  ImportAttributesUseAssert: \\\"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.\\\",\\n  ImportBindingIsString: ({\\n    importName\\n  }) => `A string literal cannot be used as an imported binding.\\\\n- Did you mean \\\\`import { \\\"${importName}\\\" as foo }\\\\`?`,\\n  ImportCallArgumentTrailingComma: \\\"Trailing comma is disallowed inside import(...) arguments.\\\",\\n  ImportCallArity: ({\\n    maxArgumentCount\\n  }) => `\\\\`import()\\\\` requires exactly ${maxArgumentCount === 1 ? \\\"one argument\\\" : \\\"one or two arguments\\\"}.`,\\n  ImportCallNotNewExpression: \\\"Cannot use new with import(...).\\\",\\n  ImportCallSpreadArgument: \\\"`...` is not allowed in `import()`.\\\",\\n  ImportJSONBindingNotDefault: \\\"A JSON module can only be imported with `default`.\\\",\\n  ImportReflectionHasAssertion: \\\"`import module x` cannot have assertions.\\\",\\n  ImportReflectionNotBinding: 'Only `import module x from \\\"./module\\\"` is valid.',\\n  IncompatibleRegExpUVFlags: \\\"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\\\",\\n  InvalidBigIntLiteral: \\\"Invalid BigIntLiteral.\\\",\\n  InvalidCodePoint: \\\"Code point out of bounds.\\\",\\n  InvalidCoverInitializedName: \\\"Invalid shorthand property initializer.\\\",\\n  InvalidDecimal: \\\"Invalid decimal.\\\",\\n  InvalidDigit: ({\\n    radix\\n  }) => `Expected number in radix ${radix}.`,\\n  InvalidEscapeSequence: \\\"Bad character escape sequence.\\\",\\n  InvalidEscapeSequenceTemplate: \\\"Invalid escape sequence in template.\\\",\\n  InvalidEscapedReservedWord: ({\\n    reservedWord\\n  }) => `Escape sequence in keyword ${reservedWord}.`,\\n  InvalidIdentifier: ({\\n    identifierName\\n  }) => `Invalid identifier ${identifierName}.`,\\n  InvalidLhs: ({\\n    ancestor\\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\\n  InvalidLhsBinding: ({\\n    ancestor\\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\\n  InvalidLhsOptionalChaining: ({\\n    ancestor\\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\\n  InvalidNumber: \\\"Invalid number.\\\",\\n  InvalidOrMissingExponent: \\\"Floating-point numbers require a valid exponent after the 'e'.\\\",\\n  InvalidOrUnexpectedToken: ({\\n    unexpected\\n  }) => `Unexpected character '${unexpected}'.`,\\n  InvalidParenthesizedAssignment: \\\"Invalid parenthesized assignment pattern.\\\",\\n  InvalidPrivateFieldResolution: ({\\n    identifierName\\n  }) => `Private name #${identifierName} is not defined.`,\\n  InvalidPropertyBindingPattern: \\\"Binding member expression.\\\",\\n  InvalidRecordProperty: \\\"Only properties and spread elements are allowed in record definitions.\\\",\\n  InvalidRestAssignmentPattern: \\\"Invalid rest operator's argument.\\\",\\n  LabelRedeclaration: ({\\n    labelName\\n  }) => `Label '${labelName}' is already declared.`,\\n  LetInLexicalBinding: \\\"'let' is disallowed as a lexically bound name.\\\",\\n  LineTerminatorBeforeArrow: \\\"No line break is allowed before '=>'.\\\",\\n  MalformedRegExpFlags: \\\"Invalid regular expression flag.\\\",\\n  MissingClassName: \\\"A class name is required.\\\",\\n  MissingEqInAssignment: \\\"Only '=' operator can be used for specifying default value.\\\",\\n  MissingSemicolon: \\\"Missing semicolon.\\\",\\n  MissingPlugin: ({\\n    missingPlugin\\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\\\", \\\")}.`,\\n  MissingOneOfPlugins: ({\\n    missingPlugin\\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\\\", \\\")}.`,\\n  MissingUnicodeEscape: \\\"Expecting Unicode escape sequence \\\\\\\\uXXXX.\\\",\\n  MixingCoalesceWithLogical: \\\"Nullish coalescing operator(??) requires parens when mixing with logical operators.\\\",\\n  ModuleAttributeDifferentFromType: \\\"The only accepted module attribute is `type`.\\\",\\n  ModuleAttributeInvalidValue: \\\"Only string literals are allowed as module attribute values.\\\",\\n  ModuleAttributesWithDuplicateKeys: ({\\n    key\\n  }) => `Duplicate key \\\"${key}\\\" is not allowed in module attributes.`,\\n  ModuleExportNameHasLoneSurrogate: ({\\n    surrogateCharCode\\n  }) => `An export name cannot include a lone surrogate, found '\\\\\\\\u${surrogateCharCode.toString(16)}'.`,\\n  ModuleExportUndefined: ({\\n    localName\\n  }) => `Export '${localName}' is not defined.`,\\n  MultipleDefaultsInSwitch: \\\"Multiple default clauses.\\\",\\n  NewlineAfterThrow: \\\"Illegal newline after throw.\\\",\\n  NoCatchOrFinally: \\\"Missing catch or finally clause.\\\",\\n  NumberIdentifier: \\\"Identifier directly after number.\\\",\\n  NumericSeparatorInEscapeSequence: \\\"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\\\",\\n  ObsoleteAwaitStar: \\\"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\\\",\\n  OptionalChainingNoNew: \\\"Constructors in/after an Optional Chain are not allowed.\\\",\\n  OptionalChainingNoTemplate: \\\"Tagged Template Literals are not allowed in optionalChain.\\\",\\n  OverrideOnConstructor: \\\"'override' modifier cannot appear on a constructor declaration.\\\",\\n  ParamDupe: \\\"Argument name clash.\\\",\\n  PatternHasAccessor: \\\"Object pattern can't contain getter or setter.\\\",\\n  PatternHasMethod: \\\"Object pattern can't contain methods.\\\",\\n  PrivateInExpectedIn: ({\\n    identifierName\\n  }) => `Private names are only allowed in property accesses (\\\\`obj.#${identifierName}\\\\`) or in \\\\`in\\\\` expressions (\\\\`#${identifierName} in obj\\\\`).`,\\n  PrivateNameRedeclaration: ({\\n    identifierName\\n  }) => `Duplicate private name #${identifierName}.`,\\n  RecordExpressionBarIncorrectEndSyntaxType: \\\"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\\\",\\n  RecordExpressionBarIncorrectStartSyntaxType: \\\"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\\\",\\n  RecordExpressionHashIncorrectStartSyntaxType: \\\"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\\\",\\n  RecordNoProto: \\\"'__proto__' is not allowed in Record expressions.\\\",\\n  RestTrailingComma: \\\"Unexpected trailing comma after rest element.\\\",\\n  SloppyFunction: \\\"In non-strict mode code, functions can only be declared at top level or inside a block.\\\",\\n  SloppyFunctionAnnexB: \\\"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\\\",\\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \\\"./module\\\"` is valid.',\\n  StaticPrototype: \\\"Classes may not have static property named prototype.\\\",\\n  SuperNotAllowed: \\\"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\\\",\\n  SuperPrivateField: \\\"Private fields can't be accessed on super.\\\",\\n  TrailingDecorator: \\\"Decorators must be attached to a class element.\\\",\\n  TupleExpressionBarIncorrectEndSyntaxType: \\\"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\\\",\\n  TupleExpressionBarIncorrectStartSyntaxType: \\\"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\\\",\\n  TupleExpressionHashIncorrectStartSyntaxType: \\\"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\\\",\\n  UnexpectedArgumentPlaceholder: \\\"Unexpected argument placeholder.\\\",\\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \\\"await\\\" after pipeline body; await must have parentheses in minimal proposal.',\\n  UnexpectedDigitAfterHash: \\\"Unexpected digit after hash token.\\\",\\n  UnexpectedImportExport: \\\"'import' and 'export' may only appear at the top level.\\\",\\n  UnexpectedKeyword: ({\\n    keyword\\n  }) => `Unexpected keyword '${keyword}'.`,\\n  UnexpectedLeadingDecorator: \\\"Leading decorators must be attached to a class declaration.\\\",\\n  UnexpectedLexicalDeclaration: \\\"Lexical declaration cannot appear in a single-statement context.\\\",\\n  UnexpectedNewTarget: \\\"`new.target` can only be used in functions or class properties.\\\",\\n  UnexpectedNumericSeparator: \\\"A numeric separator is only allowed between two digits.\\\",\\n  UnexpectedPrivateField: \\\"Unexpected private name.\\\",\\n  UnexpectedReservedWord: ({\\n    reservedWord\\n  }) => `Unexpected reserved word '${reservedWord}'.`,\\n  UnexpectedSuper: \\\"'super' is only allowed in object methods and classes.\\\",\\n  UnexpectedToken: ({\\n    expected,\\n    unexpected\\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \\\"\\\"}${expected ? `, expected \\\"${expected}\\\"` : \\\"\\\"}`,\\n  UnexpectedTokenUnaryExponentiation: \\\"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\\\",\\n  UnexpectedUsingDeclaration: \\\"Using declaration cannot appear in the top level when source type is `script`.\\\",\\n  UnsupportedBind: \\\"Binding should be performed on object property.\\\",\\n  UnsupportedDecoratorExport: \\\"A decorated export must export a class declaration.\\\",\\n  UnsupportedDefaultExport: \\\"Only expressions, functions or classes are allowed as the `default` export.\\\",\\n  UnsupportedImport: \\\"`import` can only be used in `import()` or `import.meta`.\\\",\\n  UnsupportedMetaProperty: ({\\n    target,\\n    onlyValidPropertyName\\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\\n  UnsupportedParameterDecorator: \\\"Decorators cannot be used to decorate parameters.\\\",\\n  UnsupportedPropertyDecorator: \\\"Decorators cannot be used to decorate object literal properties.\\\",\\n  UnsupportedSuper: \\\"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\\\",\\n  UnterminatedComment: \\\"Unterminated comment.\\\",\\n  UnterminatedRegExp: \\\"Unterminated regular expression.\\\",\\n  UnterminatedString: \\\"Unterminated string constant.\\\",\\n  UnterminatedTemplate: \\\"Unterminated template.\\\",\\n  UsingDeclarationHasBindingPattern: \\\"Using declaration cannot have destructuring patterns.\\\",\\n  VarRedeclaration: ({\\n    identifierName\\n  }) => `Identifier '${identifierName}' has already been declared.`,\\n  YieldBindingIdentifier: \\\"Can not use 'yield' as identifier inside a generator.\\\",\\n  YieldInParameter: \\\"Yield expression is not allowed in formal parameters.\\\",\\n  ZeroDigitNumericSeparator: \\\"Numeric separator can not be used after leading 0.\\\"\\n};\\nvar StrictModeErrors = {\\n  StrictDelete: \\\"Deleting local variable in strict mode.\\\",\\n  StrictEvalArguments: ({\\n    referenceName\\n  }) => `Assigning to '${referenceName}' in strict mode.`,\\n  StrictEvalArgumentsBinding: ({\\n    bindingName\\n  }) => `Binding '${bindingName}' in strict mode.`,\\n  StrictFunction: \\\"In strict mode code, functions can only be declared at top level or inside a block.\\\",\\n  StrictNumericEscape: \\\"The only valid numeric escape in strict mode is '\\\\\\\\0'.\\\",\\n  StrictOctalLiteral: \\\"Legacy octal literals are not allowed in strict mode.\\\",\\n  StrictWith: \\\"'with' in strict mode.\\\"\\n};\\nconst UnparenthesizedPipeBodyDescriptions = new Set([\\\"ArrowFunctionExpression\\\", \\\"AssignmentExpression\\\", \\\"ConditionalExpression\\\", \\\"YieldExpression\\\"]);\\nvar PipelineOperatorErrors = {\\n  PipeBodyIsTighter: \\\"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\\\",\\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \\\"proposal\\\": \\\"hack\\\" or \\\"smart\\\" option.',\\n  PipeTopicUnbound: \\\"Topic reference is unbound; it must be inside a pipe body.\\\",\\n  PipeTopicUnconfiguredToken: ({\\n    token\\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \\\"proposal\\\": \\\"hack\\\", \\\"topicToken\\\": \\\"${token}\\\" }.`,\\n  PipeTopicUnused: \\\"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\\\",\\n  PipeUnparenthesizedBody: ({\\n    type\\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\\n    type\\n  })}; please wrap it in parentheses.`,\\n  PipelineBodyNoArrow: 'Unexpected arrow \\\"=>\\\" after pipeline body; arrow function in pipeline body must be parenthesized.',\\n  PipelineBodySequenceExpression: \\\"Pipeline body may not be a comma-separated sequence expression.\\\",\\n  PipelineHeadSequenceExpression: \\\"Pipeline head should not be a comma-separated sequence expression.\\\",\\n  PipelineTopicUnused: \\\"Pipeline is in topic style but does not use topic reference.\\\",\\n  PrimaryTopicNotAllowed: \\\"Topic reference was used in a lexical context without topic binding.\\\",\\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \\\"proposal\\\": \\\"hack\\\" or \\\"smart\\\" option.'\\n};\\nconst _excluded = [\\\"toMessage\\\"],\\n  _excluded2 = [\\\"message\\\"];\\nfunction defineHidden(obj, key, value) {\\n  Object.defineProperty(obj, key, {\\n    enumerable: false,\\n    configurable: true,\\n    value\\n  });\\n}\\nfunction toParseErrorConstructor(_ref) {\\n  let {\\n      toMessage\\n    } = _ref,\\n    properties = _objectWithoutPropertiesLoose(_ref, _excluded);\\n  return function constructor(loc, details) {\\n    const error = new SyntaxError();\\n    Object.assign(error, properties, {\\n      loc,\\n      pos: loc.index\\n    });\\n    if (\\\"missingPlugin\\\" in details) {\\n      Object.assign(error, {\\n        missingPlugin: details.missingPlugin\\n      });\\n    }\\n    defineHidden(error, \\\"clone\\\", function clone(overrides = {}) {\\n      var _overrides$loc;\\n      const {\\n        line,\\n        column,\\n        index\\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\\n    });\\n    defineHidden(error, \\\"details\\\", details);\\n    Object.defineProperty(error, \\\"message\\\", {\\n      configurable: true,\\n      get() {\\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\\n        this.message = message;\\n        return message;\\n      },\\n      set(value) {\\n        Object.defineProperty(this, \\\"message\\\", {\\n          value,\\n          writable: true\\n        });\\n      }\\n    });\\n    return error;\\n  };\\n}\\nfunction ParseErrorEnum(argument, syntaxPlugin) {\\n  if (Array.isArray(argument)) {\\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\\n  }\\n  const ParseErrorConstructors = {};\\n  for (const reasonCode of Object.keys(argument)) {\\n    const template = argument[reasonCode];\\n    const _ref2 = typeof template === \\\"string\\\" ? {\\n        message: () => template\\n      } : typeof template === \\\"function\\\" ? {\\n        message: template\\n      } : template,\\n      {\\n        message\\n      } = _ref2,\\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);\\n    const toMessage = typeof message === \\\"string\\\" ? () => message : message;\\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\\n      code: \\\"BABEL_PARSER_SYNTAX_ERROR\\\",\\n      reasonCode,\\n      toMessage\\n    }, syntaxPlugin ? {\\n      syntaxPlugin\\n    } : {}, rest));\\n  }\\n  return ParseErrorConstructors;\\n}\\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\\nconst {\\n  defineProperty\\n} = Object;\\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\\n  enumerable: false,\\n  value: object[key]\\n});\\nfunction toESTreeLocation(node) {\\n  node.loc.start && toUnenumerable(node.loc.start, \\\"index\\\");\\n  node.loc.end && toUnenumerable(node.loc.end, \\\"index\\\");\\n  return node;\\n}\\nvar estree = superClass => class ESTreeParserMixin extends superClass {\\n  parse() {\\n    const file = toESTreeLocation(super.parse());\\n    if (this.options.tokens) {\\n      file.tokens = file.tokens.map(toESTreeLocation);\\n    }\\n    return file;\\n  }\\n  parseRegExpLiteral({\\n    pattern,\\n    flags\\n  }) {\\n    let regex = null;\\n    try {\\n      regex = new RegExp(pattern, flags);\\n    } catch (e) {}\\n    const node = this.estreeParseLiteral(regex);\\n    node.regex = {\\n      pattern,\\n      flags\\n    };\\n    return node;\\n  }\\n  parseBigIntLiteral(value) {\\n    let bigInt;\\n    try {\\n      bigInt = BigInt(value);\\n    } catch (_unused) {\\n      bigInt = null;\\n    }\\n    const node = this.estreeParseLiteral(bigInt);\\n    node.bigint = String(node.value || value);\\n    return node;\\n  }\\n  parseDecimalLiteral(value) {\\n    const decimal = null;\\n    const node = this.estreeParseLiteral(decimal);\\n    node.decimal = String(node.value || value);\\n    return node;\\n  }\\n  estreeParseLiteral(value) {\\n    return this.parseLiteral(value, \\\"Literal\\\");\\n  }\\n  parseStringLiteral(value) {\\n    return this.estreeParseLiteral(value);\\n  }\\n  parseNumericLiteral(value) {\\n    return this.estreeParseLiteral(value);\\n  }\\n  parseNullLiteral() {\\n    return this.estreeParseLiteral(null);\\n  }\\n  parseBooleanLiteral(value) {\\n    return this.estreeParseLiteral(value);\\n  }\\n  directiveToStmt(directive) {\\n    const expression = directive.value;\\n    delete directive.value;\\n    expression.type = \\\"Literal\\\";\\n    expression.raw = expression.extra.raw;\\n    expression.value = expression.extra.expressionValue;\\n    const stmt = directive;\\n    stmt.type = \\\"ExpressionStatement\\\";\\n    stmt.expression = expression;\\n    stmt.directive = expression.extra.rawValue;\\n    delete expression.extra;\\n    return stmt;\\n  }\\n  initFunction(node, isAsync) {\\n    super.initFunction(node, isAsync);\\n    node.expression = false;\\n  }\\n  checkDeclaration(node) {\\n    if (node != null && this.isObjectProperty(node)) {\\n      this.checkDeclaration(node.value);\\n    } else {\\n      super.checkDeclaration(node);\\n    }\\n  }\\n  getObjectOrClassMethodParams(method) {\\n    return method.value.params;\\n  }\\n  isValidDirective(stmt) {\\n    var _stmt$expression$extr;\\n    return stmt.type === \\\"ExpressionStatement\\\" && stmt.expression.type === \\\"Literal\\\" && typeof stmt.expression.value === \\\"string\\\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\\n  }\\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\\n    node.body = directiveStatements.concat(node.body);\\n    delete node.directives;\\n  }\\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \\\"ClassMethod\\\", true);\\n    if (method.typeParameters) {\\n      method.value.typeParameters = method.typeParameters;\\n      delete method.typeParameters;\\n    }\\n    classBody.body.push(method);\\n  }\\n  parsePrivateName() {\\n    const node = super.parsePrivateName();\\n    {\\n      if (!this.getPluginOption(\\\"estree\\\", \\\"classFeatures\\\")) {\\n        return node;\\n      }\\n    }\\n    return this.convertPrivateNameToPrivateIdentifier(node);\\n  }\\n  convertPrivateNameToPrivateIdentifier(node) {\\n    const name = super.getPrivateNameSV(node);\\n    node = node;\\n    delete node.id;\\n    node.name = name;\\n    node.type = \\\"PrivateIdentifier\\\";\\n    return node;\\n  }\\n  isPrivateName(node) {\\n    {\\n      if (!this.getPluginOption(\\\"estree\\\", \\\"classFeatures\\\")) {\\n        return super.isPrivateName(node);\\n      }\\n    }\\n    return node.type === \\\"PrivateIdentifier\\\";\\n  }\\n  getPrivateNameSV(node) {\\n    {\\n      if (!this.getPluginOption(\\\"estree\\\", \\\"classFeatures\\\")) {\\n        return super.getPrivateNameSV(node);\\n      }\\n    }\\n    return node.name;\\n  }\\n  parseLiteral(value, type) {\\n    const node = super.parseLiteral(value, type);\\n    node.raw = node.extra.raw;\\n    delete node.extra;\\n    return node;\\n  }\\n  parseFunctionBody(node, allowExpression, isMethod = false) {\\n    super.parseFunctionBody(node, allowExpression, isMethod);\\n    node.expression = node.body.type !== \\\"BlockStatement\\\";\\n  }\\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\\n    let funcNode = this.startNode();\\n    funcNode.kind = node.kind;\\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\\n    funcNode.type = \\\"FunctionExpression\\\";\\n    delete funcNode.kind;\\n    node.value = funcNode;\\n    if (type === \\\"ClassPrivateMethod\\\") {\\n      node.computed = false;\\n    }\\n    return this.finishNode(node, \\\"MethodDefinition\\\");\\n  }\\n  parseClassProperty(...args) {\\n    const propertyNode = super.parseClassProperty(...args);\\n    {\\n      if (!this.getPluginOption(\\\"estree\\\", \\\"classFeatures\\\")) {\\n        return propertyNode;\\n      }\\n    }\\n    propertyNode.type = \\\"PropertyDefinition\\\";\\n    return propertyNode;\\n  }\\n  parseClassPrivateProperty(...args) {\\n    const propertyNode = super.parseClassPrivateProperty(...args);\\n    {\\n      if (!this.getPluginOption(\\\"estree\\\", \\\"classFeatures\\\")) {\\n        return propertyNode;\\n      }\\n    }\\n    propertyNode.type = \\\"PropertyDefinition\\\";\\n    propertyNode.computed = false;\\n    return propertyNode;\\n  }\\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\\n    if (node) {\\n      node.type = \\\"Property\\\";\\n      if (node.kind === \\\"method\\\") {\\n        node.kind = \\\"init\\\";\\n      }\\n      node.shorthand = false;\\n    }\\n    return node;\\n  }\\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\\n    if (node) {\\n      node.kind = \\\"init\\\";\\n      node.type = \\\"Property\\\";\\n    }\\n    return node;\\n  }\\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\\n    return type === \\\"Property\\\" ? \\\"value\\\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\\n  }\\n  isAssignable(node, isBinding) {\\n    if (node != null && this.isObjectProperty(node)) {\\n      return this.isAssignable(node.value, isBinding);\\n    }\\n    return super.isAssignable(node, isBinding);\\n  }\\n  toAssignable(node, isLHS = false) {\\n    if (node != null && this.isObjectProperty(node)) {\\n      const {\\n        key,\\n        value\\n      } = node;\\n      if (this.isPrivateName(key)) {\\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\\n      }\\n      this.toAssignable(value, isLHS);\\n    } else {\\n      super.toAssignable(node, isLHS);\\n    }\\n  }\\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\\n    if (prop.kind === \\\"get\\\" || prop.kind === \\\"set\\\") {\\n      this.raise(Errors.PatternHasAccessor, prop.key);\\n    } else if (prop.method) {\\n      this.raise(Errors.PatternHasMethod, prop.key);\\n    } else {\\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\\n    }\\n  }\\n  finishCallExpression(unfinished, optional) {\\n    const node = super.finishCallExpression(unfinished, optional);\\n    if (node.callee.type === \\\"Import\\\") {\\n      node.type = \\\"ImportExpression\\\";\\n      node.source = node.arguments[0];\\n      if (this.hasPlugin(\\\"importAttributes\\\") || this.hasPlugin(\\\"importAssertions\\\")) {\\n        var _node$arguments$, _node$arguments$2;\\n        node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\\n        node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;\\n      }\\n      delete node.arguments;\\n      delete node.callee;\\n    }\\n    return node;\\n  }\\n  toReferencedArguments(node) {\\n    if (node.type === \\\"ImportExpression\\\") {\\n      return;\\n    }\\n    super.toReferencedArguments(node);\\n  }\\n  parseExport(unfinished, decorators) {\\n    const exportStartLoc = this.state.lastTokStartLoc;\\n    const node = super.parseExport(unfinished, decorators);\\n    switch (node.type) {\\n      case \\\"ExportAllDeclaration\\\":\\n        node.exported = null;\\n        break;\\n      case \\\"ExportNamedDeclaration\\\":\\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \\\"ExportNamespaceSpecifier\\\") {\\n          node.type = \\\"ExportAllDeclaration\\\";\\n          node.exported = node.specifiers[0].exported;\\n          delete node.specifiers;\\n        }\\n      case \\\"ExportDefaultDeclaration\\\":\\n        {\\n          var _declaration$decorato;\\n          const {\\n            declaration\\n          } = node;\\n          if ((declaration == null ? void 0 : declaration.type) === \\\"ClassDeclaration\\\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\\n            this.resetStartLocation(node, exportStartLoc);\\n          }\\n        }\\n        break;\\n    }\\n    return node;\\n  }\\n  parseSubscript(base, startLoc, noCalls, state) {\\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\\n    if (state.optionalChainMember) {\\n      if (node.type === \\\"OptionalMemberExpression\\\" || node.type === \\\"OptionalCallExpression\\\") {\\n        node.type = node.type.substring(8);\\n      }\\n      if (state.stop) {\\n        const chain = this.startNodeAtNode(node);\\n        chain.expression = node;\\n        return this.finishNode(chain, \\\"ChainExpression\\\");\\n      }\\n    } else if (node.type === \\\"MemberExpression\\\" || node.type === \\\"CallExpression\\\") {\\n      node.optional = false;\\n    }\\n    return node;\\n  }\\n  isOptionalMemberExpression(node) {\\n    if (node.type === \\\"ChainExpression\\\") {\\n      return node.expression.type === \\\"MemberExpression\\\";\\n    }\\n    return super.isOptionalMemberExpression(node);\\n  }\\n  hasPropertyAsPrivateName(node) {\\n    if (node.type === \\\"ChainExpression\\\") {\\n      node = node.expression;\\n    }\\n    return super.hasPropertyAsPrivateName(node);\\n  }\\n  isObjectProperty(node) {\\n    return node.type === \\\"Property\\\" && node.kind === \\\"init\\\" && !node.method;\\n  }\\n  isObjectMethod(node) {\\n    return node.method || node.kind === \\\"get\\\" || node.kind === \\\"set\\\";\\n  }\\n  finishNodeAt(node, type, endLoc) {\\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\\n  }\\n  resetStartLocation(node, startLoc) {\\n    super.resetStartLocation(node, startLoc);\\n    toESTreeLocation(node);\\n  }\\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\\n    super.resetEndLocation(node, endLoc);\\n    toESTreeLocation(node);\\n  }\\n};\\nclass TokContext {\\n  constructor(token, preserveSpace) {\\n    this.token = void 0;\\n    this.preserveSpace = void 0;\\n    this.token = token;\\n    this.preserveSpace = !!preserveSpace;\\n  }\\n}\\nconst types = {\\n  brace: new TokContext(\\\"{\\\"),\\n  j_oTag: new TokContext(\\\"<tag\\\"),\\n  j_cTag: new TokContext(\\\"</tag\\\"),\\n  j_expr: new TokContext(\\\"<tag>...</tag>\\\", true)\\n};\\n{\\n  types.template = new TokContext(\\\"`\\\", true);\\n}\\nconst beforeExpr = true;\\nconst startsExpr = true;\\nconst isLoop = true;\\nconst isAssign = true;\\nconst prefix = true;\\nconst postfix = true;\\nclass ExportedTokenType {\\n  constructor(label, conf = {}) {\\n    this.label = void 0;\\n    this.keyword = void 0;\\n    this.beforeExpr = void 0;\\n    this.startsExpr = void 0;\\n    this.rightAssociative = void 0;\\n    this.isLoop = void 0;\\n    this.isAssign = void 0;\\n    this.prefix = void 0;\\n    this.postfix = void 0;\\n    this.binop = void 0;\\n    this.label = label;\\n    this.keyword = conf.keyword;\\n    this.beforeExpr = !!conf.beforeExpr;\\n    this.startsExpr = !!conf.startsExpr;\\n    this.rightAssociative = !!conf.rightAssociative;\\n    this.isLoop = !!conf.isLoop;\\n    this.isAssign = !!conf.isAssign;\\n    this.prefix = !!conf.prefix;\\n    this.postfix = !!conf.postfix;\\n    this.binop = conf.binop != null ? conf.binop : null;\\n    {\\n      this.updateContext = null;\\n    }\\n  }\\n}\\nconst keywords$1 = new Map();\\nfunction createKeyword(name, options = {}) {\\n  options.keyword = name;\\n  const token = createToken(name, options);\\n  keywords$1.set(name, token);\\n  return token;\\n}\\nfunction createBinop(name, binop) {\\n  return createToken(name, {\\n    beforeExpr,\\n    binop\\n  });\\n}\\nlet tokenTypeCounter = -1;\\nconst tokenTypes = [];\\nconst tokenLabels = [];\\nconst tokenBinops = [];\\nconst tokenBeforeExprs = [];\\nconst tokenStartsExprs = [];\\nconst tokenPrefixes = [];\\nfunction createToken(name, options = {}) {\\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\\n  ++tokenTypeCounter;\\n  tokenLabels.push(name);\\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\\n  tokenTypes.push(new ExportedTokenType(name, options));\\n  return tokenTypeCounter;\\n}\\nfunction createKeywordLike(name, options = {}) {\\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\\n  ++tokenTypeCounter;\\n  keywords$1.set(name, tokenTypeCounter);\\n  tokenLabels.push(name);\\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\\n  tokenTypes.push(new ExportedTokenType(\\\"name\\\", options));\\n  return tokenTypeCounter;\\n}\\nconst tt = {\\n  bracketL: createToken(\\\"[\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  bracketHashL: createToken(\\\"#[\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  bracketBarL: createToken(\\\"[|\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  bracketR: createToken(\\\"]\\\"),\\n  bracketBarR: createToken(\\\"|]\\\"),\\n  braceL: createToken(\\\"{\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  braceBarL: createToken(\\\"{|\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  braceHashL: createToken(\\\"#{\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  braceR: createToken(\\\"}\\\"),\\n  braceBarR: createToken(\\\"|}\\\"),\\n  parenL: createToken(\\\"(\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  parenR: createToken(\\\")\\\"),\\n  comma: createToken(\\\",\\\", {\\n    beforeExpr\\n  }),\\n  semi: createToken(\\\";\\\", {\\n    beforeExpr\\n  }),\\n  colon: createToken(\\\":\\\", {\\n    beforeExpr\\n  }),\\n  doubleColon: createToken(\\\"::\\\", {\\n    beforeExpr\\n  }),\\n  dot: createToken(\\\".\\\"),\\n  question: createToken(\\\"?\\\", {\\n    beforeExpr\\n  }),\\n  questionDot: createToken(\\\"?.\\\"),\\n  arrow: createToken(\\\"=>\\\", {\\n    beforeExpr\\n  }),\\n  template: createToken(\\\"template\\\"),\\n  ellipsis: createToken(\\\"...\\\", {\\n    beforeExpr\\n  }),\\n  backQuote: createToken(\\\"`\\\", {\\n    startsExpr\\n  }),\\n  dollarBraceL: createToken(\\\"${\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  templateTail: createToken(\\\"...`\\\", {\\n    startsExpr\\n  }),\\n  templateNonTail: createToken(\\\"...${\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  at: createToken(\\\"@\\\"),\\n  hash: createToken(\\\"#\\\", {\\n    startsExpr\\n  }),\\n  interpreterDirective: createToken(\\\"#!...\\\"),\\n  eq: createToken(\\\"=\\\", {\\n    beforeExpr,\\n    isAssign\\n  }),\\n  assign: createToken(\\\"_=\\\", {\\n    beforeExpr,\\n    isAssign\\n  }),\\n  slashAssign: createToken(\\\"_=\\\", {\\n    beforeExpr,\\n    isAssign\\n  }),\\n  xorAssign: createToken(\\\"_=\\\", {\\n    beforeExpr,\\n    isAssign\\n  }),\\n  moduloAssign: createToken(\\\"_=\\\", {\\n    beforeExpr,\\n    isAssign\\n  }),\\n  incDec: createToken(\\\"++/--\\\", {\\n    prefix,\\n    postfix,\\n    startsExpr\\n  }),\\n  bang: createToken(\\\"!\\\", {\\n    beforeExpr,\\n    prefix,\\n    startsExpr\\n  }),\\n  tilde: createToken(\\\"~\\\", {\\n    beforeExpr,\\n    prefix,\\n    startsExpr\\n  }),\\n  doubleCaret: createToken(\\\"^^\\\", {\\n    startsExpr\\n  }),\\n  doubleAt: createToken(\\\"@@\\\", {\\n    startsExpr\\n  }),\\n  pipeline: createBinop(\\\"|>\\\", 0),\\n  nullishCoalescing: createBinop(\\\"??\\\", 1),\\n  logicalOR: createBinop(\\\"||\\\", 1),\\n  logicalAND: createBinop(\\\"&&\\\", 2),\\n  bitwiseOR: createBinop(\\\"|\\\", 3),\\n  bitwiseXOR: createBinop(\\\"^\\\", 4),\\n  bitwiseAND: createBinop(\\\"&\\\", 5),\\n  equality: createBinop(\\\"==/!=/===/!==\\\", 6),\\n  lt: createBinop(\\\"</>/<=/>=\\\", 7),\\n  gt: createBinop(\\\"</>/<=/>=\\\", 7),\\n  relational: createBinop(\\\"</>/<=/>=\\\", 7),\\n  bitShift: createBinop(\\\"<</>>/>>>\\\", 8),\\n  bitShiftL: createBinop(\\\"<</>>/>>>\\\", 8),\\n  bitShiftR: createBinop(\\\"<</>>/>>>\\\", 8),\\n  plusMin: createToken(\\\"+/-\\\", {\\n    beforeExpr,\\n    binop: 9,\\n    prefix,\\n    startsExpr\\n  }),\\n  modulo: createToken(\\\"%\\\", {\\n    binop: 10,\\n    startsExpr\\n  }),\\n  star: createToken(\\\"*\\\", {\\n    binop: 10\\n  }),\\n  slash: createBinop(\\\"/\\\", 10),\\n  exponent: createToken(\\\"**\\\", {\\n    beforeExpr,\\n    binop: 11,\\n    rightAssociative: true\\n  }),\\n  _in: createKeyword(\\\"in\\\", {\\n    beforeExpr,\\n    binop: 7\\n  }),\\n  _instanceof: createKeyword(\\\"instanceof\\\", {\\n    beforeExpr,\\n    binop: 7\\n  }),\\n  _break: createKeyword(\\\"break\\\"),\\n  _case: createKeyword(\\\"case\\\", {\\n    beforeExpr\\n  }),\\n  _catch: createKeyword(\\\"catch\\\"),\\n  _continue: createKeyword(\\\"continue\\\"),\\n  _debugger: createKeyword(\\\"debugger\\\"),\\n  _default: createKeyword(\\\"default\\\", {\\n    beforeExpr\\n  }),\\n  _else: createKeyword(\\\"else\\\", {\\n    beforeExpr\\n  }),\\n  _finally: createKeyword(\\\"finally\\\"),\\n  _function: createKeyword(\\\"function\\\", {\\n    startsExpr\\n  }),\\n  _if: createKeyword(\\\"if\\\"),\\n  _return: createKeyword(\\\"return\\\", {\\n    beforeExpr\\n  }),\\n  _switch: createKeyword(\\\"switch\\\"),\\n  _throw: createKeyword(\\\"throw\\\", {\\n    beforeExpr,\\n    prefix,\\n    startsExpr\\n  }),\\n  _try: createKeyword(\\\"try\\\"),\\n  _var: createKeyword(\\\"var\\\"),\\n  _const: createKeyword(\\\"const\\\"),\\n  _with: createKeyword(\\\"with\\\"),\\n  _new: createKeyword(\\\"new\\\", {\\n    beforeExpr,\\n    startsExpr\\n  }),\\n  _this: createKeyword(\\\"this\\\", {\\n    startsExpr\\n  }),\\n  _super: createKeyword(\\\"super\\\", {\\n    startsExpr\\n  }),\\n  _class: createKeyword(\\\"class\\\", {\\n    startsExpr\\n  }),\\n  _extends: createKeyword(\\\"extends\\\", {\\n    beforeExpr\\n  }),\\n  _export: createKeyword(\\\"export\\\"),\\n  _import: createKeyword(\\\"import\\\", {\\n    startsExpr\\n  }),\\n  _null: createKeyword(\\\"null\\\", {\\n    startsExpr\\n  }),\\n  _true: createKeyword(\\\"true\\\", {\\n    startsExpr\\n  }),\\n  _false: createKeyword(\\\"false\\\", {\\n    startsExpr\\n  }),\\n  _typeof: createKeyword(\\\"typeof\\\", {\\n    beforeExpr,\\n    prefix,\\n    startsExpr\\n  }),\\n  _void: createKeyword(\\\"void\\\", {\\n    beforeExpr,\\n    prefix,\\n    startsExpr\\n  }),\\n  _delete: createKeyword(\\\"delete\\\", {\\n    beforeExpr,\\n    prefix,\\n    startsExpr\\n  }),\\n  _do: createKeyword(\\\"do\\\", {\\n    isLoop,\\n    beforeExpr\\n  }),\\n  _for: createKeyword(\\\"for\\\", {\\n    isLoop\\n  }),\\n  _while: createKeyword(\\\"while\\\", {\\n    isLoop\\n  }),\\n  _as: createKeywordLike(\\\"as\\\", {\\n    startsExpr\\n  }),\\n  _assert: createKeywordLike(\\\"assert\\\", {\\n    startsExpr\\n  }),\\n  _async: createKeywordLike(\\\"async\\\", {\\n    startsExpr\\n  }),\\n  _await: createKeywordLike(\\\"await\\\", {\\n    startsExpr\\n  }),\\n  _defer: createKeywordLike(\\\"defer\\\", {\\n    startsExpr\\n  }),\\n  _from: createKeywordLike(\\\"from\\\", {\\n    startsExpr\\n  }),\\n  _get: createKeywordLike(\\\"get\\\", {\\n    startsExpr\\n  }),\\n  _let: createKeywordLike(\\\"let\\\", {\\n    startsExpr\\n  }),\\n  _meta: createKeywordLike(\\\"meta\\\", {\\n    startsExpr\\n  }),\\n  _of: createKeywordLike(\\\"of\\\", {\\n    startsExpr\\n  }),\\n  _sent: createKeywordLike(\\\"sent\\\", {\\n    startsExpr\\n  }),\\n  _set: createKeywordLike(\\\"set\\\", {\\n    startsExpr\\n  }),\\n  _source: createKeywordLike(\\\"source\\\", {\\n    startsExpr\\n  }),\\n  _static: createKeywordLike(\\\"static\\\", {\\n    startsExpr\\n  }),\\n  _using: createKeywordLike(\\\"using\\\", {\\n    startsExpr\\n  }),\\n  _yield: createKeywordLike(\\\"yield\\\", {\\n    startsExpr\\n  }),\\n  _asserts: createKeywordLike(\\\"asserts\\\", {\\n    startsExpr\\n  }),\\n  _checks: createKeywordLike(\\\"checks\\\", {\\n    startsExpr\\n  }),\\n  _exports: createKeywordLike(\\\"exports\\\", {\\n    startsExpr\\n  }),\\n  _global: createKeywordLike(\\\"global\\\", {\\n    startsExpr\\n  }),\\n  _implements: createKeywordLike(\\\"implements\\\", {\\n    startsExpr\\n  }),\\n  _intrinsic: createKeywordLike(\\\"intrinsic\\\", {\\n    startsExpr\\n  }),\\n  _infer: createKeywordLike(\\\"infer\\\", {\\n    startsExpr\\n  }),\\n  _is: createKeywordLike(\\\"is\\\", {\\n    startsExpr\\n  }),\\n  _mixins: createKeywordLike(\\\"mixins\\\", {\\n    startsExpr\\n  }),\\n  _proto: createKeywordLike(\\\"proto\\\", {\\n    startsExpr\\n  }),\\n  _require: createKeywordLike(\\\"require\\\", {\\n    startsExpr\\n  }),\\n  _satisfies: createKeywordLike(\\\"satisfies\\\", {\\n    startsExpr\\n  }),\\n  _keyof: createKeywordLike(\\\"keyof\\\", {\\n    startsExpr\\n  }),\\n  _readonly: createKeywordLike(\\\"readonly\\\", {\\n    startsExpr\\n  }),\\n  _unique: createKeywordLike(\\\"unique\\\", {\\n    startsExpr\\n  }),\\n  _abstract: createKeywordLike(\\\"abstract\\\", {\\n    startsExpr\\n  }),\\n  _declare: createKeywordLike(\\\"declare\\\", {\\n    startsExpr\\n  }),\\n  _enum: createKeywordLike(\\\"enum\\\", {\\n    startsExpr\\n  }),\\n  _module: createKeywordLike(\\\"module\\\", {\\n    startsExpr\\n  }),\\n  _namespace: createKeywordLike(\\\"namespace\\\", {\\n    startsExpr\\n  }),\\n  _interface: createKeywordLike(\\\"interface\\\", {\\n    startsExpr\\n  }),\\n  _type: createKeywordLike(\\\"type\\\", {\\n    startsExpr\\n  }),\\n  _opaque: createKeywordLike(\\\"opaque\\\", {\\n    startsExpr\\n  }),\\n  name: createToken(\\\"name\\\", {\\n    startsExpr\\n  }),\\n  string: createToken(\\\"string\\\", {\\n    startsExpr\\n  }),\\n  num: createToken(\\\"num\\\", {\\n    startsExpr\\n  }),\\n  bigint: createToken(\\\"bigint\\\", {\\n    startsExpr\\n  }),\\n  decimal: createToken(\\\"decimal\\\", {\\n    startsExpr\\n  }),\\n  regexp: createToken(\\\"regexp\\\", {\\n    startsExpr\\n  }),\\n  privateName: createToken(\\\"#name\\\", {\\n    startsExpr\\n  }),\\n  eof: createToken(\\\"eof\\\"),\\n  jsxName: createToken(\\\"jsxName\\\"),\\n  jsxText: createToken(\\\"jsxText\\\", {\\n    beforeExpr: true\\n  }),\\n  jsxTagStart: createToken(\\\"jsxTagStart\\\", {\\n    startsExpr: true\\n  }),\\n  jsxTagEnd: createToken(\\\"jsxTagEnd\\\"),\\n  placeholder: createToken(\\\"%%\\\", {\\n    startsExpr: true\\n  })\\n};\\nfunction tokenIsIdentifier(token) {\\n  return token >= 93 && token <= 132;\\n}\\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\\n  return token <= 92;\\n}\\nfunction tokenIsKeywordOrIdentifier(token) {\\n  return token >= 58 && token <= 132;\\n}\\nfunction tokenIsLiteralPropertyName(token) {\\n  return token >= 58 && token <= 136;\\n}\\nfunction tokenComesBeforeExpression(token) {\\n  return tokenBeforeExprs[token];\\n}\\nfunction tokenCanStartExpression(token) {\\n  return tokenStartsExprs[token];\\n}\\nfunction tokenIsAssignment(token) {\\n  return token >= 29 && token <= 33;\\n}\\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\\n  return token >= 129 && token <= 131;\\n}\\nfunction tokenIsLoop(token) {\\n  return token >= 90 && token <= 92;\\n}\\nfunction tokenIsKeyword(token) {\\n  return token >= 58 && token <= 92;\\n}\\nfunction tokenIsOperator(token) {\\n  return token >= 39 && token <= 59;\\n}\\nfunction tokenIsPostfix(token) {\\n  return token === 34;\\n}\\nfunction tokenIsPrefix(token) {\\n  return tokenPrefixes[token];\\n}\\nfunction tokenIsTSTypeOperator(token) {\\n  return token >= 121 && token <= 123;\\n}\\nfunction tokenIsTSDeclarationStart(token) {\\n  return token >= 124 && token <= 130;\\n}\\nfunction tokenLabelName(token) {\\n  return tokenLabels[token];\\n}\\nfunction tokenOperatorPrecedence(token) {\\n  return tokenBinops[token];\\n}\\nfunction tokenIsRightAssociative(token) {\\n  return token === 57;\\n}\\nfunction tokenIsTemplate(token) {\\n  return token >= 24 && token <= 25;\\n}\\nfunction getExportedToken(token) {\\n  return tokenTypes[token];\\n}\\n{\\n  tokenTypes[8].updateContext = context => {\\n    context.pop();\\n  };\\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\\n    context.push(types.brace);\\n  };\\n  tokenTypes[22].updateContext = context => {\\n    if (context[context.length - 1] === types.template) {\\n      context.pop();\\n    } else {\\n      context.push(types.template);\\n    }\\n  };\\n  tokenTypes[142].updateContext = context => {\\n    context.push(types.j_expr, types.j_oTag);\\n  };\\n}\\nlet nonASCIIidentifierStartChars = \\\"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u037f\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u052f\\\\u0531-\\\\u0556\\\\u0559\\\\u0560-\\\\u0588\\\\u05d0-\\\\u05ea\\\\u05ef-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u0860-\\\\u086a\\\\u0870-\\\\u0887\\\\u0889-\\\\u088e\\\\u08a0-\\\\u08c9\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0980\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u09fc\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0af9\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c39\\\\u0c3d\\\\u0c58-\\\\u0c5a\\\\u0c5d\\\\u0c60\\\\u0c61\\\\u0c80\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cdd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d04-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d54-\\\\u0d56\\\\u0d5f-\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e86-\\\\u0e8a\\\\u0e8c-\\\\u0ea3\\\\u0ea5\\\\u0ea7-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f5\\\\u13f8-\\\\u13fd\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f8\\\\u1700-\\\\u1711\\\\u171f-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1878\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191e\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19b0-\\\\u19c9\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4c\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1c80-\\\\u1c88\\\\u1c90-\\\\u1cba\\\\u1cbd-\\\\u1cbf\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf3\\\\u1cf5\\\\u1cf6\\\\u1cfa\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2118-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309b-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31bf\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4dbf\\\\u4e00-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua69d\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua7ca\\\\ua7d0\\\\ua7d1\\\\ua7d3\\\\ua7d5-\\\\ua7d9\\\\ua7f2-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua8fd\\\\ua8fe\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\ua9e0-\\\\ua9e4\\\\ua9e6-\\\\ua9ef\\\\ua9fa-\\\\ua9fe\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa7e-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uab30-\\\\uab5a\\\\uab5c-\\\\uab69\\\\uab70-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\\\";\\nlet nonASCIIidentifierChars = \\\"\\\\u200c\\\\u200d\\\\xb7\\\\u0300-\\\\u036f\\\\u0387\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u0669\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06df-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u06f0-\\\\u06f9\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07c0-\\\\u07c9\\\\u07eb-\\\\u07f3\\\\u07fd\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0859-\\\\u085b\\\\u0898-\\\\u089f\\\\u08ca-\\\\u08e1\\\\u08e3-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09cb-\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u09e6-\\\\u09ef\\\\u09fe\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0afa-\\\\u0aff\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b55-\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c00-\\\\u0c04\\\\u0c3c\\\\u0c3e-\\\\u0c44\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c81-\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0cf3\\\\u0d00-\\\\u0d03\\\\u0d3b\\\\u0d3c\\\\u0d3e-\\\\u0d44\\\\u0d46-\\\\u0d48\\\\u0d4a-\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d81-\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0de6-\\\\u0def\\\\u0df2\\\\u0df3\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0e50-\\\\u0e59\\\\u0eb1\\\\u0eb4-\\\\u0ebc\\\\u0ec8-\\\\u0ece\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f3e\\\\u0f3f\\\\u0f71-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102b-\\\\u103e\\\\u1040-\\\\u1049\\\\u1056-\\\\u1059\\\\u105e-\\\\u1060\\\\u1062-\\\\u1064\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u1369-\\\\u1371\\\\u1712-\\\\u1715\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b4-\\\\u17d3\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u180f-\\\\u1819\\\\u18a9\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1946-\\\\u194f\\\\u19d0-\\\\u19da\\\\u1a17-\\\\u1a1b\\\\u1a55-\\\\u1a5e\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1ab0-\\\\u1abd\\\\u1abf-\\\\u1ace\\\\u1b00-\\\\u1b04\\\\u1b34-\\\\u1b44\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1b80-\\\\u1b82\\\\u1ba1-\\\\u1bad\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c24-\\\\u1c37\\\\u1c40-\\\\u1c49\\\\u1c50-\\\\u1c59\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce8\\\\u1ced\\\\u1cf4\\\\u1cf7-\\\\u1cf9\\\\u1dc0-\\\\u1dff\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2d7f\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\u30fb\\\\ua620-\\\\ua629\\\\ua66f\\\\ua674-\\\\ua67d\\\\ua69e\\\\ua69f\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua82c\\\\ua880\\\\ua881\\\\ua8b4-\\\\ua8c5\\\\ua8d0-\\\\ua8d9\\\\ua8e0-\\\\ua8f1\\\\ua8ff-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua953\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\ua9d0-\\\\ua9d9\\\\ua9e5\\\\ua9f0-\\\\ua9f9\\\\uaa29-\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b-\\\\uaa7d\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uaaeb-\\\\uaaef\\\\uaaf5\\\\uaaf6\\\\uabe3-\\\\uabea\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe2f\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\\\\uff65\\\";\\nconst nonASCIIidentifierStart = new RegExp(\\\"[\\\" + nonASCIIidentifierStartChars + \\\"]\\\");\\nconst nonASCIIidentifier = new RegExp(\\\"[\\\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \\\"]\\\");\\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\\nfunction isInAstralSet(code, set) {\\n  let pos = 0x10000;\\n  for (let i = 0, length = set.length; i < length; i += 2) {\\n    pos += set[i];\\n    if (pos > code) return false;\\n    pos += set[i + 1];\\n    if (pos >= code) return true;\\n  }\\n  return false;\\n}\\nfunction isIdentifierStart(code) {\\n  if (code < 65) return code === 36;\\n  if (code <= 90) return true;\\n  if (code < 97) return code === 95;\\n  if (code <= 122) return true;\\n  if (code <= 0xffff) {\\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\\n  }\\n  return isInAstralSet(code, astralIdentifierStartCodes);\\n}\\nfunction isIdentifierChar(code) {\\n  if (code < 48) return code === 36;\\n  if (code < 58) return true;\\n  if (code < 65) return false;\\n  if (code <= 90) return true;\\n  if (code < 97) return code === 95;\\n  if (code <= 122) return true;\\n  if (code <= 0xffff) {\\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\\n  }\\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\\n}\\nconst reservedWords = {\\n  keyword: [\\\"break\\\", \\\"case\\\", \\\"catch\\\", \\\"continue\\\", \\\"debugger\\\", \\\"default\\\", \\\"do\\\", \\\"else\\\", \\\"finally\\\", \\\"for\\\", \\\"function\\\", \\\"if\\\", \\\"return\\\", \\\"switch\\\", \\\"throw\\\", \\\"try\\\", \\\"var\\\", \\\"const\\\", \\\"while\\\", \\\"with\\\", \\\"new\\\", \\\"this\\\", \\\"super\\\", \\\"class\\\", \\\"extends\\\", \\\"export\\\", \\\"import\\\", \\\"null\\\", \\\"true\\\", \\\"false\\\", \\\"in\\\", \\\"instanceof\\\", \\\"typeof\\\", \\\"void\\\", \\\"delete\\\"],\\n  strict: [\\\"implements\\\", \\\"interface\\\", \\\"let\\\", \\\"package\\\", \\\"private\\\", \\\"protected\\\", \\\"public\\\", \\\"static\\\", \\\"yield\\\"],\\n  strictBind: [\\\"eval\\\", \\\"arguments\\\"]\\n};\\nconst keywords = new Set(reservedWords.keyword);\\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\\nfunction isReservedWord(word, inModule) {\\n  return inModule && word === \\\"await\\\" || word === \\\"enum\\\";\\n}\\nfunction isStrictReservedWord(word, inModule) {\\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\\n}\\nfunction isStrictBindOnlyReservedWord(word) {\\n  return reservedWordsStrictBindSet.has(word);\\n}\\nfunction isStrictBindReservedWord(word, inModule) {\\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\\n}\\nfunction isKeyword(word) {\\n  return keywords.has(word);\\n}\\nfunction isIteratorStart(current, next, next2) {\\n  return current === 64 && next === 64 && isIdentifierStart(next2);\\n}\\nconst reservedWordLikeSet = new Set([\\\"break\\\", \\\"case\\\", \\\"catch\\\", \\\"continue\\\", \\\"debugger\\\", \\\"default\\\", \\\"do\\\", \\\"else\\\", \\\"finally\\\", \\\"for\\\", \\\"function\\\", \\\"if\\\", \\\"return\\\", \\\"switch\\\", \\\"throw\\\", \\\"try\\\", \\\"var\\\", \\\"const\\\", \\\"while\\\", \\\"with\\\", \\\"new\\\", \\\"this\\\", \\\"super\\\", \\\"class\\\", \\\"extends\\\", \\\"export\\\", \\\"import\\\", \\\"null\\\", \\\"true\\\", \\\"false\\\", \\\"in\\\", \\\"instanceof\\\", \\\"typeof\\\", \\\"void\\\", \\\"delete\\\", \\\"implements\\\", \\\"interface\\\", \\\"let\\\", \\\"package\\\", \\\"private\\\", \\\"protected\\\", \\\"public\\\", \\\"static\\\", \\\"yield\\\", \\\"eval\\\", \\\"arguments\\\", \\\"enum\\\", \\\"await\\\"]);\\nfunction canBeReservedWord(word) {\\n  return reservedWordLikeSet.has(word);\\n}\\nclass Scope {\\n  constructor(flags) {\\n    this.flags = 0;\\n    this.names = new Map();\\n    this.firstLexicalName = \\\"\\\";\\n    this.flags = flags;\\n  }\\n}\\nclass ScopeHandler {\\n  constructor(parser, inModule) {\\n    this.parser = void 0;\\n    this.scopeStack = [];\\n    this.inModule = void 0;\\n    this.undefinedExports = new Map();\\n    this.parser = parser;\\n    this.inModule = inModule;\\n  }\\n  get inTopLevel() {\\n    return (this.currentScope().flags & 1) > 0;\\n  }\\n  get inFunction() {\\n    return (this.currentVarScopeFlags() & 2) > 0;\\n  }\\n  get allowSuper() {\\n    return (this.currentThisScopeFlags() & 16) > 0;\\n  }\\n  get allowDirectSuper() {\\n    return (this.currentThisScopeFlags() & 32) > 0;\\n  }\\n  get inClass() {\\n    return (this.currentThisScopeFlags() & 64) > 0;\\n  }\\n  get inClassAndNotInNonArrowFunction() {\\n    const flags = this.currentThisScopeFlags();\\n    return (flags & 64) > 0 && (flags & 2) === 0;\\n  }\\n  get inStaticBlock() {\\n    for (let i = this.scopeStack.length - 1;; i--) {\\n      const {\\n        flags\\n      } = this.scopeStack[i];\\n      if (flags & 128) {\\n        return true;\\n      }\\n      if (flags & (387 | 64)) {\\n        return false;\\n      }\\n    }\\n  }\\n  get inNonArrowFunction() {\\n    return (this.currentThisScopeFlags() & 2) > 0;\\n  }\\n  get treatFunctionsAsVar() {\\n    return this.treatFunctionsAsVarInScope(this.currentScope());\\n  }\\n  createScope(flags) {\\n    return new Scope(flags);\\n  }\\n  enter(flags) {\\n    this.scopeStack.push(this.createScope(flags));\\n  }\\n  exit() {\\n    const scope = this.scopeStack.pop();\\n    return scope.flags;\\n  }\\n  treatFunctionsAsVarInScope(scope) {\\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\\n  }\\n  declareName(name, bindingType, loc) {\\n    let scope = this.currentScope();\\n    if (bindingType & 8 || bindingType & 16) {\\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\\n      let type = scope.names.get(name) || 0;\\n      if (bindingType & 16) {\\n        type = type | 4;\\n      } else {\\n        if (!scope.firstLexicalName) {\\n          scope.firstLexicalName = name;\\n        }\\n        type = type | 2;\\n      }\\n      scope.names.set(name, type);\\n      if (bindingType & 8) {\\n        this.maybeExportDefined(scope, name);\\n      }\\n    } else if (bindingType & 4) {\\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\\n        scope = this.scopeStack[i];\\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\\n        this.maybeExportDefined(scope, name);\\n        if (scope.flags & 387) break;\\n      }\\n    }\\n    if (this.parser.inModule && scope.flags & 1) {\\n      this.undefinedExports.delete(name);\\n    }\\n  }\\n  maybeExportDefined(scope, name) {\\n    if (this.parser.inModule && scope.flags & 1) {\\n      this.undefinedExports.delete(name);\\n    }\\n  }\\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\\n      this.parser.raise(Errors.VarRedeclaration, loc, {\\n        identifierName: name\\n      });\\n    }\\n  }\\n  isRedeclaredInScope(scope, name, bindingType) {\\n    if (!(bindingType & 1)) return false;\\n    if (bindingType & 8) {\\n      return scope.names.has(name);\\n    }\\n    const type = scope.names.get(name);\\n    if (bindingType & 16) {\\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\\n    }\\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\\n  }\\n  checkLocalExport(id) {\\n    const {\\n      name\\n    } = id;\\n    const topLevelScope = this.scopeStack[0];\\n    if (!topLevelScope.names.has(name)) {\\n      this.undefinedExports.set(name, id.loc.start);\\n    }\\n  }\\n  currentScope() {\\n    return this.scopeStack[this.scopeStack.length - 1];\\n  }\\n  currentVarScopeFlags() {\\n    for (let i = this.scopeStack.length - 1;; i--) {\\n      const {\\n        flags\\n      } = this.scopeStack[i];\\n      if (flags & 387) {\\n        return flags;\\n      }\\n    }\\n  }\\n  currentThisScopeFlags() {\\n    for (let i = this.scopeStack.length - 1;; i--) {\\n      const {\\n        flags\\n      } = this.scopeStack[i];\\n      if (flags & (387 | 64) && !(flags & 4)) {\\n        return flags;\\n      }\\n    }\\n  }\\n}\\nclass FlowScope extends Scope {\\n  constructor(...args) {\\n    super(...args);\\n    this.declareFunctions = new Set();\\n  }\\n}\\nclass FlowScopeHandler extends ScopeHandler {\\n  createScope(flags) {\\n    return new FlowScope(flags);\\n  }\\n  declareName(name, bindingType, loc) {\\n    const scope = this.currentScope();\\n    if (bindingType & 2048) {\\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\\n      this.maybeExportDefined(scope, name);\\n      scope.declareFunctions.add(name);\\n      return;\\n    }\\n    super.declareName(name, bindingType, loc);\\n  }\\n  isRedeclaredInScope(scope, name, bindingType) {\\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\\n      const type = scope.names.get(name);\\n      return (type & 4) > 0 || (type & 2) > 0;\\n    }\\n    return false;\\n  }\\n  checkLocalExport(id) {\\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\\n      super.checkLocalExport(id);\\n    }\\n  }\\n}\\nclass BaseParser {\\n  constructor() {\\n    this.sawUnambiguousESM = false;\\n    this.ambiguousScriptDifferentAst = false;\\n  }\\n  hasPlugin(pluginConfig) {\\n    if (typeof pluginConfig === \\\"string\\\") {\\n      return this.plugins.has(pluginConfig);\\n    } else {\\n      const [pluginName, pluginOptions] = pluginConfig;\\n      if (!this.hasPlugin(pluginName)) {\\n        return false;\\n      }\\n      const actualOptions = this.plugins.get(pluginName);\\n      for (const key of Object.keys(pluginOptions)) {\\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }\\n  }\\n  getPluginOption(plugin, name) {\\n    var _this$plugins$get;\\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\\n  }\\n}\\nfunction setTrailingComments(node, comments) {\\n  if (node.trailingComments === undefined) {\\n    node.trailingComments = comments;\\n  } else {\\n    node.trailingComments.unshift(...comments);\\n  }\\n}\\nfunction setLeadingComments(node, comments) {\\n  if (node.leadingComments === undefined) {\\n    node.leadingComments = comments;\\n  } else {\\n    node.leadingComments.unshift(...comments);\\n  }\\n}\\nfunction setInnerComments(node, comments) {\\n  if (node.innerComments === undefined) {\\n    node.innerComments = comments;\\n  } else {\\n    node.innerComments.unshift(...comments);\\n  }\\n}\\nfunction adjustInnerComments(node, elements, commentWS) {\\n  let lastElement = null;\\n  let i = elements.length;\\n  while (lastElement === null && i > 0) {\\n    lastElement = elements[--i];\\n  }\\n  if (lastElement === null || lastElement.start > commentWS.start) {\\n    setInnerComments(node, commentWS.comments);\\n  } else {\\n    setTrailingComments(lastElement, commentWS.comments);\\n  }\\n}\\nclass CommentsParser extends BaseParser {\\n  addComment(comment) {\\n    if (this.filename) comment.loc.filename = this.filename;\\n    const {\\n      commentsLen\\n    } = this.state;\\n    if (this.comments.length != commentsLen) this.comments.length = commentsLen;\\n    this.comments.push(comment);\\n    this.state.commentsLen++;\\n  }\\n  processComment(node) {\\n    const {\\n      commentStack\\n    } = this.state;\\n    const commentStackLength = commentStack.length;\\n    if (commentStackLength === 0) return;\\n    let i = commentStackLength - 1;\\n    const lastCommentWS = commentStack[i];\\n    if (lastCommentWS.start === node.end) {\\n      lastCommentWS.leadingNode = node;\\n      i--;\\n    }\\n    const {\\n      start: nodeStart\\n    } = node;\\n    for (; i >= 0; i--) {\\n      const commentWS = commentStack[i];\\n      const commentEnd = commentWS.end;\\n      if (commentEnd > nodeStart) {\\n        commentWS.containingNode = node;\\n        this.finalizeComment(commentWS);\\n        commentStack.splice(i, 1);\\n      } else {\\n        if (commentEnd === nodeStart) {\\n          commentWS.trailingNode = node;\\n        }\\n        break;\\n      }\\n    }\\n  }\\n  finalizeComment(commentWS) {\\n    const {\\n      comments\\n    } = commentWS;\\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\\n      if (commentWS.leadingNode !== null) {\\n        setTrailingComments(commentWS.leadingNode, comments);\\n      }\\n      if (commentWS.trailingNode !== null) {\\n        setLeadingComments(commentWS.trailingNode, comments);\\n      }\\n    } else {\\n      const {\\n        containingNode: node,\\n        start: commentStart\\n      } = commentWS;\\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\\n        switch (node.type) {\\n          case \\\"ObjectExpression\\\":\\n          case \\\"ObjectPattern\\\":\\n          case \\\"RecordExpression\\\":\\n            adjustInnerComments(node, node.properties, commentWS);\\n            break;\\n          case \\\"CallExpression\\\":\\n          case \\\"OptionalCallExpression\\\":\\n            adjustInnerComments(node, node.arguments, commentWS);\\n            break;\\n          case \\\"FunctionDeclaration\\\":\\n          case \\\"FunctionExpression\\\":\\n          case \\\"ArrowFunctionExpression\\\":\\n          case \\\"ObjectMethod\\\":\\n          case \\\"ClassMethod\\\":\\n          case \\\"ClassPrivateMethod\\\":\\n            adjustInnerComments(node, node.params, commentWS);\\n            break;\\n          case \\\"ArrayExpression\\\":\\n          case \\\"ArrayPattern\\\":\\n          case \\\"TupleExpression\\\":\\n            adjustInnerComments(node, node.elements, commentWS);\\n            break;\\n          case \\\"ExportNamedDeclaration\\\":\\n          case \\\"ImportDeclaration\\\":\\n            adjustInnerComments(node, node.specifiers, commentWS);\\n            break;\\n          default:\\n            {\\n              setInnerComments(node, comments);\\n            }\\n        }\\n      } else {\\n        setInnerComments(node, comments);\\n      }\\n    }\\n  }\\n  finalizeRemainingComments() {\\n    const {\\n      commentStack\\n    } = this.state;\\n    for (let i = commentStack.length - 1; i >= 0; i--) {\\n      this.finalizeComment(commentStack[i]);\\n    }\\n    this.state.commentStack = [];\\n  }\\n  resetPreviousNodeTrailingComments(node) {\\n    const {\\n      commentStack\\n    } = this.state;\\n    const {\\n      length\\n    } = commentStack;\\n    if (length === 0) return;\\n    const commentWS = commentStack[length - 1];\\n    if (commentWS.leadingNode === node) {\\n      commentWS.leadingNode = null;\\n    }\\n  }\\n  resetPreviousIdentifierLeadingComments(node) {\\n    const {\\n      commentStack\\n    } = this.state;\\n    const {\\n      length\\n    } = commentStack;\\n    if (length === 0) return;\\n    if (commentStack[length - 1].trailingNode === node) {\\n      commentStack[length - 1].trailingNode = null;\\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\\n      commentStack[length - 2].trailingNode = null;\\n    }\\n  }\\n  takeSurroundingComments(node, start, end) {\\n    const {\\n      commentStack\\n    } = this.state;\\n    const commentStackLength = commentStack.length;\\n    if (commentStackLength === 0) return;\\n    let i = commentStackLength - 1;\\n    for (; i >= 0; i--) {\\n      const commentWS = commentStack[i];\\n      const commentEnd = commentWS.end;\\n      const commentStart = commentWS.start;\\n      if (commentStart === end) {\\n        commentWS.leadingNode = node;\\n      } else if (commentEnd === start) {\\n        commentWS.trailingNode = node;\\n      } else if (commentEnd < start) {\\n        break;\\n      }\\n    }\\n  }\\n}\\nconst lineBreak = /\\\\r\\\\n?|[\\\\n\\\\u2028\\\\u2029]/;\\nconst lineBreakG = new RegExp(lineBreak.source, \\\"g\\\");\\nfunction isNewLine(code) {\\n  switch (code) {\\n    case 10:\\n    case 13:\\n    case 8232:\\n    case 8233:\\n      return true;\\n    default:\\n      return false;\\n  }\\n}\\nconst skipWhiteSpace = /(?:\\\\s|\\\\/\\\\/.*|\\\\/\\\\*[^]*?\\\\*\\\\/)*/g;\\nconst skipWhiteSpaceInLine = /(?:[^\\\\S\\\\n\\\\r\\\\u2028\\\\u2029]|\\\\/\\\\/.*|\\\\/\\\\*.*?\\\\*\\\\/)*/g;\\nconst skipWhiteSpaceToLineBreak = new RegExp(\\\"(?=(\\\" + skipWhiteSpaceInLine.source + \\\"))\\\\\\\\1\\\" + /(?=[\\\\n\\\\r\\\\u2028\\\\u2029]|\\\\/\\\\*(?!.*?\\\\*\\\\/)|$)/.source, \\\"y\\\");\\nfunction isWhitespace(code) {\\n  switch (code) {\\n    case 0x0009:\\n    case 0x000b:\\n    case 0x000c:\\n    case 32:\\n    case 160:\\n    case 5760:\\n    case 0x2000:\\n    case 0x2001:\\n    case 0x2002:\\n    case 0x2003:\\n    case 0x2004:\\n    case 0x2005:\\n    case 0x2006:\\n    case 0x2007:\\n    case 0x2008:\\n    case 0x2009:\\n    case 0x200a:\\n    case 0x202f:\\n    case 0x205f:\\n    case 0x3000:\\n    case 0xfeff:\\n      return true;\\n    default:\\n      return false;\\n  }\\n}\\nclass State {\\n  constructor() {\\n    this.flags = 1024;\\n    this.curLine = void 0;\\n    this.lineStart = void 0;\\n    this.startLoc = void 0;\\n    this.endLoc = void 0;\\n    this.errors = [];\\n    this.potentialArrowAt = -1;\\n    this.noArrowAt = [];\\n    this.noArrowParamsConversionAt = [];\\n    this.topicContext = {\\n      maxNumOfResolvableTopics: 0,\\n      maxTopicIndex: null\\n    };\\n    this.labels = [];\\n    this.commentsLen = 0;\\n    this.commentStack = [];\\n    this.pos = 0;\\n    this.type = 139;\\n    this.value = null;\\n    this.start = 0;\\n    this.end = 0;\\n    this.lastTokEndLoc = null;\\n    this.lastTokStartLoc = null;\\n    this.context = [types.brace];\\n    this.firstInvalidTemplateEscapePos = null;\\n    this.strictErrors = new Map();\\n    this.tokensLength = 0;\\n  }\\n  get strict() {\\n    return (this.flags & 1) > 0;\\n  }\\n  set strict(value) {\\n    if (value) {\\n      this.flags |= 1;\\n    } else {\\n      this.flags &= ~1;\\n    }\\n  }\\n  init({\\n    strictMode,\\n    sourceType,\\n    startLine,\\n    startColumn\\n  }) {\\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \\\"module\\\";\\n    this.curLine = startLine;\\n    this.lineStart = -startColumn;\\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\\n  }\\n  get maybeInArrowParameters() {\\n    return (this.flags & 2) > 0;\\n  }\\n  set maybeInArrowParameters(value) {\\n    if (value) {\\n      this.flags |= 2;\\n    } else {\\n      this.flags &= ~2;\\n    }\\n  }\\n  get inType() {\\n    return (this.flags & 4) > 0;\\n  }\\n  set inType(value) {\\n    if (value) {\\n      this.flags |= 4;\\n    } else {\\n      this.flags &= ~4;\\n    }\\n  }\\n  get noAnonFunctionType() {\\n    return (this.flags & 8) > 0;\\n  }\\n  set noAnonFunctionType(value) {\\n    if (value) {\\n      this.flags |= 8;\\n    } else {\\n      this.flags &= ~8;\\n    }\\n  }\\n  get hasFlowComment() {\\n    return (this.flags & 16) > 0;\\n  }\\n  set hasFlowComment(value) {\\n    if (value) {\\n      this.flags |= 16;\\n    } else {\\n      this.flags &= ~16;\\n    }\\n  }\\n  get isAmbientContext() {\\n    return (this.flags & 32) > 0;\\n  }\\n  set isAmbientContext(value) {\\n    if (value) {\\n      this.flags |= 32;\\n    } else {\\n      this.flags &= ~32;\\n    }\\n  }\\n  get inAbstractClass() {\\n    return (this.flags & 64) > 0;\\n  }\\n  set inAbstractClass(value) {\\n    if (value) {\\n      this.flags |= 64;\\n    } else {\\n      this.flags &= ~64;\\n    }\\n  }\\n  get inDisallowConditionalTypesContext() {\\n    return (this.flags & 128) > 0;\\n  }\\n  set inDisallowConditionalTypesContext(value) {\\n    if (value) {\\n      this.flags |= 128;\\n    } else {\\n      this.flags &= ~128;\\n    }\\n  }\\n  get soloAwait() {\\n    return (this.flags & 256) > 0;\\n  }\\n  set soloAwait(value) {\\n    if (value) {\\n      this.flags |= 256;\\n    } else {\\n      this.flags &= ~256;\\n    }\\n  }\\n  get inFSharpPipelineDirectBody() {\\n    return (this.flags & 512) > 0;\\n  }\\n  set inFSharpPipelineDirectBody(value) {\\n    if (value) {\\n      this.flags |= 512;\\n    } else {\\n      this.flags &= ~512;\\n    }\\n  }\\n  get canStartJSXElement() {\\n    return (this.flags & 1024) > 0;\\n  }\\n  set canStartJSXElement(value) {\\n    if (value) {\\n      this.flags |= 1024;\\n    } else {\\n      this.flags &= ~1024;\\n    }\\n  }\\n  get containsEsc() {\\n    return (this.flags & 2048) > 0;\\n  }\\n  set containsEsc(value) {\\n    if (value) {\\n      this.flags |= 2048;\\n    } else {\\n      this.flags &= ~2048;\\n    }\\n  }\\n  curPosition() {\\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\\n  }\\n  clone() {\\n    const state = new State();\\n    state.flags = this.flags;\\n    state.curLine = this.curLine;\\n    state.lineStart = this.lineStart;\\n    state.startLoc = this.startLoc;\\n    state.endLoc = this.endLoc;\\n    state.errors = this.errors.slice();\\n    state.potentialArrowAt = this.potentialArrowAt;\\n    state.noArrowAt = this.noArrowAt.slice();\\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\\n    state.topicContext = this.topicContext;\\n    state.labels = this.labels.slice();\\n    state.commentsLen = this.commentsLen;\\n    state.commentStack = this.commentStack.slice();\\n    state.pos = this.pos;\\n    state.type = this.type;\\n    state.value = this.value;\\n    state.start = this.start;\\n    state.end = this.end;\\n    state.lastTokEndLoc = this.lastTokEndLoc;\\n    state.lastTokStartLoc = this.lastTokStartLoc;\\n    state.context = this.context.slice();\\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\\n    state.strictErrors = this.strictErrors;\\n    state.tokensLength = this.tokensLength;\\n    return state;\\n  }\\n}\\nvar _isDigit = function isDigit(code) {\\n  return code >= 48 && code <= 57;\\n};\\nconst forbiddenNumericSeparatorSiblings = {\\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\\n  hex: new Set([46, 88, 95, 120])\\n};\\nconst isAllowedNumericSeparatorSibling = {\\n  bin: ch => ch === 48 || ch === 49,\\n  oct: ch => ch >= 48 && ch <= 55,\\n  dec: ch => ch >= 48 && ch <= 57,\\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\\n};\\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\\n  const initialPos = pos;\\n  const initialLineStart = lineStart;\\n  const initialCurLine = curLine;\\n  let out = \\\"\\\";\\n  let firstInvalidLoc = null;\\n  let chunkStart = pos;\\n  const {\\n    length\\n  } = input;\\n  for (;;) {\\n    if (pos >= length) {\\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\\n      out += input.slice(chunkStart, pos);\\n      break;\\n    }\\n    const ch = input.charCodeAt(pos);\\n    if (isStringEnd(type, ch, input, pos)) {\\n      out += input.slice(chunkStart, pos);\\n      break;\\n    }\\n    if (ch === 92) {\\n      out += input.slice(chunkStart, pos);\\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \\\"template\\\", errors);\\n      if (res.ch === null && !firstInvalidLoc) {\\n        firstInvalidLoc = {\\n          pos,\\n          lineStart,\\n          curLine\\n        };\\n      } else {\\n        out += res.ch;\\n      }\\n      ({\\n        pos,\\n        lineStart,\\n        curLine\\n      } = res);\\n      chunkStart = pos;\\n    } else if (ch === 8232 || ch === 8233) {\\n      ++pos;\\n      ++curLine;\\n      lineStart = pos;\\n    } else if (ch === 10 || ch === 13) {\\n      if (type === \\\"template\\\") {\\n        out += input.slice(chunkStart, pos) + \\\"\\\\n\\\";\\n        ++pos;\\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\\n          ++pos;\\n        }\\n        ++curLine;\\n        chunkStart = lineStart = pos;\\n      } else {\\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\\n      }\\n    } else {\\n      ++pos;\\n    }\\n  }\\n  return {\\n    pos,\\n    str: out,\\n    firstInvalidLoc,\\n    lineStart,\\n    curLine,\\n    containsInvalid: !!firstInvalidLoc\\n  };\\n}\\nfunction isStringEnd(type, ch, input, pos) {\\n  if (type === \\\"template\\\") {\\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\\n  }\\n  return ch === (type === \\\"double\\\" ? 34 : 39);\\n}\\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\\n  const throwOnInvalid = !inTemplate;\\n  pos++;\\n  const res = ch => ({\\n    pos,\\n    ch,\\n    lineStart,\\n    curLine\\n  });\\n  const ch = input.charCodeAt(pos++);\\n  switch (ch) {\\n    case 110:\\n      return res(\\\"\\\\n\\\");\\n    case 114:\\n      return res(\\\"\\\\r\\\");\\n    case 120:\\n      {\\n        let code;\\n        ({\\n          code,\\n          pos\\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\\n        return res(code === null ? null : String.fromCharCode(code));\\n      }\\n    case 117:\\n      {\\n        let code;\\n        ({\\n          code,\\n          pos\\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\\n        return res(code === null ? null : String.fromCodePoint(code));\\n      }\\n    case 116:\\n      return res(\\\"\\\\t\\\");\\n    case 98:\\n      return res(\\\"\\\\b\\\");\\n    case 118:\\n      return res(\\\"\\\\u000b\\\");\\n    case 102:\\n      return res(\\\"\\\\f\\\");\\n    case 13:\\n      if (input.charCodeAt(pos) === 10) {\\n        ++pos;\\n      }\\n    case 10:\\n      lineStart = pos;\\n      ++curLine;\\n    case 8232:\\n    case 8233:\\n      return res(\\\"\\\");\\n    case 56:\\n    case 57:\\n      if (inTemplate) {\\n        return res(null);\\n      } else {\\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\\n      }\\n    default:\\n      if (ch >= 48 && ch <= 55) {\\n        const startPos = pos - 1;\\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\\n        let octalStr = match[0];\\n        let octal = parseInt(octalStr, 8);\\n        if (octal > 255) {\\n          octalStr = octalStr.slice(0, -1);\\n          octal = parseInt(octalStr, 8);\\n        }\\n        pos += octalStr.length - 1;\\n        const next = input.charCodeAt(pos);\\n        if (octalStr !== \\\"0\\\" || next === 56 || next === 57) {\\n          if (inTemplate) {\\n            return res(null);\\n          } else {\\n            errors.strictNumericEscape(startPos, lineStart, curLine);\\n          }\\n        }\\n        return res(String.fromCharCode(octal));\\n      }\\n      return res(String.fromCharCode(ch));\\n  }\\n}\\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\\n  const initialPos = pos;\\n  let n;\\n  ({\\n    n,\\n    pos\\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\\n  if (n === null) {\\n    if (throwOnInvalid) {\\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\\n    } else {\\n      pos = initialPos - 1;\\n    }\\n  }\\n  return {\\n    code: n,\\n    pos\\n  };\\n}\\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\\n  const start = pos;\\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\\n  let invalid = false;\\n  let total = 0;\\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\\n    const code = input.charCodeAt(pos);\\n    let val;\\n    if (code === 95 && allowNumSeparator !== \\\"bail\\\") {\\n      const prev = input.charCodeAt(pos - 1);\\n      const next = input.charCodeAt(pos + 1);\\n      if (!allowNumSeparator) {\\n        if (bailOnError) return {\\n          n: null,\\n          pos\\n        };\\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\\n        if (bailOnError) return {\\n          n: null,\\n          pos\\n        };\\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\\n      }\\n      ++pos;\\n      continue;\\n    }\\n    if (code >= 97) {\\n      val = code - 97 + 10;\\n    } else if (code >= 65) {\\n      val = code - 65 + 10;\\n    } else if (_isDigit(code)) {\\n      val = code - 48;\\n    } else {\\n      val = Infinity;\\n    }\\n    if (val >= radix) {\\n      if (val <= 9 && bailOnError) {\\n        return {\\n          n: null,\\n          pos\\n        };\\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\\n        val = 0;\\n      } else if (forceLen) {\\n        val = 0;\\n        invalid = true;\\n      } else {\\n        break;\\n      }\\n    }\\n    ++pos;\\n    total = total * radix + val;\\n  }\\n  if (pos === start || len != null && pos - start !== len || invalid) {\\n    return {\\n      n: null,\\n      pos\\n    };\\n  }\\n  return {\\n    n: total,\\n    pos\\n  };\\n}\\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\\n  const ch = input.charCodeAt(pos);\\n  let code;\\n  if (ch === 123) {\\n    ++pos;\\n    ({\\n      code,\\n      pos\\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\\\"}\\\", pos) - pos, true, throwOnInvalid, errors));\\n    ++pos;\\n    if (code !== null && code > 0x10ffff) {\\n      if (throwOnInvalid) {\\n        errors.invalidCodePoint(pos, lineStart, curLine);\\n      } else {\\n        return {\\n          code: null,\\n          pos\\n        };\\n      }\\n    }\\n  } else {\\n    ({\\n      code,\\n      pos\\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\\n  }\\n  return {\\n    code,\\n    pos\\n  };\\n}\\nfunction buildPosition(pos, lineStart, curLine) {\\n  return new Position(curLine, pos - lineStart, pos);\\n}\\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\\nclass Token {\\n  constructor(state) {\\n    this.type = state.type;\\n    this.value = state.value;\\n    this.start = state.start;\\n    this.end = state.end;\\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\\n  }\\n}\\nclass Tokenizer extends CommentsParser {\\n  constructor(options, input) {\\n    super();\\n    this.isLookahead = void 0;\\n    this.tokens = [];\\n    this.errorHandlers_readInt = {\\n      invalidDigit: (pos, lineStart, curLine, radix) => {\\n        if (!this.options.errorRecovery) return false;\\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\\n          radix\\n        });\\n        return true;\\n      },\\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\\n    };\\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\\n    });\\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\\n      strictNumericEscape: (pos, lineStart, curLine) => {\\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\\n      },\\n      unterminated: (pos, lineStart, curLine) => {\\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\\n      }\\n    });\\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\\n      unterminated: (pos, lineStart, curLine) => {\\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\\n      }\\n    });\\n    this.state = new State();\\n    this.state.init(options);\\n    this.input = input;\\n    this.length = input.length;\\n    this.comments = [];\\n    this.isLookahead = false;\\n  }\\n  pushToken(token) {\\n    this.tokens.length = this.state.tokensLength;\\n    this.tokens.push(token);\\n    ++this.state.tokensLength;\\n  }\\n  next() {\\n    this.checkKeywordEscapes();\\n    if (this.options.tokens) {\\n      this.pushToken(new Token(this.state));\\n    }\\n    this.state.lastTokEndLoc = this.state.endLoc;\\n    this.state.lastTokStartLoc = this.state.startLoc;\\n    this.nextToken();\\n  }\\n  eat(type) {\\n    if (this.match(type)) {\\n      this.next();\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n  match(type) {\\n    return this.state.type === type;\\n  }\\n  createLookaheadState(state) {\\n    return {\\n      pos: state.pos,\\n      value: null,\\n      type: state.type,\\n      start: state.start,\\n      end: state.end,\\n      context: [this.curContext()],\\n      inType: state.inType,\\n      startLoc: state.startLoc,\\n      lastTokEndLoc: state.lastTokEndLoc,\\n      curLine: state.curLine,\\n      lineStart: state.lineStart,\\n      curPosition: state.curPosition\\n    };\\n  }\\n  lookahead() {\\n    const old = this.state;\\n    this.state = this.createLookaheadState(old);\\n    this.isLookahead = true;\\n    this.nextToken();\\n    this.isLookahead = false;\\n    const curr = this.state;\\n    this.state = old;\\n    return curr;\\n  }\\n  nextTokenStart() {\\n    return this.nextTokenStartSince(this.state.pos);\\n  }\\n  nextTokenStartSince(pos) {\\n    skipWhiteSpace.lastIndex = pos;\\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\\n  }\\n  lookaheadCharCode() {\\n    return this.input.charCodeAt(this.nextTokenStart());\\n  }\\n  nextTokenInLineStart() {\\n    return this.nextTokenInLineStartSince(this.state.pos);\\n  }\\n  nextTokenInLineStartSince(pos) {\\n    skipWhiteSpaceInLine.lastIndex = pos;\\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\\n  }\\n  lookaheadInLineCharCode() {\\n    return this.input.charCodeAt(this.nextTokenInLineStart());\\n  }\\n  codePointAtPos(pos) {\\n    let cp = this.input.charCodeAt(pos);\\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\\n      const trail = this.input.charCodeAt(pos);\\n      if ((trail & 0xfc00) === 0xdc00) {\\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\\n      }\\n    }\\n    return cp;\\n  }\\n  setStrict(strict) {\\n    this.state.strict = strict;\\n    if (strict) {\\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\\n      this.state.strictErrors.clear();\\n    }\\n  }\\n  curContext() {\\n    return this.state.context[this.state.context.length - 1];\\n  }\\n  nextToken() {\\n    this.skipSpace();\\n    this.state.start = this.state.pos;\\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\\n    if (this.state.pos >= this.length) {\\n      this.finishToken(139);\\n      return;\\n    }\\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\\n  }\\n  skipBlockComment(commentEnd) {\\n    let startLoc;\\n    if (!this.isLookahead) startLoc = this.state.curPosition();\\n    const start = this.state.pos;\\n    const end = this.input.indexOf(commentEnd, start + 2);\\n    if (end === -1) {\\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\\n    }\\n    this.state.pos = end + commentEnd.length;\\n    lineBreakG.lastIndex = start + 2;\\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\\n      ++this.state.curLine;\\n      this.state.lineStart = lineBreakG.lastIndex;\\n    }\\n    if (this.isLookahead) return;\\n    const comment = {\\n      type: \\\"CommentBlock\\\",\\n      value: this.input.slice(start + 2, end),\\n      start,\\n      end: end + commentEnd.length,\\n      loc: new SourceLocation(startLoc, this.state.curPosition())\\n    };\\n    if (this.options.tokens) this.pushToken(comment);\\n    return comment;\\n  }\\n  skipLineComment(startSkip) {\\n    const start = this.state.pos;\\n    let startLoc;\\n    if (!this.isLookahead) startLoc = this.state.curPosition();\\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\\n    if (this.state.pos < this.length) {\\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\\n        ch = this.input.charCodeAt(this.state.pos);\\n      }\\n    }\\n    if (this.isLookahead) return;\\n    const end = this.state.pos;\\n    const value = this.input.slice(start + startSkip, end);\\n    const comment = {\\n      type: \\\"CommentLine\\\",\\n      value,\\n      start,\\n      end,\\n      loc: new SourceLocation(startLoc, this.state.curPosition())\\n    };\\n    if (this.options.tokens) this.pushToken(comment);\\n    return comment;\\n  }\\n  skipSpace() {\\n    const spaceStart = this.state.pos;\\n    const comments = [];\\n    loop: while (this.state.pos < this.length) {\\n      const ch = this.input.charCodeAt(this.state.pos);\\n      switch (ch) {\\n        case 32:\\n        case 160:\\n        case 9:\\n          ++this.state.pos;\\n          break;\\n        case 13:\\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\\n            ++this.state.pos;\\n          }\\n        case 10:\\n        case 8232:\\n        case 8233:\\n          ++this.state.pos;\\n          ++this.state.curLine;\\n          this.state.lineStart = this.state.pos;\\n          break;\\n        case 47:\\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\\n            case 42:\\n              {\\n                const comment = this.skipBlockComment(\\\"*/\\\");\\n                if (comment !== undefined) {\\n                  this.addComment(comment);\\n                  if (this.options.attachComment) comments.push(comment);\\n                }\\n                break;\\n              }\\n            case 47:\\n              {\\n                const comment = this.skipLineComment(2);\\n                if (comment !== undefined) {\\n                  this.addComment(comment);\\n                  if (this.options.attachComment) comments.push(comment);\\n                }\\n                break;\\n              }\\n            default:\\n              break loop;\\n          }\\n          break;\\n        default:\\n          if (isWhitespace(ch)) {\\n            ++this.state.pos;\\n          } else if (ch === 45 && !this.inModule && this.options.annexB) {\\n            const pos = this.state.pos;\\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\\n              const comment = this.skipLineComment(3);\\n              if (comment !== undefined) {\\n                this.addComment(comment);\\n                if (this.options.attachComment) comments.push(comment);\\n              }\\n            } else {\\n              break loop;\\n            }\\n          } else if (ch === 60 && !this.inModule && this.options.annexB) {\\n            const pos = this.state.pos;\\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\\n              const comment = this.skipLineComment(4);\\n              if (comment !== undefined) {\\n                this.addComment(comment);\\n                if (this.options.attachComment) comments.push(comment);\\n              }\\n            } else {\\n              break loop;\\n            }\\n          } else {\\n            break loop;\\n          }\\n      }\\n    }\\n    if (comments.length > 0) {\\n      const end = this.state.pos;\\n      const commentWhitespace = {\\n        start: spaceStart,\\n        end,\\n        comments,\\n        leadingNode: null,\\n        trailingNode: null,\\n        containingNode: null\\n      };\\n      this.state.commentStack.push(commentWhitespace);\\n    }\\n  }\\n  finishToken(type, val) {\\n    this.state.end = this.state.pos;\\n    this.state.endLoc = this.state.curPosition();\\n    const prevType = this.state.type;\\n    this.state.type = type;\\n    this.state.value = val;\\n    if (!this.isLookahead) {\\n      this.updateContext(prevType);\\n    }\\n  }\\n  replaceToken(type) {\\n    this.state.type = type;\\n    this.updateContext();\\n  }\\n  readToken_numberSign() {\\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\\n      return;\\n    }\\n    const nextPos = this.state.pos + 1;\\n    const next = this.codePointAtPos(nextPos);\\n    if (next >= 48 && next <= 57) {\\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\\n    }\\n    if (next === 123 || next === 91 && this.hasPlugin(\\\"recordAndTuple\\\")) {\\n      this.expectPlugin(\\\"recordAndTuple\\\");\\n      if (this.getPluginOption(\\\"recordAndTuple\\\", \\\"syntaxType\\\") === \\\"bar\\\") {\\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\\n      }\\n      this.state.pos += 2;\\n      if (next === 123) {\\n        this.finishToken(7);\\n      } else {\\n        this.finishToken(1);\\n      }\\n    } else if (isIdentifierStart(next)) {\\n      ++this.state.pos;\\n      this.finishToken(138, this.readWord1(next));\\n    } else if (next === 92) {\\n      ++this.state.pos;\\n      this.finishToken(138, this.readWord1());\\n    } else {\\n      this.finishOp(27, 1);\\n    }\\n  }\\n  readToken_dot() {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next >= 48 && next <= 57) {\\n      this.readNumber(true);\\n      return;\\n    }\\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\\n      this.state.pos += 3;\\n      this.finishToken(21);\\n    } else {\\n      ++this.state.pos;\\n      this.finishToken(16);\\n    }\\n  }\\n  readToken_slash() {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next === 61) {\\n      this.finishOp(31, 2);\\n    } else {\\n      this.finishOp(56, 1);\\n    }\\n  }\\n  readToken_interpreter() {\\n    if (this.state.pos !== 0 || this.length < 2) return false;\\n    let ch = this.input.charCodeAt(this.state.pos + 1);\\n    if (ch !== 33) return false;\\n    const start = this.state.pos;\\n    this.state.pos += 1;\\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\\n      ch = this.input.charCodeAt(this.state.pos);\\n    }\\n    const value = this.input.slice(start + 2, this.state.pos);\\n    this.finishToken(28, value);\\n    return true;\\n  }\\n  readToken_mult_modulo(code) {\\n    let type = code === 42 ? 55 : 54;\\n    let width = 1;\\n    let next = this.input.charCodeAt(this.state.pos + 1);\\n    if (code === 42 && next === 42) {\\n      width++;\\n      next = this.input.charCodeAt(this.state.pos + 2);\\n      type = 57;\\n    }\\n    if (next === 61 && !this.state.inType) {\\n      width++;\\n      type = code === 37 ? 33 : 30;\\n    }\\n    this.finishOp(type, width);\\n  }\\n  readToken_pipe_amp(code) {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next === code) {\\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\\n        this.finishOp(30, 3);\\n      } else {\\n        this.finishOp(code === 124 ? 41 : 42, 2);\\n      }\\n      return;\\n    }\\n    if (code === 124) {\\n      if (next === 62) {\\n        this.finishOp(39, 2);\\n        return;\\n      }\\n      if (this.hasPlugin(\\\"recordAndTuple\\\") && next === 125) {\\n        if (this.getPluginOption(\\\"recordAndTuple\\\", \\\"syntaxType\\\") !== \\\"bar\\\") {\\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\\n        }\\n        this.state.pos += 2;\\n        this.finishToken(9);\\n        return;\\n      }\\n      if (this.hasPlugin(\\\"recordAndTuple\\\") && next === 93) {\\n        if (this.getPluginOption(\\\"recordAndTuple\\\", \\\"syntaxType\\\") !== \\\"bar\\\") {\\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\\n        }\\n        this.state.pos += 2;\\n        this.finishToken(4);\\n        return;\\n      }\\n    }\\n    if (next === 61) {\\n      this.finishOp(30, 2);\\n      return;\\n    }\\n    this.finishOp(code === 124 ? 43 : 45, 1);\\n  }\\n  readToken_caret() {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next === 61 && !this.state.inType) {\\n      this.finishOp(32, 2);\\n    } else if (next === 94 && this.hasPlugin([\\\"pipelineOperator\\\", {\\n      proposal: \\\"hack\\\",\\n      topicToken: \\\"^^\\\"\\n    }])) {\\n      this.finishOp(37, 2);\\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\\n      if (lookaheadCh === 94) {\\n        this.unexpected();\\n      }\\n    } else {\\n      this.finishOp(44, 1);\\n    }\\n  }\\n  readToken_atSign() {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next === 64 && this.hasPlugin([\\\"pipelineOperator\\\", {\\n      proposal: \\\"hack\\\",\\n      topicToken: \\\"@@\\\"\\n    }])) {\\n      this.finishOp(38, 2);\\n    } else {\\n      this.finishOp(26, 1);\\n    }\\n  }\\n  readToken_plus_min(code) {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next === code) {\\n      this.finishOp(34, 2);\\n      return;\\n    }\\n    if (next === 61) {\\n      this.finishOp(30, 2);\\n    } else {\\n      this.finishOp(53, 1);\\n    }\\n  }\\n  readToken_lt() {\\n    const {\\n      pos\\n    } = this.state;\\n    const next = this.input.charCodeAt(pos + 1);\\n    if (next === 60) {\\n      if (this.input.charCodeAt(pos + 2) === 61) {\\n        this.finishOp(30, 3);\\n        return;\\n      }\\n      this.finishOp(51, 2);\\n      return;\\n    }\\n    if (next === 61) {\\n      this.finishOp(49, 2);\\n      return;\\n    }\\n    this.finishOp(47, 1);\\n  }\\n  readToken_gt() {\\n    const {\\n      pos\\n    } = this.state;\\n    const next = this.input.charCodeAt(pos + 1);\\n    if (next === 62) {\\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\\n      if (this.input.charCodeAt(pos + size) === 61) {\\n        this.finishOp(30, size + 1);\\n        return;\\n      }\\n      this.finishOp(52, size);\\n      return;\\n    }\\n    if (next === 61) {\\n      this.finishOp(49, 2);\\n      return;\\n    }\\n    this.finishOp(48, 1);\\n  }\\n  readToken_eq_excl(code) {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (next === 61) {\\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\\n      return;\\n    }\\n    if (code === 61 && next === 62) {\\n      this.state.pos += 2;\\n      this.finishToken(19);\\n      return;\\n    }\\n    this.finishOp(code === 61 ? 29 : 35, 1);\\n  }\\n  readToken_question() {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\\n    if (next === 63) {\\n      if (next2 === 61) {\\n        this.finishOp(30, 3);\\n      } else {\\n        this.finishOp(40, 2);\\n      }\\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\\n      this.state.pos += 2;\\n      this.finishToken(18);\\n    } else {\\n      ++this.state.pos;\\n      this.finishToken(17);\\n    }\\n  }\\n  getTokenFromCode(code) {\\n    switch (code) {\\n      case 46:\\n        this.readToken_dot();\\n        return;\\n      case 40:\\n        ++this.state.pos;\\n        this.finishToken(10);\\n        return;\\n      case 41:\\n        ++this.state.pos;\\n        this.finishToken(11);\\n        return;\\n      case 59:\\n        ++this.state.pos;\\n        this.finishToken(13);\\n        return;\\n      case 44:\\n        ++this.state.pos;\\n        this.finishToken(12);\\n        return;\\n      case 91:\\n        if (this.hasPlugin(\\\"recordAndTuple\\\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\\n          if (this.getPluginOption(\\\"recordAndTuple\\\", \\\"syntaxType\\\") !== \\\"bar\\\") {\\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\\n          }\\n          this.state.pos += 2;\\n          this.finishToken(2);\\n        } else {\\n          ++this.state.pos;\\n          this.finishToken(0);\\n        }\\n        return;\\n      case 93:\\n        ++this.state.pos;\\n        this.finishToken(3);\\n        return;\\n      case 123:\\n        if (this.hasPlugin(\\\"recordAndTuple\\\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\\n          if (this.getPluginOption(\\\"recordAndTuple\\\", \\\"syntaxType\\\") !== \\\"bar\\\") {\\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\\n          }\\n          this.state.pos += 2;\\n          this.finishToken(6);\\n        } else {\\n          ++this.state.pos;\\n          this.finishToken(5);\\n        }\\n        return;\\n      case 125:\\n        ++this.state.pos;\\n        this.finishToken(8);\\n        return;\\n      case 58:\\n        if (this.hasPlugin(\\\"functionBind\\\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\\n          this.finishOp(15, 2);\\n        } else {\\n          ++this.state.pos;\\n          this.finishToken(14);\\n        }\\n        return;\\n      case 63:\\n        this.readToken_question();\\n        return;\\n      case 96:\\n        this.readTemplateToken();\\n        return;\\n      case 48:\\n        {\\n          const next = this.input.charCodeAt(this.state.pos + 1);\\n          if (next === 120 || next === 88) {\\n            this.readRadixNumber(16);\\n            return;\\n          }\\n          if (next === 111 || next === 79) {\\n            this.readRadixNumber(8);\\n            return;\\n          }\\n          if (next === 98 || next === 66) {\\n            this.readRadixNumber(2);\\n            return;\\n          }\\n        }\\n      case 49:\\n      case 50:\\n      case 51:\\n      case 52:\\n      case 53:\\n      case 54:\\n      case 55:\\n      case 56:\\n      case 57:\\n        this.readNumber(false);\\n        return;\\n      case 34:\\n      case 39:\\n        this.readString(code);\\n        return;\\n      case 47:\\n        this.readToken_slash();\\n        return;\\n      case 37:\\n      case 42:\\n        this.readToken_mult_modulo(code);\\n        return;\\n      case 124:\\n      case 38:\\n        this.readToken_pipe_amp(code);\\n        return;\\n      case 94:\\n        this.readToken_caret();\\n        return;\\n      case 43:\\n      case 45:\\n        this.readToken_plus_min(code);\\n        return;\\n      case 60:\\n        this.readToken_lt();\\n        return;\\n      case 62:\\n        this.readToken_gt();\\n        return;\\n      case 61:\\n      case 33:\\n        this.readToken_eq_excl(code);\\n        return;\\n      case 126:\\n        this.finishOp(36, 1);\\n        return;\\n      case 64:\\n        this.readToken_atSign();\\n        return;\\n      case 35:\\n        this.readToken_numberSign();\\n        return;\\n      case 92:\\n        this.readWord();\\n        return;\\n      default:\\n        if (isIdentifierStart(code)) {\\n          this.readWord(code);\\n          return;\\n        }\\n    }\\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\\n      unexpected: String.fromCodePoint(code)\\n    });\\n  }\\n  finishOp(type, size) {\\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\\n    this.state.pos += size;\\n    this.finishToken(type, str);\\n  }\\n  readRegexp() {\\n    const startLoc = this.state.startLoc;\\n    const start = this.state.start + 1;\\n    let escaped, inClass;\\n    let {\\n      pos\\n    } = this.state;\\n    for (;; ++pos) {\\n      if (pos >= this.length) {\\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\\n      }\\n      const ch = this.input.charCodeAt(pos);\\n      if (isNewLine(ch)) {\\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\\n      }\\n      if (escaped) {\\n        escaped = false;\\n      } else {\\n        if (ch === 91) {\\n          inClass = true;\\n        } else if (ch === 93 && inClass) {\\n          inClass = false;\\n        } else if (ch === 47 && !inClass) {\\n          break;\\n        }\\n        escaped = ch === 92;\\n      }\\n    }\\n    const content = this.input.slice(start, pos);\\n    ++pos;\\n    let mods = \\\"\\\";\\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\\n    while (pos < this.length) {\\n      const cp = this.codePointAtPos(pos);\\n      const char = String.fromCharCode(cp);\\n      if (VALID_REGEX_FLAGS.has(cp)) {\\n        if (cp === 118) {\\n          if (mods.includes(\\\"u\\\")) {\\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\\n          }\\n        } else if (cp === 117) {\\n          if (mods.includes(\\\"v\\\")) {\\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\\n          }\\n        }\\n        if (mods.includes(char)) {\\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\\n        }\\n      } else if (isIdentifierChar(cp) || cp === 92) {\\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\\n      } else {\\n        break;\\n      }\\n      ++pos;\\n      mods += char;\\n    }\\n    this.state.pos = pos;\\n    this.finishToken(137, {\\n      pattern: content,\\n      flags: mods\\n    });\\n  }\\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\\n    const {\\n      n,\\n      pos\\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\\n    this.state.pos = pos;\\n    return n;\\n  }\\n  readRadixNumber(radix) {\\n    const startLoc = this.state.curPosition();\\n    let isBigInt = false;\\n    this.state.pos += 2;\\n    const val = this.readInt(radix);\\n    if (val == null) {\\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\\n        radix\\n      });\\n    }\\n    const next = this.input.charCodeAt(this.state.pos);\\n    if (next === 110) {\\n      ++this.state.pos;\\n      isBigInt = true;\\n    } else if (next === 109) {\\n      throw this.raise(Errors.InvalidDecimal, startLoc);\\n    }\\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\\n    }\\n    if (isBigInt) {\\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \\\"\\\");\\n      this.finishToken(135, str);\\n      return;\\n    }\\n    this.finishToken(134, val);\\n  }\\n  readNumber(startsWithDot) {\\n    const start = this.state.pos;\\n    const startLoc = this.state.curPosition();\\n    let isFloat = false;\\n    let isBigInt = false;\\n    let isDecimal = false;\\n    let hasExponent = false;\\n    let isOctal = false;\\n    if (!startsWithDot && this.readInt(10) === null) {\\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\\n    }\\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\\n    if (hasLeadingZero) {\\n      const integer = this.input.slice(start, this.state.pos);\\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\\n      if (!this.state.strict) {\\n        const underscorePos = integer.indexOf(\\\"_\\\");\\n        if (underscorePos > 0) {\\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\\n        }\\n      }\\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\\n    }\\n    let next = this.input.charCodeAt(this.state.pos);\\n    if (next === 46 && !isOctal) {\\n      ++this.state.pos;\\n      this.readInt(10);\\n      isFloat = true;\\n      next = this.input.charCodeAt(this.state.pos);\\n    }\\n    if ((next === 69 || next === 101) && !isOctal) {\\n      next = this.input.charCodeAt(++this.state.pos);\\n      if (next === 43 || next === 45) {\\n        ++this.state.pos;\\n      }\\n      if (this.readInt(10) === null) {\\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\\n      }\\n      isFloat = true;\\n      hasExponent = true;\\n      next = this.input.charCodeAt(this.state.pos);\\n    }\\n    if (next === 110) {\\n      if (isFloat || hasLeadingZero) {\\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\\n      }\\n      ++this.state.pos;\\n      isBigInt = true;\\n    }\\n    if (next === 109) {\\n      this.expectPlugin(\\\"decimal\\\", this.state.curPosition());\\n      if (hasExponent || hasLeadingZero) {\\n        this.raise(Errors.InvalidDecimal, startLoc);\\n      }\\n      ++this.state.pos;\\n      isDecimal = true;\\n    }\\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\\n    }\\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \\\"\\\");\\n    if (isBigInt) {\\n      this.finishToken(135, str);\\n      return;\\n    }\\n    if (isDecimal) {\\n      this.finishToken(136, str);\\n      return;\\n    }\\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\\n    this.finishToken(134, val);\\n  }\\n  readCodePoint(throwOnInvalid) {\\n    const {\\n      code,\\n      pos\\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\\n    this.state.pos = pos;\\n    return code;\\n  }\\n  readString(quote) {\\n    const {\\n      str,\\n      pos,\\n      curLine,\\n      lineStart\\n    } = readStringContents(quote === 34 ? \\\"double\\\" : \\\"single\\\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\\n    this.state.pos = pos + 1;\\n    this.state.lineStart = lineStart;\\n    this.state.curLine = curLine;\\n    this.finishToken(133, str);\\n  }\\n  readTemplateContinuation() {\\n    if (!this.match(8)) {\\n      this.unexpected(null, 8);\\n    }\\n    this.state.pos--;\\n    this.readTemplateToken();\\n  }\\n  readTemplateToken() {\\n    const opening = this.input[this.state.pos];\\n    const {\\n      str,\\n      firstInvalidLoc,\\n      pos,\\n      curLine,\\n      lineStart\\n    } = readStringContents(\\\"template\\\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\\n    this.state.pos = pos + 1;\\n    this.state.lineStart = lineStart;\\n    this.state.curLine = curLine;\\n    if (firstInvalidLoc) {\\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);\\n    }\\n    if (this.input.codePointAt(pos) === 96) {\\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \\\"`\\\");\\n    } else {\\n      this.state.pos++;\\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \\\"${\\\");\\n    }\\n  }\\n  recordStrictModeErrors(toParseError, at) {\\n    const index = at.index;\\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\\n      this.raise(toParseError, at);\\n    } else {\\n      this.state.strictErrors.set(index, [toParseError, at]);\\n    }\\n  }\\n  readWord1(firstCode) {\\n    this.state.containsEsc = false;\\n    let word = \\\"\\\";\\n    const start = this.state.pos;\\n    let chunkStart = this.state.pos;\\n    if (firstCode !== undefined) {\\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\\n    }\\n    while (this.state.pos < this.length) {\\n      const ch = this.codePointAtPos(this.state.pos);\\n      if (isIdentifierChar(ch)) {\\n        this.state.pos += ch <= 0xffff ? 1 : 2;\\n      } else if (ch === 92) {\\n        this.state.containsEsc = true;\\n        word += this.input.slice(chunkStart, this.state.pos);\\n        const escStart = this.state.curPosition();\\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\\n          chunkStart = this.state.pos - 1;\\n          continue;\\n        }\\n        ++this.state.pos;\\n        const esc = this.readCodePoint(true);\\n        if (esc !== null) {\\n          if (!identifierCheck(esc)) {\\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\\n          }\\n          word += String.fromCodePoint(esc);\\n        }\\n        chunkStart = this.state.pos;\\n      } else {\\n        break;\\n      }\\n    }\\n    return word + this.input.slice(chunkStart, this.state.pos);\\n  }\\n  readWord(firstCode) {\\n    const word = this.readWord1(firstCode);\\n    const type = keywords$1.get(word);\\n    if (type !== undefined) {\\n      this.finishToken(type, tokenLabelName(type));\\n    } else {\\n      this.finishToken(132, word);\\n    }\\n  }\\n  checkKeywordEscapes() {\\n    const {\\n      type\\n    } = this.state;\\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\\n        reservedWord: tokenLabelName(type)\\n      });\\n    }\\n  }\\n  raise(toParseError, at, details = {}) {\\n    const loc = at instanceof Position ? at : at.loc.start;\\n    const error = toParseError(loc, details);\\n    if (!this.options.errorRecovery) throw error;\\n    if (!this.isLookahead) this.state.errors.push(error);\\n    return error;\\n  }\\n  raiseOverwrite(toParseError, at, details = {}) {\\n    const loc = at instanceof Position ? at : at.loc.start;\\n    const pos = loc.index;\\n    const errors = this.state.errors;\\n    for (let i = errors.length - 1; i >= 0; i--) {\\n      const error = errors[i];\\n      if (error.loc.index === pos) {\\n        return errors[i] = toParseError(loc, details);\\n      }\\n      if (error.loc.index < pos) break;\\n    }\\n    return this.raise(toParseError, at, details);\\n  }\\n  updateContext(prevType) {}\\n  unexpected(loc, type) {\\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\\n      expected: type ? tokenLabelName(type) : null\\n    });\\n  }\\n  expectPlugin(pluginName, loc) {\\n    if (this.hasPlugin(pluginName)) {\\n      return true;\\n    }\\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\\n      missingPlugin: [pluginName]\\n    });\\n  }\\n  expectOnePlugin(pluginNames) {\\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\\n        missingPlugin: pluginNames\\n      });\\n    }\\n  }\\n  errorBuilder(error) {\\n    return (pos, lineStart, curLine) => {\\n      this.raise(error, buildPosition(pos, lineStart, curLine));\\n    };\\n  }\\n}\\nclass ClassScope {\\n  constructor() {\\n    this.privateNames = new Set();\\n    this.loneAccessors = new Map();\\n    this.undefinedPrivateNames = new Map();\\n  }\\n}\\nclass ClassScopeHandler {\\n  constructor(parser) {\\n    this.parser = void 0;\\n    this.stack = [];\\n    this.undefinedPrivateNames = new Map();\\n    this.parser = parser;\\n  }\\n  current() {\\n    return this.stack[this.stack.length - 1];\\n  }\\n  enter() {\\n    this.stack.push(new ClassScope());\\n  }\\n  exit() {\\n    const oldClassScope = this.stack.pop();\\n    const current = this.current();\\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\\n      if (current) {\\n        if (!current.undefinedPrivateNames.has(name)) {\\n          current.undefinedPrivateNames.set(name, loc);\\n        }\\n      } else {\\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\\n          identifierName: name\\n        });\\n      }\\n    }\\n  }\\n  declarePrivateName(name, elementType, loc) {\\n    const {\\n      privateNames,\\n      loneAccessors,\\n      undefinedPrivateNames\\n    } = this.current();\\n    let redefined = privateNames.has(name);\\n    if (elementType & 3) {\\n      const accessor = redefined && loneAccessors.get(name);\\n      if (accessor) {\\n        const oldStatic = accessor & 4;\\n        const newStatic = elementType & 4;\\n        const oldKind = accessor & 3;\\n        const newKind = elementType & 3;\\n        redefined = oldKind === newKind || oldStatic !== newStatic;\\n        if (!redefined) loneAccessors.delete(name);\\n      } else if (!redefined) {\\n        loneAccessors.set(name, elementType);\\n      }\\n    }\\n    if (redefined) {\\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\\n        identifierName: name\\n      });\\n    }\\n    privateNames.add(name);\\n    undefinedPrivateNames.delete(name);\\n  }\\n  usePrivateName(name, loc) {\\n    let classScope;\\n    for (classScope of this.stack) {\\n      if (classScope.privateNames.has(name)) return;\\n    }\\n    if (classScope) {\\n      classScope.undefinedPrivateNames.set(name, loc);\\n    } else {\\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\\n        identifierName: name\\n      });\\n    }\\n  }\\n}\\nclass ExpressionScope {\\n  constructor(type = 0) {\\n    this.type = type;\\n  }\\n  canBeArrowParameterDeclaration() {\\n    return this.type === 2 || this.type === 1;\\n  }\\n  isCertainlyParameterDeclaration() {\\n    return this.type === 3;\\n  }\\n}\\nclass ArrowHeadParsingScope extends ExpressionScope {\\n  constructor(type) {\\n    super(type);\\n    this.declarationErrors = new Map();\\n  }\\n  recordDeclarationError(ParsingErrorClass, at) {\\n    const index = at.index;\\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\\n  }\\n  clearDeclarationError(index) {\\n    this.declarationErrors.delete(index);\\n  }\\n  iterateErrors(iterator) {\\n    this.declarationErrors.forEach(iterator);\\n  }\\n}\\nclass ExpressionScopeHandler {\\n  constructor(parser) {\\n    this.parser = void 0;\\n    this.stack = [new ExpressionScope()];\\n    this.parser = parser;\\n  }\\n  enter(scope) {\\n    this.stack.push(scope);\\n  }\\n  exit() {\\n    this.stack.pop();\\n  }\\n  recordParameterInitializerError(toParseError, node) {\\n    const origin = node.loc.start;\\n    const {\\n      stack\\n    } = this;\\n    let i = stack.length - 1;\\n    let scope = stack[i];\\n    while (!scope.isCertainlyParameterDeclaration()) {\\n      if (scope.canBeArrowParameterDeclaration()) {\\n        scope.recordDeclarationError(toParseError, origin);\\n      } else {\\n        return;\\n      }\\n      scope = stack[--i];\\n    }\\n    this.parser.raise(toParseError, origin);\\n  }\\n  recordArrowParameterBindingError(error, node) {\\n    const {\\n      stack\\n    } = this;\\n    const scope = stack[stack.length - 1];\\n    const origin = node.loc.start;\\n    if (scope.isCertainlyParameterDeclaration()) {\\n      this.parser.raise(error, origin);\\n    } else if (scope.canBeArrowParameterDeclaration()) {\\n      scope.recordDeclarationError(error, origin);\\n    } else {\\n      return;\\n    }\\n  }\\n  recordAsyncArrowParametersError(at) {\\n    const {\\n      stack\\n    } = this;\\n    let i = stack.length - 1;\\n    let scope = stack[i];\\n    while (scope.canBeArrowParameterDeclaration()) {\\n      if (scope.type === 2) {\\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\\n      }\\n      scope = stack[--i];\\n    }\\n  }\\n  validateAsPattern() {\\n    const {\\n      stack\\n    } = this;\\n    const currentScope = stack[stack.length - 1];\\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\\n    currentScope.iterateErrors(([toParseError, loc]) => {\\n      this.parser.raise(toParseError, loc);\\n      let i = stack.length - 2;\\n      let scope = stack[i];\\n      while (scope.canBeArrowParameterDeclaration()) {\\n        scope.clearDeclarationError(loc.index);\\n        scope = stack[--i];\\n      }\\n    });\\n  }\\n}\\nfunction newParameterDeclarationScope() {\\n  return new ExpressionScope(3);\\n}\\nfunction newArrowHeadScope() {\\n  return new ArrowHeadParsingScope(1);\\n}\\nfunction newAsyncArrowScope() {\\n  return new ArrowHeadParsingScope(2);\\n}\\nfunction newExpressionScope() {\\n  return new ExpressionScope();\\n}\\nclass ProductionParameterHandler {\\n  constructor() {\\n    this.stacks = [];\\n  }\\n  enter(flags) {\\n    this.stacks.push(flags);\\n  }\\n  exit() {\\n    this.stacks.pop();\\n  }\\n  currentFlags() {\\n    return this.stacks[this.stacks.length - 1];\\n  }\\n  get hasAwait() {\\n    return (this.currentFlags() & 2) > 0;\\n  }\\n  get hasYield() {\\n    return (this.currentFlags() & 1) > 0;\\n  }\\n  get hasReturn() {\\n    return (this.currentFlags() & 4) > 0;\\n  }\\n  get hasIn() {\\n    return (this.currentFlags() & 8) > 0;\\n  }\\n}\\nfunction functionFlags(isAsync, isGenerator) {\\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\\n}\\nclass UtilParser extends Tokenizer {\\n  addExtra(node, key, value, enumerable = true) {\\n    if (!node) return;\\n    const extra = node.extra = node.extra || {};\\n    if (enumerable) {\\n      extra[key] = value;\\n    } else {\\n      Object.defineProperty(extra, key, {\\n        enumerable,\\n        value\\n      });\\n    }\\n  }\\n  isContextual(token) {\\n    return this.state.type === token && !this.state.containsEsc;\\n  }\\n  isUnparsedContextual(nameStart, name) {\\n    const nameEnd = nameStart + name.length;\\n    if (this.input.slice(nameStart, nameEnd) === name) {\\n      const nextCh = this.input.charCodeAt(nameEnd);\\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\\n    }\\n    return false;\\n  }\\n  isLookaheadContextual(name) {\\n    const next = this.nextTokenStart();\\n    return this.isUnparsedContextual(next, name);\\n  }\\n  eatContextual(token) {\\n    if (this.isContextual(token)) {\\n      this.next();\\n      return true;\\n    }\\n    return false;\\n  }\\n  expectContextual(token, toParseError) {\\n    if (!this.eatContextual(token)) {\\n      if (toParseError != null) {\\n        throw this.raise(toParseError, this.state.startLoc);\\n      }\\n      this.unexpected(null, token);\\n    }\\n  }\\n  canInsertSemicolon() {\\n    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();\\n  }\\n  hasPrecedingLineBreak() {\\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\\n  }\\n  hasFollowingLineBreak() {\\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\\n    return skipWhiteSpaceToLineBreak.test(this.input);\\n  }\\n  isLineTerminator() {\\n    return this.eat(13) || this.canInsertSemicolon();\\n  }\\n  semicolon(allowAsi = true) {\\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\\n  }\\n  expect(type, loc) {\\n    this.eat(type) || this.unexpected(loc, type);\\n  }\\n  tryParse(fn, oldState = this.state.clone()) {\\n    const abortSignal = {\\n      node: null\\n    };\\n    try {\\n      const node = fn((node = null) => {\\n        abortSignal.node = node;\\n        throw abortSignal;\\n      });\\n      if (this.state.errors.length > oldState.errors.length) {\\n        const failState = this.state;\\n        this.state = oldState;\\n        this.state.tokensLength = failState.tokensLength;\\n        return {\\n          node,\\n          error: failState.errors[oldState.errors.length],\\n          thrown: false,\\n          aborted: false,\\n          failState\\n        };\\n      }\\n      return {\\n        node,\\n        error: null,\\n        thrown: false,\\n        aborted: false,\\n        failState: null\\n      };\\n    } catch (error) {\\n      const failState = this.state;\\n      this.state = oldState;\\n      if (error instanceof SyntaxError) {\\n        return {\\n          node: null,\\n          error,\\n          thrown: true,\\n          aborted: false,\\n          failState\\n        };\\n      }\\n      if (error === abortSignal) {\\n        return {\\n          node: abortSignal.node,\\n          error: null,\\n          thrown: false,\\n          aborted: true,\\n          failState\\n        };\\n      }\\n      throw error;\\n    }\\n  }\\n  checkExpressionErrors(refExpressionErrors, andThrow) {\\n    if (!refExpressionErrors) return false;\\n    const {\\n      shorthandAssignLoc,\\n      doubleProtoLoc,\\n      privateKeyLoc,\\n      optionalParametersLoc\\n    } = refExpressionErrors;\\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\\n    if (!andThrow) {\\n      return hasErrors;\\n    }\\n    if (shorthandAssignLoc != null) {\\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\\n    }\\n    if (doubleProtoLoc != null) {\\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\\n    }\\n    if (privateKeyLoc != null) {\\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\\n    }\\n    if (optionalParametersLoc != null) {\\n      this.unexpected(optionalParametersLoc);\\n    }\\n  }\\n  isLiteralPropertyName() {\\n    return tokenIsLiteralPropertyName(this.state.type);\\n  }\\n  isPrivateName(node) {\\n    return node.type === \\\"PrivateName\\\";\\n  }\\n  getPrivateNameSV(node) {\\n    return node.id.name;\\n  }\\n  hasPropertyAsPrivateName(node) {\\n    return (node.type === \\\"MemberExpression\\\" || node.type === \\\"OptionalMemberExpression\\\") && this.isPrivateName(node.property);\\n  }\\n  isObjectProperty(node) {\\n    return node.type === \\\"ObjectProperty\\\";\\n  }\\n  isObjectMethod(node) {\\n    return node.type === \\\"ObjectMethod\\\";\\n  }\\n  initializeScopes(inModule = this.options.sourceType === \\\"module\\\") {\\n    const oldLabels = this.state.labels;\\n    this.state.labels = [];\\n    const oldExportedIdentifiers = this.exportedIdentifiers;\\n    this.exportedIdentifiers = new Set();\\n    const oldInModule = this.inModule;\\n    this.inModule = inModule;\\n    const oldScope = this.scope;\\n    const ScopeHandler = this.getScopeHandler();\\n    this.scope = new ScopeHandler(this, inModule);\\n    const oldProdParam = this.prodParam;\\n    this.prodParam = new ProductionParameterHandler();\\n    const oldClassScope = this.classScope;\\n    this.classScope = new ClassScopeHandler(this);\\n    const oldExpressionScope = this.expressionScope;\\n    this.expressionScope = new ExpressionScopeHandler(this);\\n    return () => {\\n      this.state.labels = oldLabels;\\n      this.exportedIdentifiers = oldExportedIdentifiers;\\n      this.inModule = oldInModule;\\n      this.scope = oldScope;\\n      this.prodParam = oldProdParam;\\n      this.classScope = oldClassScope;\\n      this.expressionScope = oldExpressionScope;\\n    };\\n  }\\n  enterInitialScopes() {\\n    let paramFlags = 0;\\n    if (this.inModule) {\\n      paramFlags |= 2;\\n    }\\n    this.scope.enter(1);\\n    this.prodParam.enter(paramFlags);\\n  }\\n  checkDestructuringPrivate(refExpressionErrors) {\\n    const {\\n      privateKeyLoc\\n    } = refExpressionErrors;\\n    if (privateKeyLoc !== null) {\\n      this.expectPlugin(\\\"destructuringPrivate\\\", privateKeyLoc);\\n    }\\n  }\\n}\\nclass ExpressionErrors {\\n  constructor() {\\n    this.shorthandAssignLoc = null;\\n    this.doubleProtoLoc = null;\\n    this.privateKeyLoc = null;\\n    this.optionalParametersLoc = null;\\n  }\\n}\\nclass Node {\\n  constructor(parser, pos, loc) {\\n    this.type = \\\"\\\";\\n    this.start = pos;\\n    this.end = 0;\\n    this.loc = new SourceLocation(loc);\\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\\n  }\\n}\\nconst NodePrototype = Node.prototype;\\n{\\n  NodePrototype.__clone = function () {\\n    const newNode = new Node(undefined, this.start, this.loc.start);\\n    const keys = Object.keys(this);\\n    for (let i = 0, length = keys.length; i < length; i++) {\\n      const key = keys[i];\\n      if (key !== \\\"leadingComments\\\" && key !== \\\"trailingComments\\\" && key !== \\\"innerComments\\\") {\\n        newNode[key] = this[key];\\n      }\\n    }\\n    return newNode;\\n  };\\n}\\nfunction clonePlaceholder(node) {\\n  return cloneIdentifier(node);\\n}\\nfunction cloneIdentifier(node) {\\n  const {\\n    type,\\n    start,\\n    end,\\n    loc,\\n    range,\\n    extra,\\n    name\\n  } = node;\\n  const cloned = Object.create(NodePrototype);\\n  cloned.type = type;\\n  cloned.start = start;\\n  cloned.end = end;\\n  cloned.loc = loc;\\n  cloned.range = range;\\n  cloned.extra = extra;\\n  cloned.name = name;\\n  if (type === \\\"Placeholder\\\") {\\n    cloned.expectedNode = node.expectedNode;\\n  }\\n  return cloned;\\n}\\nfunction cloneStringLiteral(node) {\\n  const {\\n    type,\\n    start,\\n    end,\\n    loc,\\n    range,\\n    extra\\n  } = node;\\n  if (type === \\\"Placeholder\\\") {\\n    return clonePlaceholder(node);\\n  }\\n  const cloned = Object.create(NodePrototype);\\n  cloned.type = type;\\n  cloned.start = start;\\n  cloned.end = end;\\n  cloned.loc = loc;\\n  cloned.range = range;\\n  if (node.raw !== undefined) {\\n    cloned.raw = node.raw;\\n  } else {\\n    cloned.extra = extra;\\n  }\\n  cloned.value = node.value;\\n  return cloned;\\n}\\nclass NodeUtils extends UtilParser {\\n  startNode() {\\n    const loc = this.state.startLoc;\\n    return new Node(this, loc.index, loc);\\n  }\\n  startNodeAt(loc) {\\n    return new Node(this, loc.index, loc);\\n  }\\n  startNodeAtNode(type) {\\n    return this.startNodeAt(type.loc.start);\\n  }\\n  finishNode(node, type) {\\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\\n  }\\n  finishNodeAt(node, type, endLoc) {\\n    node.type = type;\\n    node.end = endLoc.index;\\n    node.loc.end = endLoc;\\n    if (this.options.ranges) node.range[1] = endLoc.index;\\n    if (this.options.attachComment) this.processComment(node);\\n    return node;\\n  }\\n  resetStartLocation(node, startLoc) {\\n    node.start = startLoc.index;\\n    node.loc.start = startLoc;\\n    if (this.options.ranges) node.range[0] = startLoc.index;\\n  }\\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\\n    node.end = endLoc.index;\\n    node.loc.end = endLoc;\\n    if (this.options.ranges) node.range[1] = endLoc.index;\\n  }\\n  resetStartLocationFromNode(node, locationNode) {\\n    this.resetStartLocation(node, locationNode.loc.start);\\n  }\\n}\\nconst reservedTypes = new Set([\\\"_\\\", \\\"any\\\", \\\"bool\\\", \\\"boolean\\\", \\\"empty\\\", \\\"extends\\\", \\\"false\\\", \\\"interface\\\", \\\"mixed\\\", \\\"null\\\", \\\"number\\\", \\\"static\\\", \\\"string\\\", \\\"true\\\", \\\"typeof\\\", \\\"void\\\"]);\\nconst FlowErrors = ParseErrorEnum`flow`({\\n  AmbiguousConditionalArrow: \\\"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\\\",\\n  AmbiguousDeclareModuleKind: \\\"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\\\",\\n  AssignReservedType: ({\\n    reservedType\\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\\n  DeclareClassElement: \\\"The `declare` modifier can only appear on class fields.\\\",\\n  DeclareClassFieldInitializer: \\\"Initializers are not allowed in fields with the `declare` modifier.\\\",\\n  DuplicateDeclareModuleExports: \\\"Duplicate `declare module.exports` statement.\\\",\\n  EnumBooleanMemberNotInitialized: ({\\n    memberName,\\n    enumName\\n  }) => `Boolean enum members need to be initialized. Use either \\\\`${memberName} = true,\\\\` or \\\\`${memberName} = false,\\\\` in enum \\\\`${enumName}\\\\`.`,\\n  EnumDuplicateMemberName: ({\\n    memberName,\\n    enumName\\n  }) => `Enum member names need to be unique, but the name \\\\`${memberName}\\\\` has already been used before in enum \\\\`${enumName}\\\\`.`,\\n  EnumInconsistentMemberValues: ({\\n    enumName\\n  }) => `Enum \\\\`${enumName}\\\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\\n  EnumInvalidExplicitType: ({\\n    invalidEnumType,\\n    enumName\\n  }) => `Enum type \\\\`${invalidEnumType}\\\\` is not valid. Use one of \\\\`boolean\\\\`, \\\\`number\\\\`, \\\\`string\\\\`, or \\\\`symbol\\\\` in enum \\\\`${enumName}\\\\`.`,\\n  EnumInvalidExplicitTypeUnknownSupplied: ({\\n    enumName\\n  }) => `Supplied enum type is not valid. Use one of \\\\`boolean\\\\`, \\\\`number\\\\`, \\\\`string\\\\`, or \\\\`symbol\\\\` in enum \\\\`${enumName}\\\\`.`,\\n  EnumInvalidMemberInitializerPrimaryType: ({\\n    enumName,\\n    memberName,\\n    explicitType\\n  }) => `Enum \\\\`${enumName}\\\\` has type \\\\`${explicitType}\\\\`, so the initializer of \\\\`${memberName}\\\\` needs to be a ${explicitType} literal.`,\\n  EnumInvalidMemberInitializerSymbolType: ({\\n    enumName,\\n    memberName\\n  }) => `Symbol enum members cannot be initialized. Use \\\\`${memberName},\\\\` in enum \\\\`${enumName}\\\\`.`,\\n  EnumInvalidMemberInitializerUnknownType: ({\\n    enumName,\\n    memberName\\n  }) => `The enum member initializer for \\\\`${memberName}\\\\` needs to be a literal (either a boolean, number, or string) in enum \\\\`${enumName}\\\\`.`,\\n  EnumInvalidMemberName: ({\\n    enumName,\\n    memberName,\\n    suggestion\\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\\\`${memberName}\\\\`, consider using \\\\`${suggestion}\\\\`, in enum \\\\`${enumName}\\\\`.`,\\n  EnumNumberMemberNotInitialized: ({\\n    enumName,\\n    memberName\\n  }) => `Number enum members need to be initialized, e.g. \\\\`${memberName} = 1\\\\` in enum \\\\`${enumName}\\\\`.`,\\n  EnumStringMemberInconsistentlyInitialized: ({\\n    enumName\\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\\\`${enumName}\\\\`.`,\\n  GetterMayNotHaveThisParam: \\\"A getter cannot have a `this` parameter.\\\",\\n  ImportReflectionHasImportType: \\\"An `import module` declaration can not use `type` or `typeof` keyword.\\\",\\n  ImportTypeShorthandOnlyInPureImport: \\\"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\\\",\\n  InexactInsideExact: \\\"Explicit inexact syntax cannot appear inside an explicit exact object type.\\\",\\n  InexactInsideNonObject: \\\"Explicit inexact syntax cannot appear in class or interface definitions.\\\",\\n  InexactVariance: \\\"Explicit inexact syntax cannot have variance.\\\",\\n  InvalidNonTypeImportInDeclareModule: \\\"Imports within a `declare module` body must always be `import type` or `import typeof`.\\\",\\n  MissingTypeParamDefault: \\\"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\\\",\\n  NestedDeclareModule: \\\"`declare module` cannot be used inside another `declare module`.\\\",\\n  NestedFlowComment: \\\"Cannot have a flow comment inside another flow comment.\\\",\\n  PatternIsOptional: Object.assign({\\n    message: \\\"A binding pattern parameter cannot be optional in an implementation signature.\\\"\\n  }, {\\n    reasonCode: \\\"OptionalBindingPattern\\\"\\n  }),\\n  SetterMayNotHaveThisParam: \\\"A setter cannot have a `this` parameter.\\\",\\n  SpreadVariance: \\\"Spread properties cannot have variance.\\\",\\n  ThisParamAnnotationRequired: \\\"A type annotation is required for the `this` parameter.\\\",\\n  ThisParamBannedInConstructor: \\\"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\\\",\\n  ThisParamMayNotBeOptional: \\\"The `this` parameter cannot be optional.\\\",\\n  ThisParamMustBeFirst: \\\"The `this` parameter must be the first function parameter.\\\",\\n  ThisParamNoDefault: \\\"The `this` parameter may not have a default value.\\\",\\n  TypeBeforeInitializer: \\\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\\\",\\n  TypeCastInPattern: \\\"The type cast expression is expected to be wrapped with parenthesis.\\\",\\n  UnexpectedExplicitInexactInObject: \\\"Explicit inexact syntax must appear at the end of an inexact object.\\\",\\n  UnexpectedReservedType: ({\\n    reservedType\\n  }) => `Unexpected reserved type ${reservedType}.`,\\n  UnexpectedReservedUnderscore: \\\"`_` is only allowed as a type argument to call or new.\\\",\\n  UnexpectedSpaceBetweenModuloChecks: \\\"Spaces between `%` and `checks` are not allowed here.\\\",\\n  UnexpectedSpreadType: \\\"Spread operator cannot appear in class or interface definitions.\\\",\\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \\\"number\\\" or \\\"bigint\\\".',\\n  UnexpectedTokenAfterTypeParameter: \\\"Expected an arrow function after this type parameter declaration.\\\",\\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \\\"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\\\",\\n  UnsupportedDeclareExportKind: ({\\n    unsupportedExportKind,\\n    suggestion\\n  }) => `\\\\`declare export ${unsupportedExportKind}\\\\` is not supported. Use \\\\`${suggestion}\\\\` instead.`,\\n  UnsupportedStatementInDeclareModule: \\\"Only declares and type imports are allowed inside declare module.\\\",\\n  UnterminatedFlowComment: \\\"Unterminated flow-comment.\\\"\\n});\\nfunction isEsModuleType(bodyElement) {\\n  return bodyElement.type === \\\"DeclareExportAllDeclaration\\\" || bodyElement.type === \\\"DeclareExportDeclaration\\\" && (!bodyElement.declaration || bodyElement.declaration.type !== \\\"TypeAlias\\\" && bodyElement.declaration.type !== \\\"InterfaceDeclaration\\\");\\n}\\nfunction hasTypeImportKind(node) {\\n  return node.importKind === \\\"type\\\" || node.importKind === \\\"typeof\\\";\\n}\\nconst exportSuggestions = {\\n  const: \\\"declare export var\\\",\\n  let: \\\"declare export var\\\",\\n  type: \\\"export type\\\",\\n  interface: \\\"export interface\\\"\\n};\\nfunction partition(list, test) {\\n  const list1 = [];\\n  const list2 = [];\\n  for (let i = 0; i < list.length; i++) {\\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\\n  }\\n  return [list1, list2];\\n}\\nconst FLOW_PRAGMA_REGEX = /\\\\*?\\\\s*@((?:no)?flow)\\\\b/;\\nvar flow = superClass => class FlowParserMixin extends superClass {\\n  constructor(...args) {\\n    super(...args);\\n    this.flowPragma = undefined;\\n  }\\n  getScopeHandler() {\\n    return FlowScopeHandler;\\n  }\\n  shouldParseTypes() {\\n    return this.getPluginOption(\\\"flow\\\", \\\"all\\\") || this.flowPragma === \\\"flow\\\";\\n  }\\n  shouldParseEnums() {\\n    return !!this.getPluginOption(\\\"flow\\\", \\\"enums\\\");\\n  }\\n  finishToken(type, val) {\\n    if (type !== 133 && type !== 13 && type !== 28) {\\n      if (this.flowPragma === undefined) {\\n        this.flowPragma = null;\\n      }\\n    }\\n    super.finishToken(type, val);\\n  }\\n  addComment(comment) {\\n    if (this.flowPragma === undefined) {\\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\\n      if (!matches) ;else if (matches[1] === \\\"flow\\\") {\\n        this.flowPragma = \\\"flow\\\";\\n      } else if (matches[1] === \\\"noflow\\\") {\\n        this.flowPragma = \\\"noflow\\\";\\n      } else {\\n        throw new Error(\\\"Unexpected flow pragma\\\");\\n      }\\n    }\\n    super.addComment(comment);\\n  }\\n  flowParseTypeInitialiser(tok) {\\n    const oldInType = this.state.inType;\\n    this.state.inType = true;\\n    this.expect(tok || 14);\\n    const type = this.flowParseType();\\n    this.state.inType = oldInType;\\n    return type;\\n  }\\n  flowParsePredicate() {\\n    const node = this.startNode();\\n    const moduloLoc = this.state.startLoc;\\n    this.next();\\n    this.expectContextual(110);\\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\\n    }\\n    if (this.eat(10)) {\\n      node.value = super.parseExpression();\\n      this.expect(11);\\n      return this.finishNode(node, \\\"DeclaredPredicate\\\");\\n    } else {\\n      return this.finishNode(node, \\\"InferredPredicate\\\");\\n    }\\n  }\\n  flowParseTypeAndPredicateInitialiser() {\\n    const oldInType = this.state.inType;\\n    this.state.inType = true;\\n    this.expect(14);\\n    let type = null;\\n    let predicate = null;\\n    if (this.match(54)) {\\n      this.state.inType = oldInType;\\n      predicate = this.flowParsePredicate();\\n    } else {\\n      type = this.flowParseType();\\n      this.state.inType = oldInType;\\n      if (this.match(54)) {\\n        predicate = this.flowParsePredicate();\\n      }\\n    }\\n    return [type, predicate];\\n  }\\n  flowParseDeclareClass(node) {\\n    this.next();\\n    this.flowParseInterfaceish(node, true);\\n    return this.finishNode(node, \\\"DeclareClass\\\");\\n  }\\n  flowParseDeclareFunction(node) {\\n    this.next();\\n    const id = node.id = this.parseIdentifier();\\n    const typeNode = this.startNode();\\n    const typeContainer = this.startNode();\\n    if (this.match(47)) {\\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\\n    } else {\\n      typeNode.typeParameters = null;\\n    }\\n    this.expect(10);\\n    const tmp = this.flowParseFunctionTypeParams();\\n    typeNode.params = tmp.params;\\n    typeNode.rest = tmp.rest;\\n    typeNode.this = tmp._this;\\n    this.expect(11);\\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \\\"FunctionTypeAnnotation\\\");\\n    id.typeAnnotation = this.finishNode(typeContainer, \\\"TypeAnnotation\\\");\\n    this.resetEndLocation(id);\\n    this.semicolon();\\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\\n    return this.finishNode(node, \\\"DeclareFunction\\\");\\n  }\\n  flowParseDeclare(node, insideModule) {\\n    if (this.match(80)) {\\n      return this.flowParseDeclareClass(node);\\n    } else if (this.match(68)) {\\n      return this.flowParseDeclareFunction(node);\\n    } else if (this.match(74)) {\\n      return this.flowParseDeclareVariable(node);\\n    } else if (this.eatContextual(127)) {\\n      if (this.match(16)) {\\n        return this.flowParseDeclareModuleExports(node);\\n      } else {\\n        if (insideModule) {\\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\\n        }\\n        return this.flowParseDeclareModule(node);\\n      }\\n    } else if (this.isContextual(130)) {\\n      return this.flowParseDeclareTypeAlias(node);\\n    } else if (this.isContextual(131)) {\\n      return this.flowParseDeclareOpaqueType(node);\\n    } else if (this.isContextual(129)) {\\n      return this.flowParseDeclareInterface(node);\\n    } else if (this.match(82)) {\\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\\n    } else {\\n      this.unexpected();\\n    }\\n  }\\n  flowParseDeclareVariable(node) {\\n    this.next();\\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"DeclareVariable\\\");\\n  }\\n  flowParseDeclareModule(node) {\\n    this.scope.enter(0);\\n    if (this.match(133)) {\\n      node.id = super.parseExprAtom();\\n    } else {\\n      node.id = this.parseIdentifier();\\n    }\\n    const bodyNode = node.body = this.startNode();\\n    const body = bodyNode.body = [];\\n    this.expect(5);\\n    while (!this.match(8)) {\\n      let bodyNode = this.startNode();\\n      if (this.match(83)) {\\n        this.next();\\n        if (!this.isContextual(130) && !this.match(87)) {\\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\\n        }\\n        super.parseImport(bodyNode);\\n      } else {\\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\\n        bodyNode = this.flowParseDeclare(bodyNode, true);\\n      }\\n      body.push(bodyNode);\\n    }\\n    this.scope.exit();\\n    this.expect(8);\\n    this.finishNode(bodyNode, \\\"BlockStatement\\\");\\n    let kind = null;\\n    let hasModuleExport = false;\\n    body.forEach(bodyElement => {\\n      if (isEsModuleType(bodyElement)) {\\n        if (kind === \\\"CommonJS\\\") {\\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\\n        }\\n        kind = \\\"ES\\\";\\n      } else if (bodyElement.type === \\\"DeclareModuleExports\\\") {\\n        if (hasModuleExport) {\\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\\n        }\\n        if (kind === \\\"ES\\\") {\\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\\n        }\\n        kind = \\\"CommonJS\\\";\\n        hasModuleExport = true;\\n      }\\n    });\\n    node.kind = kind || \\\"CommonJS\\\";\\n    return this.finishNode(node, \\\"DeclareModule\\\");\\n  }\\n  flowParseDeclareExportDeclaration(node, insideModule) {\\n    this.expect(82);\\n    if (this.eat(65)) {\\n      if (this.match(68) || this.match(80)) {\\n        node.declaration = this.flowParseDeclare(this.startNode());\\n      } else {\\n        node.declaration = this.flowParseType();\\n        this.semicolon();\\n      }\\n      node.default = true;\\n      return this.finishNode(node, \\\"DeclareExportDeclaration\\\");\\n    } else {\\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\\n        const label = this.state.value;\\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\\n          unsupportedExportKind: label,\\n          suggestion: exportSuggestions[label]\\n        });\\n      }\\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\\n        node.declaration = this.flowParseDeclare(this.startNode());\\n        node.default = false;\\n        return this.finishNode(node, \\\"DeclareExportDeclaration\\\");\\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\\n        node = this.parseExport(node, null);\\n        if (node.type === \\\"ExportNamedDeclaration\\\") {\\n          node.type = \\\"ExportDeclaration\\\";\\n          node.default = false;\\n          delete node.exportKind;\\n        }\\n        node.type = \\\"Declare\\\" + node.type;\\n        return node;\\n      }\\n    }\\n    this.unexpected();\\n  }\\n  flowParseDeclareModuleExports(node) {\\n    this.next();\\n    this.expectContextual(111);\\n    node.typeAnnotation = this.flowParseTypeAnnotation();\\n    this.semicolon();\\n    return this.finishNode(node, \\\"DeclareModuleExports\\\");\\n  }\\n  flowParseDeclareTypeAlias(node) {\\n    this.next();\\n    const finished = this.flowParseTypeAlias(node);\\n    finished.type = \\\"DeclareTypeAlias\\\";\\n    return finished;\\n  }\\n  flowParseDeclareOpaqueType(node) {\\n    this.next();\\n    const finished = this.flowParseOpaqueType(node, true);\\n    finished.type = \\\"DeclareOpaqueType\\\";\\n    return finished;\\n  }\\n  flowParseDeclareInterface(node) {\\n    this.next();\\n    this.flowParseInterfaceish(node, false);\\n    return this.finishNode(node, \\\"DeclareInterface\\\");\\n  }\\n  flowParseInterfaceish(node, isClass) {\\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\\n    } else {\\n      node.typeParameters = null;\\n    }\\n    node.extends = [];\\n    if (this.eat(81)) {\\n      do {\\n        node.extends.push(this.flowParseInterfaceExtends());\\n      } while (!isClass && this.eat(12));\\n    }\\n    if (isClass) {\\n      node.implements = [];\\n      node.mixins = [];\\n      if (this.eatContextual(117)) {\\n        do {\\n          node.mixins.push(this.flowParseInterfaceExtends());\\n        } while (this.eat(12));\\n      }\\n      if (this.eatContextual(113)) {\\n        do {\\n          node.implements.push(this.flowParseInterfaceExtends());\\n        } while (this.eat(12));\\n      }\\n    }\\n    node.body = this.flowParseObjectType({\\n      allowStatic: isClass,\\n      allowExact: false,\\n      allowSpread: false,\\n      allowProto: isClass,\\n      allowInexact: false\\n    });\\n  }\\n  flowParseInterfaceExtends() {\\n    const node = this.startNode();\\n    node.id = this.flowParseQualifiedTypeIdentifier();\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\\n    } else {\\n      node.typeParameters = null;\\n    }\\n    return this.finishNode(node, \\\"InterfaceExtends\\\");\\n  }\\n  flowParseInterface(node) {\\n    this.flowParseInterfaceish(node, false);\\n    return this.finishNode(node, \\\"InterfaceDeclaration\\\");\\n  }\\n  checkNotUnderscore(word) {\\n    if (word === \\\"_\\\") {\\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\\n    }\\n  }\\n  checkReservedType(word, startLoc, declaration) {\\n    if (!reservedTypes.has(word)) return;\\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\\n      reservedType: word\\n    });\\n  }\\n  flowParseRestrictedIdentifier(liberal, declaration) {\\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\\n    return this.parseIdentifier(liberal);\\n  }\\n  flowParseTypeAlias(node) {\\n    node.id = this.flowParseRestrictedIdentifier(false, true);\\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\\n    } else {\\n      node.typeParameters = null;\\n    }\\n    node.right = this.flowParseTypeInitialiser(29);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"TypeAlias\\\");\\n  }\\n  flowParseOpaqueType(node, declare) {\\n    this.expectContextual(130);\\n    node.id = this.flowParseRestrictedIdentifier(true, true);\\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\\n    } else {\\n      node.typeParameters = null;\\n    }\\n    node.supertype = null;\\n    if (this.match(14)) {\\n      node.supertype = this.flowParseTypeInitialiser(14);\\n    }\\n    node.impltype = null;\\n    if (!declare) {\\n      node.impltype = this.flowParseTypeInitialiser(29);\\n    }\\n    this.semicolon();\\n    return this.finishNode(node, \\\"OpaqueType\\\");\\n  }\\n  flowParseTypeParameter(requireDefault = false) {\\n    const nodeStartLoc = this.state.startLoc;\\n    const node = this.startNode();\\n    const variance = this.flowParseVariance();\\n    const ident = this.flowParseTypeAnnotatableIdentifier();\\n    node.name = ident.name;\\n    node.variance = variance;\\n    node.bound = ident.typeAnnotation;\\n    if (this.match(29)) {\\n      this.eat(29);\\n      node.default = this.flowParseType();\\n    } else {\\n      if (requireDefault) {\\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\\n      }\\n    }\\n    return this.finishNode(node, \\\"TypeParameter\\\");\\n  }\\n  flowParseTypeParameterDeclaration() {\\n    const oldInType = this.state.inType;\\n    const node = this.startNode();\\n    node.params = [];\\n    this.state.inType = true;\\n    if (this.match(47) || this.match(142)) {\\n      this.next();\\n    } else {\\n      this.unexpected();\\n    }\\n    let defaultRequired = false;\\n    do {\\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\\n      node.params.push(typeParameter);\\n      if (typeParameter.default) {\\n        defaultRequired = true;\\n      }\\n      if (!this.match(48)) {\\n        this.expect(12);\\n      }\\n    } while (!this.match(48));\\n    this.expect(48);\\n    this.state.inType = oldInType;\\n    return this.finishNode(node, \\\"TypeParameterDeclaration\\\");\\n  }\\n  flowParseTypeParameterInstantiation() {\\n    const node = this.startNode();\\n    const oldInType = this.state.inType;\\n    node.params = [];\\n    this.state.inType = true;\\n    this.expect(47);\\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\\n    this.state.noAnonFunctionType = false;\\n    while (!this.match(48)) {\\n      node.params.push(this.flowParseType());\\n      if (!this.match(48)) {\\n        this.expect(12);\\n      }\\n    }\\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\\n    this.expect(48);\\n    this.state.inType = oldInType;\\n    return this.finishNode(node, \\\"TypeParameterInstantiation\\\");\\n  }\\n  flowParseTypeParameterInstantiationCallOrNew() {\\n    const node = this.startNode();\\n    const oldInType = this.state.inType;\\n    node.params = [];\\n    this.state.inType = true;\\n    this.expect(47);\\n    while (!this.match(48)) {\\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\\n      if (!this.match(48)) {\\n        this.expect(12);\\n      }\\n    }\\n    this.expect(48);\\n    this.state.inType = oldInType;\\n    return this.finishNode(node, \\\"TypeParameterInstantiation\\\");\\n  }\\n  flowParseInterfaceType() {\\n    const node = this.startNode();\\n    this.expectContextual(129);\\n    node.extends = [];\\n    if (this.eat(81)) {\\n      do {\\n        node.extends.push(this.flowParseInterfaceExtends());\\n      } while (this.eat(12));\\n    }\\n    node.body = this.flowParseObjectType({\\n      allowStatic: false,\\n      allowExact: false,\\n      allowSpread: false,\\n      allowProto: false,\\n      allowInexact: false\\n    });\\n    return this.finishNode(node, \\\"InterfaceTypeAnnotation\\\");\\n  }\\n  flowParseObjectPropertyKey() {\\n    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);\\n  }\\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\\n    node.static = isStatic;\\n    if (this.lookahead().type === 14) {\\n      node.id = this.flowParseObjectPropertyKey();\\n      node.key = this.flowParseTypeInitialiser();\\n    } else {\\n      node.id = null;\\n      node.key = this.flowParseType();\\n    }\\n    this.expect(3);\\n    node.value = this.flowParseTypeInitialiser();\\n    node.variance = variance;\\n    return this.finishNode(node, \\\"ObjectTypeIndexer\\\");\\n  }\\n  flowParseObjectTypeInternalSlot(node, isStatic) {\\n    node.static = isStatic;\\n    node.id = this.flowParseObjectPropertyKey();\\n    this.expect(3);\\n    this.expect(3);\\n    if (this.match(47) || this.match(10)) {\\n      node.method = true;\\n      node.optional = false;\\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\\n    } else {\\n      node.method = false;\\n      if (this.eat(17)) {\\n        node.optional = true;\\n      }\\n      node.value = this.flowParseTypeInitialiser();\\n    }\\n    return this.finishNode(node, \\\"ObjectTypeInternalSlot\\\");\\n  }\\n  flowParseObjectTypeMethodish(node) {\\n    node.params = [];\\n    node.rest = null;\\n    node.typeParameters = null;\\n    node.this = null;\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\\n    }\\n    this.expect(10);\\n    if (this.match(78)) {\\n      node.this = this.flowParseFunctionTypeParam(true);\\n      node.this.name = null;\\n      if (!this.match(11)) {\\n        this.expect(12);\\n      }\\n    }\\n    while (!this.match(11) && !this.match(21)) {\\n      node.params.push(this.flowParseFunctionTypeParam(false));\\n      if (!this.match(11)) {\\n        this.expect(12);\\n      }\\n    }\\n    if (this.eat(21)) {\\n      node.rest = this.flowParseFunctionTypeParam(false);\\n    }\\n    this.expect(11);\\n    node.returnType = this.flowParseTypeInitialiser();\\n    return this.finishNode(node, \\\"FunctionTypeAnnotation\\\");\\n  }\\n  flowParseObjectTypeCallProperty(node, isStatic) {\\n    const valueNode = this.startNode();\\n    node.static = isStatic;\\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\\n    return this.finishNode(node, \\\"ObjectTypeCallProperty\\\");\\n  }\\n  flowParseObjectType({\\n    allowStatic,\\n    allowExact,\\n    allowSpread,\\n    allowProto,\\n    allowInexact\\n  }) {\\n    const oldInType = this.state.inType;\\n    this.state.inType = true;\\n    const nodeStart = this.startNode();\\n    nodeStart.callProperties = [];\\n    nodeStart.properties = [];\\n    nodeStart.indexers = [];\\n    nodeStart.internalSlots = [];\\n    let endDelim;\\n    let exact;\\n    let inexact = false;\\n    if (allowExact && this.match(6)) {\\n      this.expect(6);\\n      endDelim = 9;\\n      exact = true;\\n    } else {\\n      this.expect(5);\\n      endDelim = 8;\\n      exact = false;\\n    }\\n    nodeStart.exact = exact;\\n    while (!this.match(endDelim)) {\\n      let isStatic = false;\\n      let protoStartLoc = null;\\n      let inexactStartLoc = null;\\n      const node = this.startNode();\\n      if (allowProto && this.isContextual(118)) {\\n        const lookahead = this.lookahead();\\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\\n          this.next();\\n          protoStartLoc = this.state.startLoc;\\n          allowStatic = false;\\n        }\\n      }\\n      if (allowStatic && this.isContextual(106)) {\\n        const lookahead = this.lookahead();\\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\\n          this.next();\\n          isStatic = true;\\n        }\\n      }\\n      const variance = this.flowParseVariance();\\n      if (this.eat(0)) {\\n        if (protoStartLoc != null) {\\n          this.unexpected(protoStartLoc);\\n        }\\n        if (this.eat(0)) {\\n          if (variance) {\\n            this.unexpected(variance.loc.start);\\n          }\\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\\n        } else {\\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\\n        }\\n      } else if (this.match(10) || this.match(47)) {\\n        if (protoStartLoc != null) {\\n          this.unexpected(protoStartLoc);\\n        }\\n        if (variance) {\\n          this.unexpected(variance.loc.start);\\n        }\\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\\n      } else {\\n        let kind = \\\"init\\\";\\n        if (this.isContextual(99) || this.isContextual(104)) {\\n          const lookahead = this.lookahead();\\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\\n            kind = this.state.value;\\n            this.next();\\n          }\\n        }\\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\\n        if (propOrInexact === null) {\\n          inexact = true;\\n          inexactStartLoc = this.state.lastTokStartLoc;\\n        } else {\\n          nodeStart.properties.push(propOrInexact);\\n        }\\n      }\\n      this.flowObjectTypeSemicolon();\\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\\n      }\\n    }\\n    this.expect(endDelim);\\n    if (allowSpread) {\\n      nodeStart.inexact = inexact;\\n    }\\n    const out = this.finishNode(nodeStart, \\\"ObjectTypeAnnotation\\\");\\n    this.state.inType = oldInType;\\n    return out;\\n  }\\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\\n    if (this.eat(21)) {\\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\\n      if (isInexactToken) {\\n        if (!allowSpread) {\\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\\n        } else if (!allowInexact) {\\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\\n        }\\n        if (variance) {\\n          this.raise(FlowErrors.InexactVariance, variance);\\n        }\\n        return null;\\n      }\\n      if (!allowSpread) {\\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\\n      }\\n      if (protoStartLoc != null) {\\n        this.unexpected(protoStartLoc);\\n      }\\n      if (variance) {\\n        this.raise(FlowErrors.SpreadVariance, variance);\\n      }\\n      node.argument = this.flowParseType();\\n      return this.finishNode(node, \\\"ObjectTypeSpreadProperty\\\");\\n    } else {\\n      node.key = this.flowParseObjectPropertyKey();\\n      node.static = isStatic;\\n      node.proto = protoStartLoc != null;\\n      node.kind = kind;\\n      let optional = false;\\n      if (this.match(47) || this.match(10)) {\\n        node.method = true;\\n        if (protoStartLoc != null) {\\n          this.unexpected(protoStartLoc);\\n        }\\n        if (variance) {\\n          this.unexpected(variance.loc.start);\\n        }\\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\\n        if (kind === \\\"get\\\" || kind === \\\"set\\\") {\\n          this.flowCheckGetterSetterParams(node);\\n        }\\n        if (!allowSpread && node.key.name === \\\"constructor\\\" && node.value.this) {\\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\\n        }\\n      } else {\\n        if (kind !== \\\"init\\\") this.unexpected();\\n        node.method = false;\\n        if (this.eat(17)) {\\n          optional = true;\\n        }\\n        node.value = this.flowParseTypeInitialiser();\\n        node.variance = variance;\\n      }\\n      node.optional = optional;\\n      return this.finishNode(node, \\\"ObjectTypeProperty\\\");\\n    }\\n  }\\n  flowCheckGetterSetterParams(property) {\\n    const paramCount = property.kind === \\\"get\\\" ? 0 : 1;\\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\\n    if (property.value.this) {\\n      this.raise(property.kind === \\\"get\\\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\\n    }\\n    if (length !== paramCount) {\\n      this.raise(property.kind === \\\"get\\\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\\n    }\\n    if (property.kind === \\\"set\\\" && property.value.rest) {\\n      this.raise(Errors.BadSetterRestParameter, property);\\n    }\\n  }\\n  flowObjectTypeSemicolon() {\\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\\n      this.unexpected();\\n    }\\n  }\\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\\n    var _startLoc;\\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\\n    let node = id || this.flowParseRestrictedIdentifier(true);\\n    while (this.eat(16)) {\\n      const node2 = this.startNodeAt(startLoc);\\n      node2.qualification = node;\\n      node2.id = this.flowParseRestrictedIdentifier(true);\\n      node = this.finishNode(node2, \\\"QualifiedTypeIdentifier\\\");\\n    }\\n    return node;\\n  }\\n  flowParseGenericType(startLoc, id) {\\n    const node = this.startNodeAt(startLoc);\\n    node.typeParameters = null;\\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\\n    }\\n    return this.finishNode(node, \\\"GenericTypeAnnotation\\\");\\n  }\\n  flowParseTypeofType() {\\n    const node = this.startNode();\\n    this.expect(87);\\n    node.argument = this.flowParsePrimaryType();\\n    return this.finishNode(node, \\\"TypeofTypeAnnotation\\\");\\n  }\\n  flowParseTupleType() {\\n    const node = this.startNode();\\n    node.types = [];\\n    this.expect(0);\\n    while (this.state.pos < this.length && !this.match(3)) {\\n      node.types.push(this.flowParseType());\\n      if (this.match(3)) break;\\n      this.expect(12);\\n    }\\n    this.expect(3);\\n    return this.finishNode(node, \\\"TupleTypeAnnotation\\\");\\n  }\\n  flowParseFunctionTypeParam(first) {\\n    let name = null;\\n    let optional = false;\\n    let typeAnnotation = null;\\n    const node = this.startNode();\\n    const lh = this.lookahead();\\n    const isThis = this.state.type === 78;\\n    if (lh.type === 14 || lh.type === 17) {\\n      if (isThis && !first) {\\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\\n      }\\n      name = this.parseIdentifier(isThis);\\n      if (this.eat(17)) {\\n        optional = true;\\n        if (isThis) {\\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\\n        }\\n      }\\n      typeAnnotation = this.flowParseTypeInitialiser();\\n    } else {\\n      typeAnnotation = this.flowParseType();\\n    }\\n    node.name = name;\\n    node.optional = optional;\\n    node.typeAnnotation = typeAnnotation;\\n    return this.finishNode(node, \\\"FunctionTypeParam\\\");\\n  }\\n  reinterpretTypeAsFunctionTypeParam(type) {\\n    const node = this.startNodeAt(type.loc.start);\\n    node.name = null;\\n    node.optional = false;\\n    node.typeAnnotation = type;\\n    return this.finishNode(node, \\\"FunctionTypeParam\\\");\\n  }\\n  flowParseFunctionTypeParams(params = []) {\\n    let rest = null;\\n    let _this = null;\\n    if (this.match(78)) {\\n      _this = this.flowParseFunctionTypeParam(true);\\n      _this.name = null;\\n      if (!this.match(11)) {\\n        this.expect(12);\\n      }\\n    }\\n    while (!this.match(11) && !this.match(21)) {\\n      params.push(this.flowParseFunctionTypeParam(false));\\n      if (!this.match(11)) {\\n        this.expect(12);\\n      }\\n    }\\n    if (this.eat(21)) {\\n      rest = this.flowParseFunctionTypeParam(false);\\n    }\\n    return {\\n      params,\\n      rest,\\n      _this\\n    };\\n  }\\n  flowIdentToTypeAnnotation(startLoc, node, id) {\\n    switch (id.name) {\\n      case \\\"any\\\":\\n        return this.finishNode(node, \\\"AnyTypeAnnotation\\\");\\n      case \\\"bool\\\":\\n      case \\\"boolean\\\":\\n        return this.finishNode(node, \\\"BooleanTypeAnnotation\\\");\\n      case \\\"mixed\\\":\\n        return this.finishNode(node, \\\"MixedTypeAnnotation\\\");\\n      case \\\"empty\\\":\\n        return this.finishNode(node, \\\"EmptyTypeAnnotation\\\");\\n      case \\\"number\\\":\\n        return this.finishNode(node, \\\"NumberTypeAnnotation\\\");\\n      case \\\"string\\\":\\n        return this.finishNode(node, \\\"StringTypeAnnotation\\\");\\n      case \\\"symbol\\\":\\n        return this.finishNode(node, \\\"SymbolTypeAnnotation\\\");\\n      default:\\n        this.checkNotUnderscore(id.name);\\n        return this.flowParseGenericType(startLoc, id);\\n    }\\n  }\\n  flowParsePrimaryType() {\\n    const startLoc = this.state.startLoc;\\n    const node = this.startNode();\\n    let tmp;\\n    let type;\\n    let isGroupedType = false;\\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\\n    switch (this.state.type) {\\n      case 5:\\n        return this.flowParseObjectType({\\n          allowStatic: false,\\n          allowExact: false,\\n          allowSpread: true,\\n          allowProto: false,\\n          allowInexact: true\\n        });\\n      case 6:\\n        return this.flowParseObjectType({\\n          allowStatic: false,\\n          allowExact: true,\\n          allowSpread: true,\\n          allowProto: false,\\n          allowInexact: false\\n        });\\n      case 0:\\n        this.state.noAnonFunctionType = false;\\n        type = this.flowParseTupleType();\\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\\n        return type;\\n      case 47:\\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\\n        this.expect(10);\\n        tmp = this.flowParseFunctionTypeParams();\\n        node.params = tmp.params;\\n        node.rest = tmp.rest;\\n        node.this = tmp._this;\\n        this.expect(11);\\n        this.expect(19);\\n        node.returnType = this.flowParseType();\\n        return this.finishNode(node, \\\"FunctionTypeAnnotation\\\");\\n      case 10:\\n        this.next();\\n        if (!this.match(11) && !this.match(21)) {\\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\\n            const token = this.lookahead().type;\\n            isGroupedType = token !== 17 && token !== 14;\\n          } else {\\n            isGroupedType = true;\\n          }\\n        }\\n        if (isGroupedType) {\\n          this.state.noAnonFunctionType = false;\\n          type = this.flowParseType();\\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\\n            this.expect(11);\\n            return type;\\n          } else {\\n            this.eat(12);\\n          }\\n        }\\n        if (type) {\\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\\n        } else {\\n          tmp = this.flowParseFunctionTypeParams();\\n        }\\n        node.params = tmp.params;\\n        node.rest = tmp.rest;\\n        node.this = tmp._this;\\n        this.expect(11);\\n        this.expect(19);\\n        node.returnType = this.flowParseType();\\n        node.typeParameters = null;\\n        return this.finishNode(node, \\\"FunctionTypeAnnotation\\\");\\n      case 133:\\n        return this.parseLiteral(this.state.value, \\\"StringLiteralTypeAnnotation\\\");\\n      case 85:\\n      case 86:\\n        node.value = this.match(85);\\n        this.next();\\n        return this.finishNode(node, \\\"BooleanLiteralTypeAnnotation\\\");\\n      case 53:\\n        if (this.state.value === \\\"-\\\") {\\n          this.next();\\n          if (this.match(134)) {\\n            return this.parseLiteralAtNode(-this.state.value, \\\"NumberLiteralTypeAnnotation\\\", node);\\n          }\\n          if (this.match(135)) {\\n            return this.parseLiteralAtNode(-this.state.value, \\\"BigIntLiteralTypeAnnotation\\\", node);\\n          }\\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\\n        }\\n        this.unexpected();\\n        return;\\n      case 134:\\n        return this.parseLiteral(this.state.value, \\\"NumberLiteralTypeAnnotation\\\");\\n      case 135:\\n        return this.parseLiteral(this.state.value, \\\"BigIntLiteralTypeAnnotation\\\");\\n      case 88:\\n        this.next();\\n        return this.finishNode(node, \\\"VoidTypeAnnotation\\\");\\n      case 84:\\n        this.next();\\n        return this.finishNode(node, \\\"NullLiteralTypeAnnotation\\\");\\n      case 78:\\n        this.next();\\n        return this.finishNode(node, \\\"ThisTypeAnnotation\\\");\\n      case 55:\\n        this.next();\\n        return this.finishNode(node, \\\"ExistsTypeAnnotation\\\");\\n      case 87:\\n        return this.flowParseTypeofType();\\n      default:\\n        if (tokenIsKeyword(this.state.type)) {\\n          const label = tokenLabelName(this.state.type);\\n          this.next();\\n          return super.createIdentifier(node, label);\\n        } else if (tokenIsIdentifier(this.state.type)) {\\n          if (this.isContextual(129)) {\\n            return this.flowParseInterfaceType();\\n          }\\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\\n        }\\n    }\\n    this.unexpected();\\n  }\\n  flowParsePostfixType() {\\n    const startLoc = this.state.startLoc;\\n    let type = this.flowParsePrimaryType();\\n    let seenOptionalIndexedAccess = false;\\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\\n      const node = this.startNodeAt(startLoc);\\n      const optional = this.eat(18);\\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\\n      this.expect(0);\\n      if (!optional && this.match(3)) {\\n        node.elementType = type;\\n        this.next();\\n        type = this.finishNode(node, \\\"ArrayTypeAnnotation\\\");\\n      } else {\\n        node.objectType = type;\\n        node.indexType = this.flowParseType();\\n        this.expect(3);\\n        if (seenOptionalIndexedAccess) {\\n          node.optional = optional;\\n          type = this.finishNode(node, \\\"OptionalIndexedAccessType\\\");\\n        } else {\\n          type = this.finishNode(node, \\\"IndexedAccessType\\\");\\n        }\\n      }\\n    }\\n    return type;\\n  }\\n  flowParsePrefixType() {\\n    const node = this.startNode();\\n    if (this.eat(17)) {\\n      node.typeAnnotation = this.flowParsePrefixType();\\n      return this.finishNode(node, \\\"NullableTypeAnnotation\\\");\\n    } else {\\n      return this.flowParsePostfixType();\\n    }\\n  }\\n  flowParseAnonFunctionWithoutParens() {\\n    const param = this.flowParsePrefixType();\\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\\n      const node = this.startNodeAt(param.loc.start);\\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\\n      node.rest = null;\\n      node.this = null;\\n      node.returnType = this.flowParseType();\\n      node.typeParameters = null;\\n      return this.finishNode(node, \\\"FunctionTypeAnnotation\\\");\\n    }\\n    return param;\\n  }\\n  flowParseIntersectionType() {\\n    const node = this.startNode();\\n    this.eat(45);\\n    const type = this.flowParseAnonFunctionWithoutParens();\\n    node.types = [type];\\n    while (this.eat(45)) {\\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\\n    }\\n    return node.types.length === 1 ? type : this.finishNode(node, \\\"IntersectionTypeAnnotation\\\");\\n  }\\n  flowParseUnionType() {\\n    const node = this.startNode();\\n    this.eat(43);\\n    const type = this.flowParseIntersectionType();\\n    node.types = [type];\\n    while (this.eat(43)) {\\n      node.types.push(this.flowParseIntersectionType());\\n    }\\n    return node.types.length === 1 ? type : this.finishNode(node, \\\"UnionTypeAnnotation\\\");\\n  }\\n  flowParseType() {\\n    const oldInType = this.state.inType;\\n    this.state.inType = true;\\n    const type = this.flowParseUnionType();\\n    this.state.inType = oldInType;\\n    return type;\\n  }\\n  flowParseTypeOrImplicitInstantiation() {\\n    if (this.state.type === 132 && this.state.value === \\\"_\\\") {\\n      const startLoc = this.state.startLoc;\\n      const node = this.parseIdentifier();\\n      return this.flowParseGenericType(startLoc, node);\\n    } else {\\n      return this.flowParseType();\\n    }\\n  }\\n  flowParseTypeAnnotation() {\\n    const node = this.startNode();\\n    node.typeAnnotation = this.flowParseTypeInitialiser();\\n    return this.finishNode(node, \\\"TypeAnnotation\\\");\\n  }\\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\\n    if (this.match(14)) {\\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\\n      this.resetEndLocation(ident);\\n    }\\n    return ident;\\n  }\\n  typeCastToParameter(node) {\\n    node.expression.typeAnnotation = node.typeAnnotation;\\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\\n    return node.expression;\\n  }\\n  flowParseVariance() {\\n    let variance = null;\\n    if (this.match(53)) {\\n      variance = this.startNode();\\n      if (this.state.value === \\\"+\\\") {\\n        variance.kind = \\\"plus\\\";\\n      } else {\\n        variance.kind = \\\"minus\\\";\\n      }\\n      this.next();\\n      return this.finishNode(variance, \\\"Variance\\\");\\n    }\\n    return variance;\\n  }\\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\\n    if (allowExpressionBody) {\\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\\n      return;\\n    }\\n    super.parseFunctionBody(node, false, isMethod);\\n  }\\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\\n    if (this.match(14)) {\\n      const typeNode = this.startNode();\\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \\\"TypeAnnotation\\\") : null;\\n    }\\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\\n  }\\n  parseStatementLike(flags) {\\n    if (this.state.strict && this.isContextual(129)) {\\n      const lookahead = this.lookahead();\\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\\n        const node = this.startNode();\\n        this.next();\\n        return this.flowParseInterface(node);\\n      }\\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\\n      const node = this.startNode();\\n      this.next();\\n      return this.flowParseEnumDeclaration(node);\\n    }\\n    const stmt = super.parseStatementLike(flags);\\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\\n      this.flowPragma = null;\\n    }\\n    return stmt;\\n  }\\n  parseExpressionStatement(node, expr, decorators) {\\n    if (expr.type === \\\"Identifier\\\") {\\n      if (expr.name === \\\"declare\\\") {\\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\\n          return this.flowParseDeclare(node);\\n        }\\n      } else if (tokenIsIdentifier(this.state.type)) {\\n        if (expr.name === \\\"interface\\\") {\\n          return this.flowParseInterface(node);\\n        } else if (expr.name === \\\"type\\\") {\\n          return this.flowParseTypeAlias(node);\\n        } else if (expr.name === \\\"opaque\\\") {\\n          return this.flowParseOpaqueType(node, false);\\n        }\\n      }\\n    }\\n    return super.parseExpressionStatement(node, expr, decorators);\\n  }\\n  shouldParseExportDeclaration() {\\n    const {\\n      type\\n    } = this.state;\\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\\n      return !this.state.containsEsc;\\n    }\\n    return super.shouldParseExportDeclaration();\\n  }\\n  isExportDefaultSpecifier() {\\n    const {\\n      type\\n    } = this.state;\\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\\n      return this.state.containsEsc;\\n    }\\n    return super.isExportDefaultSpecifier();\\n  }\\n  parseExportDefaultExpression() {\\n    if (this.shouldParseEnums() && this.isContextual(126)) {\\n      const node = this.startNode();\\n      this.next();\\n      return this.flowParseEnumDeclaration(node);\\n    }\\n    return super.parseExportDefaultExpression();\\n  }\\n  parseConditional(expr, startLoc, refExpressionErrors) {\\n    if (!this.match(17)) return expr;\\n    if (this.state.maybeInArrowParameters) {\\n      const nextCh = this.lookaheadCharCode();\\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\\n        this.setOptionalParametersError(refExpressionErrors);\\n        return expr;\\n      }\\n    }\\n    this.expect(17);\\n    const state = this.state.clone();\\n    const originalNoArrowAt = this.state.noArrowAt;\\n    const node = this.startNodeAt(startLoc);\\n    let {\\n      consequent,\\n      failed\\n    } = this.tryParseConditionalConsequent();\\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\\n    if (failed || invalid.length > 0) {\\n      const noArrowAt = [...originalNoArrowAt];\\n      if (invalid.length > 0) {\\n        this.state = state;\\n        this.state.noArrowAt = noArrowAt;\\n        for (let i = 0; i < invalid.length; i++) {\\n          noArrowAt.push(invalid[i].start);\\n        }\\n        ({\\n          consequent,\\n          failed\\n        } = this.tryParseConditionalConsequent());\\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\\n      }\\n      if (failed && valid.length > 1) {\\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\\n      }\\n      if (failed && valid.length === 1) {\\n        this.state = state;\\n        noArrowAt.push(valid[0].start);\\n        this.state.noArrowAt = noArrowAt;\\n        ({\\n          consequent,\\n          failed\\n        } = this.tryParseConditionalConsequent());\\n      }\\n    }\\n    this.getArrowLikeExpressions(consequent, true);\\n    this.state.noArrowAt = originalNoArrowAt;\\n    this.expect(14);\\n    node.test = expr;\\n    node.consequent = consequent;\\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\\n    return this.finishNode(node, \\\"ConditionalExpression\\\");\\n  }\\n  tryParseConditionalConsequent() {\\n    this.state.noArrowParamsConversionAt.push(this.state.start);\\n    const consequent = this.parseMaybeAssignAllowIn();\\n    const failed = !this.match(14);\\n    this.state.noArrowParamsConversionAt.pop();\\n    return {\\n      consequent,\\n      failed\\n    };\\n  }\\n  getArrowLikeExpressions(node, disallowInvalid) {\\n    const stack = [node];\\n    const arrows = [];\\n    while (stack.length !== 0) {\\n      const node = stack.pop();\\n      if (node.type === \\\"ArrowFunctionExpression\\\") {\\n        if (node.typeParameters || !node.returnType) {\\n          this.finishArrowValidation(node);\\n        } else {\\n          arrows.push(node);\\n        }\\n        stack.push(node.body);\\n      } else if (node.type === \\\"ConditionalExpression\\\") {\\n        stack.push(node.consequent);\\n        stack.push(node.alternate);\\n      }\\n    }\\n    if (disallowInvalid) {\\n      arrows.forEach(node => this.finishArrowValidation(node));\\n      return [arrows, []];\\n    }\\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\\n  }\\n  finishArrowValidation(node) {\\n    var _node$extra;\\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\\n    this.scope.enter(2 | 4);\\n    super.checkParams(node, false, true);\\n    this.scope.exit();\\n  }\\n  forwardNoArrowParamsConversionAt(node, parse) {\\n    let result;\\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\\n      this.state.noArrowParamsConversionAt.push(this.state.start);\\n      result = parse();\\n      this.state.noArrowParamsConversionAt.pop();\\n    } else {\\n      result = parse();\\n    }\\n    return result;\\n  }\\n  parseParenItem(node, startLoc) {\\n    node = super.parseParenItem(node, startLoc);\\n    if (this.eat(17)) {\\n      node.optional = true;\\n      this.resetEndLocation(node);\\n    }\\n    if (this.match(14)) {\\n      const typeCastNode = this.startNodeAt(startLoc);\\n      typeCastNode.expression = node;\\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\\n      return this.finishNode(typeCastNode, \\\"TypeCastExpression\\\");\\n    }\\n    return node;\\n  }\\n  assertModuleNodeAllowed(node) {\\n    if (node.type === \\\"ImportDeclaration\\\" && (node.importKind === \\\"type\\\" || node.importKind === \\\"typeof\\\") || node.type === \\\"ExportNamedDeclaration\\\" && node.exportKind === \\\"type\\\" || node.type === \\\"ExportAllDeclaration\\\" && node.exportKind === \\\"type\\\") {\\n      return;\\n    }\\n    super.assertModuleNodeAllowed(node);\\n  }\\n  parseExportDeclaration(node) {\\n    if (this.isContextual(130)) {\\n      node.exportKind = \\\"type\\\";\\n      const declarationNode = this.startNode();\\n      this.next();\\n      if (this.match(5)) {\\n        node.specifiers = this.parseExportSpecifiers(true);\\n        super.parseExportFrom(node);\\n        return null;\\n      } else {\\n        return this.flowParseTypeAlias(declarationNode);\\n      }\\n    } else if (this.isContextual(131)) {\\n      node.exportKind = \\\"type\\\";\\n      const declarationNode = this.startNode();\\n      this.next();\\n      return this.flowParseOpaqueType(declarationNode, false);\\n    } else if (this.isContextual(129)) {\\n      node.exportKind = \\\"type\\\";\\n      const declarationNode = this.startNode();\\n      this.next();\\n      return this.flowParseInterface(declarationNode);\\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\\n      node.exportKind = \\\"value\\\";\\n      const declarationNode = this.startNode();\\n      this.next();\\n      return this.flowParseEnumDeclaration(declarationNode);\\n    } else {\\n      return super.parseExportDeclaration(node);\\n    }\\n  }\\n  eatExportStar(node) {\\n    if (super.eatExportStar(node)) return true;\\n    if (this.isContextual(130) && this.lookahead().type === 55) {\\n      node.exportKind = \\\"type\\\";\\n      this.next();\\n      this.next();\\n      return true;\\n    }\\n    return false;\\n  }\\n  maybeParseExportNamespaceSpecifier(node) {\\n    const {\\n      startLoc\\n    } = this.state;\\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\\n    if (hasNamespace && node.exportKind === \\\"type\\\") {\\n      this.unexpected(startLoc);\\n    }\\n    return hasNamespace;\\n  }\\n  parseClassId(node, isStatement, optionalId) {\\n    super.parseClassId(node, isStatement, optionalId);\\n    if (this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\\n    }\\n  }\\n  parseClassMember(classBody, member, state) {\\n    const {\\n      startLoc\\n    } = this.state;\\n    if (this.isContextual(125)) {\\n      if (super.parseClassMemberFromModifier(classBody, member)) {\\n        return;\\n      }\\n      member.declare = true;\\n    }\\n    super.parseClassMember(classBody, member, state);\\n    if (member.declare) {\\n      if (member.type !== \\\"ClassProperty\\\" && member.type !== \\\"ClassPrivateProperty\\\" && member.type !== \\\"PropertyDefinition\\\") {\\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\\n      } else if (member.value) {\\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\\n      }\\n    }\\n  }\\n  isIterator(word) {\\n    return word === \\\"iterator\\\" || word === \\\"asyncIterator\\\";\\n  }\\n  readIterator() {\\n    const word = super.readWord1();\\n    const fullWord = \\\"@@\\\" + word;\\n    if (!this.isIterator(word) || !this.state.inType) {\\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\\n        identifierName: fullWord\\n      });\\n    }\\n    this.finishToken(132, fullWord);\\n  }\\n  getTokenFromCode(code) {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (code === 123 && next === 124) {\\n      this.finishOp(6, 2);\\n    } else if (this.state.inType && (code === 62 || code === 60)) {\\n      this.finishOp(code === 62 ? 48 : 47, 1);\\n    } else if (this.state.inType && code === 63) {\\n      if (next === 46) {\\n        this.finishOp(18, 2);\\n      } else {\\n        this.finishOp(17, 1);\\n      }\\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\\n      this.state.pos += 2;\\n      this.readIterator();\\n    } else {\\n      super.getTokenFromCode(code);\\n    }\\n  }\\n  isAssignable(node, isBinding) {\\n    if (node.type === \\\"TypeCastExpression\\\") {\\n      return this.isAssignable(node.expression, isBinding);\\n    } else {\\n      return super.isAssignable(node, isBinding);\\n    }\\n  }\\n  toAssignable(node, isLHS = false) {\\n    if (!isLHS && node.type === \\\"AssignmentExpression\\\" && node.left.type === \\\"TypeCastExpression\\\") {\\n      node.left = this.typeCastToParameter(node.left);\\n    }\\n    super.toAssignable(node, isLHS);\\n  }\\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\\n    for (let i = 0; i < exprList.length; i++) {\\n      const expr = exprList[i];\\n      if ((expr == null ? void 0 : expr.type) === \\\"TypeCastExpression\\\") {\\n        exprList[i] = this.typeCastToParameter(expr);\\n      }\\n    }\\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\\n  }\\n  toReferencedList(exprList, isParenthesizedExpr) {\\n    for (let i = 0; i < exprList.length; i++) {\\n      var _expr$extra;\\n      const expr = exprList[i];\\n      if (expr && expr.type === \\\"TypeCastExpression\\\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\\n      }\\n    }\\n    return exprList;\\n  }\\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\\n    if (canBePattern && !this.state.maybeInArrowParameters) {\\n      this.toReferencedList(node.elements);\\n    }\\n    return node;\\n  }\\n  isValidLVal(type, isParenthesized, binding) {\\n    return type === \\\"TypeCastExpression\\\" || super.isValidLVal(type, isParenthesized, binding);\\n  }\\n  parseClassProperty(node) {\\n    if (this.match(14)) {\\n      node.typeAnnotation = this.flowParseTypeAnnotation();\\n    }\\n    return super.parseClassProperty(node);\\n  }\\n  parseClassPrivateProperty(node) {\\n    if (this.match(14)) {\\n      node.typeAnnotation = this.flowParseTypeAnnotation();\\n    }\\n    return super.parseClassPrivateProperty(node);\\n  }\\n  isClassMethod() {\\n    return this.match(47) || super.isClassMethod();\\n  }\\n  isClassProperty() {\\n    return this.match(14) || super.isClassProperty();\\n  }\\n  isNonstaticConstructor(method) {\\n    return !this.match(14) && super.isNonstaticConstructor(method);\\n  }\\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\\n    if (method.variance) {\\n      this.unexpected(method.variance.loc.start);\\n    }\\n    delete method.variance;\\n    if (this.match(47)) {\\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\\n    }\\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\\n    if (method.params && isConstructor) {\\n      const params = method.params;\\n      if (params.length > 0 && this.isThisParam(params[0])) {\\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\\n      }\\n    } else if (method.type === \\\"MethodDefinition\\\" && isConstructor && method.value.params) {\\n      const params = method.value.params;\\n      if (params.length > 0 && this.isThisParam(params[0])) {\\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\\n      }\\n    }\\n  }\\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\\n    if (method.variance) {\\n      this.unexpected(method.variance.loc.start);\\n    }\\n    delete method.variance;\\n    if (this.match(47)) {\\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\\n    }\\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\\n  }\\n  parseClassSuper(node) {\\n    super.parseClassSuper(node);\\n    if (node.superClass && this.match(47)) {\\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\\n    }\\n    if (this.isContextual(113)) {\\n      this.next();\\n      const implemented = node.implements = [];\\n      do {\\n        const node = this.startNode();\\n        node.id = this.flowParseRestrictedIdentifier(true);\\n        if (this.match(47)) {\\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\\n        } else {\\n          node.typeParameters = null;\\n        }\\n        implemented.push(this.finishNode(node, \\\"ClassImplements\\\"));\\n      } while (this.eat(12));\\n    }\\n  }\\n  checkGetterSetterParams(method) {\\n    super.checkGetterSetterParams(method);\\n    const params = this.getObjectOrClassMethodParams(method);\\n    if (params.length > 0) {\\n      const param = params[0];\\n      if (this.isThisParam(param) && method.kind === \\\"get\\\") {\\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\\n      } else if (this.isThisParam(param)) {\\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\\n      }\\n    }\\n  }\\n  parsePropertyNamePrefixOperator(node) {\\n    node.variance = this.flowParseVariance();\\n  }\\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\\n    if (prop.variance) {\\n      this.unexpected(prop.variance.loc.start);\\n    }\\n    delete prop.variance;\\n    let typeParameters;\\n    if (this.match(47) && !isAccessor) {\\n      typeParameters = this.flowParseTypeParameterDeclaration();\\n      if (!this.match(10)) this.unexpected();\\n    }\\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\\n    if (typeParameters) {\\n      (result.value || result).typeParameters = typeParameters;\\n    }\\n    return result;\\n  }\\n  parseAssignableListItemTypes(param) {\\n    if (this.eat(17)) {\\n      if (param.type !== \\\"Identifier\\\") {\\n        this.raise(FlowErrors.PatternIsOptional, param);\\n      }\\n      if (this.isThisParam(param)) {\\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\\n      }\\n      param.optional = true;\\n    }\\n    if (this.match(14)) {\\n      param.typeAnnotation = this.flowParseTypeAnnotation();\\n    } else if (this.isThisParam(param)) {\\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\\n    }\\n    if (this.match(29) && this.isThisParam(param)) {\\n      this.raise(FlowErrors.ThisParamNoDefault, param);\\n    }\\n    this.resetEndLocation(param);\\n    return param;\\n  }\\n  parseMaybeDefault(startLoc, left) {\\n    const node = super.parseMaybeDefault(startLoc, left);\\n    if (node.type === \\\"AssignmentPattern\\\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\\n    }\\n    return node;\\n  }\\n  checkImportReflection(node) {\\n    super.checkImportReflection(node);\\n    if (node.module && node.importKind !== \\\"value\\\") {\\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\\n    }\\n  }\\n  parseImportSpecifierLocal(node, specifier, type) {\\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\\n  }\\n  isPotentialImportPhase(isExport) {\\n    if (super.isPotentialImportPhase(isExport)) return true;\\n    if (this.isContextual(130)) {\\n      if (!isExport) return true;\\n      const ch = this.lookaheadCharCode();\\n      return ch === 123 || ch === 42;\\n    }\\n    return !isExport && this.isContextual(87);\\n  }\\n  applyImportPhase(node, isExport, phase, loc) {\\n    super.applyImportPhase(node, isExport, phase, loc);\\n    if (isExport) {\\n      if (!phase && this.match(65)) {\\n        return;\\n      }\\n      node.exportKind = phase === \\\"type\\\" ? phase : \\\"value\\\";\\n    } else {\\n      if (phase === \\\"type\\\" && this.match(55)) this.unexpected();\\n      node.importKind = phase === \\\"type\\\" || phase === \\\"typeof\\\" ? phase : \\\"value\\\";\\n    }\\n  }\\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\\n    const firstIdent = specifier.imported;\\n    let specifierTypeKind = null;\\n    if (firstIdent.type === \\\"Identifier\\\") {\\n      if (firstIdent.name === \\\"type\\\") {\\n        specifierTypeKind = \\\"type\\\";\\n      } else if (firstIdent.name === \\\"typeof\\\") {\\n        specifierTypeKind = \\\"typeof\\\";\\n      }\\n    }\\n    let isBinding = false;\\n    if (this.isContextual(93) && !this.isLookaheadContextual(\\\"as\\\")) {\\n      const as_ident = this.parseIdentifier(true);\\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\\n        specifier.imported = as_ident;\\n        specifier.importKind = specifierTypeKind;\\n        specifier.local = cloneIdentifier(as_ident);\\n      } else {\\n        specifier.imported = firstIdent;\\n        specifier.importKind = null;\\n        specifier.local = this.parseIdentifier();\\n      }\\n    } else {\\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\\n        specifier.imported = this.parseIdentifier(true);\\n        specifier.importKind = specifierTypeKind;\\n      } else {\\n        if (importedIsString) {\\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\\n            importName: firstIdent.value\\n          });\\n        }\\n        specifier.imported = firstIdent;\\n        specifier.importKind = null;\\n      }\\n      if (this.eatContextual(93)) {\\n        specifier.local = this.parseIdentifier();\\n      } else {\\n        isBinding = true;\\n        specifier.local = cloneIdentifier(specifier.imported);\\n      }\\n    }\\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\\n    }\\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\\n    }\\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\\n    }\\n    return this.finishImportSpecifier(specifier, \\\"ImportSpecifier\\\");\\n  }\\n  parseBindingAtom() {\\n    switch (this.state.type) {\\n      case 78:\\n        return this.parseIdentifier(true);\\n      default:\\n        return super.parseBindingAtom();\\n    }\\n  }\\n  parseFunctionParams(node, isConstructor) {\\n    const kind = node.kind;\\n    if (kind !== \\\"get\\\" && kind !== \\\"set\\\" && this.match(47)) {\\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\\n    }\\n    super.parseFunctionParams(node, isConstructor);\\n  }\\n  parseVarId(decl, kind) {\\n    super.parseVarId(decl, kind);\\n    if (this.match(14)) {\\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\\n      this.resetEndLocation(decl.id);\\n    }\\n  }\\n  parseAsyncArrowFromCallExpression(node, call) {\\n    if (this.match(14)) {\\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\\n      this.state.noAnonFunctionType = true;\\n      node.returnType = this.flowParseTypeAnnotation();\\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\\n    }\\n    return super.parseAsyncArrowFromCallExpression(node, call);\\n  }\\n  shouldParseAsyncArrow() {\\n    return this.match(14) || super.shouldParseAsyncArrow();\\n  }\\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\\n    var _jsx;\\n    let state = null;\\n    let jsx;\\n    if (this.hasPlugin(\\\"jsx\\\") && (this.match(142) || this.match(47))) {\\n      state = this.state.clone();\\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\\n      if (!jsx.error) return jsx.node;\\n      const {\\n        context\\n      } = this.state;\\n      const currentContext = context[context.length - 1];\\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\\n        context.pop();\\n      }\\n    }\\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\\n      var _jsx2, _jsx3;\\n      state = state || this.state.clone();\\n      let typeParameters;\\n      const arrow = this.tryParse(abort => {\\n        var _arrowExpression$extr;\\n        typeParameters = this.flowParseTypeParameterDeclaration();\\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\\n          this.resetStartLocationFromNode(result, typeParameters);\\n          return result;\\n        });\\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\\n        if (expr.type !== \\\"ArrowFunctionExpression\\\") abort();\\n        expr.typeParameters = typeParameters;\\n        this.resetStartLocationFromNode(expr, typeParameters);\\n        return arrowExpression;\\n      }, state);\\n      let arrowExpression = null;\\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \\\"ArrowFunctionExpression\\\") {\\n        if (!arrow.error && !arrow.aborted) {\\n          if (arrow.node.async) {\\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\\n          }\\n          return arrow.node;\\n        }\\n        arrowExpression = arrow.node;\\n      }\\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\\n        this.state = jsx.failState;\\n        return jsx.node;\\n      }\\n      if (arrowExpression) {\\n        this.state = arrow.failState;\\n        return arrowExpression;\\n      }\\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\\n      if (arrow.thrown) throw arrow.error;\\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\\n    }\\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\\n  }\\n  parseArrow(node) {\\n    if (this.match(14)) {\\n      const result = this.tryParse(() => {\\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\\n        this.state.noAnonFunctionType = true;\\n        const typeNode = this.startNode();\\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\\n        if (this.canInsertSemicolon()) this.unexpected();\\n        if (!this.match(19)) this.unexpected();\\n        return typeNode;\\n      });\\n      if (result.thrown) return null;\\n      if (result.error) this.state = result.failState;\\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \\\"TypeAnnotation\\\") : null;\\n    }\\n    return super.parseArrow(node);\\n  }\\n  shouldParseArrow(params) {\\n    return this.match(14) || super.shouldParseArrow(params);\\n  }\\n  setArrowFunctionParameters(node, params) {\\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\\n      node.params = params;\\n    } else {\\n      super.setArrowFunctionParameters(node, params);\\n    }\\n  }\\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\\n      return;\\n    }\\n    for (let i = 0; i < node.params.length; i++) {\\n      if (this.isThisParam(node.params[i]) && i > 0) {\\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\\n      }\\n    }\\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\\n  }\\n  parseParenAndDistinguishExpression(canBeArrow) {\\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\\n  }\\n  parseSubscripts(base, startLoc, noCalls) {\\n    if (base.type === \\\"Identifier\\\" && base.name === \\\"async\\\" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {\\n      this.next();\\n      const node = this.startNodeAt(startLoc);\\n      node.callee = base;\\n      node.arguments = super.parseCallExpressionArguments(11, false);\\n      base = this.finishNode(node, \\\"CallExpression\\\");\\n    } else if (base.type === \\\"Identifier\\\" && base.name === \\\"async\\\" && this.match(47)) {\\n      const state = this.state.clone();\\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\\n      if (!arrow.error && !arrow.aborted) return arrow.node;\\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\\n      if (result.node && !result.error) return result.node;\\n      if (arrow.node) {\\n        this.state = arrow.failState;\\n        return arrow.node;\\n      }\\n      if (result.node) {\\n        this.state = result.failState;\\n        return result.node;\\n      }\\n      throw arrow.error || result.error;\\n    }\\n    return super.parseSubscripts(base, startLoc, noCalls);\\n  }\\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\\n    if (this.match(18) && this.isLookaheadToken_lt()) {\\n      subscriptState.optionalChainMember = true;\\n      if (noCalls) {\\n        subscriptState.stop = true;\\n        return base;\\n      }\\n      this.next();\\n      const node = this.startNodeAt(startLoc);\\n      node.callee = base;\\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\\n      this.expect(10);\\n      node.arguments = this.parseCallExpressionArguments(11, false);\\n      node.optional = true;\\n      return this.finishCallExpression(node, true);\\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\\n      const node = this.startNodeAt(startLoc);\\n      node.callee = base;\\n      const result = this.tryParse(() => {\\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\\n        this.expect(10);\\n        node.arguments = super.parseCallExpressionArguments(11, false);\\n        if (subscriptState.optionalChainMember) {\\n          node.optional = false;\\n        }\\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\\n      });\\n      if (result.node) {\\n        if (result.error) this.state = result.failState;\\n        return result.node;\\n      }\\n    }\\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\\n  }\\n  parseNewCallee(node) {\\n    super.parseNewCallee(node);\\n    let targs = null;\\n    if (this.shouldParseTypes() && this.match(47)) {\\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\\n    }\\n    node.typeArguments = targs;\\n  }\\n  parseAsyncArrowWithTypeParameters(startLoc) {\\n    const node = this.startNodeAt(startLoc);\\n    this.parseFunctionParams(node, false);\\n    if (!this.parseArrow(node)) return;\\n    return super.parseArrowExpression(node, undefined, true);\\n  }\\n  readToken_mult_modulo(code) {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\\n      this.state.hasFlowComment = false;\\n      this.state.pos += 2;\\n      this.nextToken();\\n      return;\\n    }\\n    super.readToken_mult_modulo(code);\\n  }\\n  readToken_pipe_amp(code) {\\n    const next = this.input.charCodeAt(this.state.pos + 1);\\n    if (code === 124 && next === 125) {\\n      this.finishOp(9, 2);\\n      return;\\n    }\\n    super.readToken_pipe_amp(code);\\n  }\\n  parseTopLevel(file, program) {\\n    const fileNode = super.parseTopLevel(file, program);\\n    if (this.state.hasFlowComment) {\\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\\n    }\\n    return fileNode;\\n  }\\n  skipBlockComment() {\\n    if (this.hasPlugin(\\\"flowComments\\\") && this.skipFlowComment()) {\\n      if (this.state.hasFlowComment) {\\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\\n      }\\n      this.hasFlowCommentCompletion();\\n      const commentSkip = this.skipFlowComment();\\n      if (commentSkip) {\\n        this.state.pos += commentSkip;\\n        this.state.hasFlowComment = true;\\n      }\\n      return;\\n    }\\n    return super.skipBlockComment(this.state.hasFlowComment ? \\\"*-/\\\" : \\\"*/\\\");\\n  }\\n  skipFlowComment() {\\n    const {\\n      pos\\n    } = this.state;\\n    let shiftToFirstNonWhiteSpace = 2;\\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\\n      shiftToFirstNonWhiteSpace++;\\n    }\\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\\n    if (ch2 === 58 && ch3 === 58) {\\n      return shiftToFirstNonWhiteSpace + 2;\\n    }\\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \\\"flow-include\\\") {\\n      return shiftToFirstNonWhiteSpace + 12;\\n    }\\n    if (ch2 === 58 && ch3 !== 58) {\\n      return shiftToFirstNonWhiteSpace;\\n    }\\n    return false;\\n  }\\n  hasFlowCommentCompletion() {\\n    const end = this.input.indexOf(\\\"*/\\\", this.state.pos);\\n    if (end === -1) {\\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\\n    }\\n  }\\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\\n    enumName,\\n    memberName\\n  }) {\\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\\n      memberName,\\n      enumName\\n    });\\n  }\\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \\\"symbol\\\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\\n  }\\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\\n  }\\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\\n  }\\n  flowEnumMemberInit() {\\n    const startLoc = this.state.startLoc;\\n    const endOfInit = () => this.match(12) || this.match(8);\\n    switch (this.state.type) {\\n      case 134:\\n        {\\n          const literal = this.parseNumericLiteral(this.state.value);\\n          if (endOfInit()) {\\n            return {\\n              type: \\\"number\\\",\\n              loc: literal.loc.start,\\n              value: literal\\n            };\\n          }\\n          return {\\n            type: \\\"invalid\\\",\\n            loc: startLoc\\n          };\\n        }\\n      case 133:\\n        {\\n          const literal = this.parseStringLiteral(this.state.value);\\n          if (endOfInit()) {\\n            return {\\n              type: \\\"string\\\",\\n              loc: literal.loc.start,\\n              value: literal\\n            };\\n          }\\n          return {\\n            type: \\\"invalid\\\",\\n            loc: startLoc\\n          };\\n        }\\n      case 85:\\n      case 86:\\n        {\\n          const literal = this.parseBooleanLiteral(this.match(85));\\n          if (endOfInit()) {\\n            return {\\n              type: \\\"boolean\\\",\\n              loc: literal.loc.start,\\n              value: literal\\n            };\\n          }\\n          return {\\n            type: \\\"invalid\\\",\\n            loc: startLoc\\n          };\\n        }\\n      default:\\n        return {\\n          type: \\\"invalid\\\",\\n          loc: startLoc\\n        };\\n    }\\n  }\\n  flowEnumMemberRaw() {\\n    const loc = this.state.startLoc;\\n    const id = this.parseIdentifier(true);\\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\\n      type: \\\"none\\\",\\n      loc\\n    };\\n    return {\\n      id,\\n      init\\n    };\\n  }\\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\\n    const {\\n      explicitType\\n    } = context;\\n    if (explicitType === null) {\\n      return;\\n    }\\n    if (explicitType !== expectedType) {\\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\\n    }\\n  }\\n  flowEnumMembers({\\n    enumName,\\n    explicitType\\n  }) {\\n    const seenNames = new Set();\\n    const members = {\\n      booleanMembers: [],\\n      numberMembers: [],\\n      stringMembers: [],\\n      defaultedMembers: []\\n    };\\n    let hasUnknownMembers = false;\\n    while (!this.match(8)) {\\n      if (this.eat(21)) {\\n        hasUnknownMembers = true;\\n        break;\\n      }\\n      const memberNode = this.startNode();\\n      const {\\n        id,\\n        init\\n      } = this.flowEnumMemberRaw();\\n      const memberName = id.name;\\n      if (memberName === \\\"\\\") {\\n        continue;\\n      }\\n      if (/^[a-z]/.test(memberName)) {\\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\\n          memberName,\\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\\n          enumName\\n        });\\n      }\\n      if (seenNames.has(memberName)) {\\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\\n          memberName,\\n          enumName\\n        });\\n      }\\n      seenNames.add(memberName);\\n      const context = {\\n        enumName,\\n        explicitType,\\n        memberName\\n      };\\n      memberNode.id = id;\\n      switch (init.type) {\\n        case \\\"boolean\\\":\\n          {\\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \\\"boolean\\\");\\n            memberNode.init = init.value;\\n            members.booleanMembers.push(this.finishNode(memberNode, \\\"EnumBooleanMember\\\"));\\n            break;\\n          }\\n        case \\\"number\\\":\\n          {\\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \\\"number\\\");\\n            memberNode.init = init.value;\\n            members.numberMembers.push(this.finishNode(memberNode, \\\"EnumNumberMember\\\"));\\n            break;\\n          }\\n        case \\\"string\\\":\\n          {\\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \\\"string\\\");\\n            memberNode.init = init.value;\\n            members.stringMembers.push(this.finishNode(memberNode, \\\"EnumStringMember\\\"));\\n            break;\\n          }\\n        case \\\"invalid\\\":\\n          {\\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\\n          }\\n        case \\\"none\\\":\\n          {\\n            switch (explicitType) {\\n              case \\\"boolean\\\":\\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\\n                break;\\n              case \\\"number\\\":\\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\\n                break;\\n              default:\\n                members.defaultedMembers.push(this.finishNode(memberNode, \\\"EnumDefaultedMember\\\"));\\n            }\\n          }\\n      }\\n      if (!this.match(8)) {\\n        this.expect(12);\\n      }\\n    }\\n    return {\\n      members,\\n      hasUnknownMembers\\n    };\\n  }\\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\\n    enumName\\n  }) {\\n    if (initializedMembers.length === 0) {\\n      return defaultedMembers;\\n    } else if (defaultedMembers.length === 0) {\\n      return initializedMembers;\\n    } else if (defaultedMembers.length > initializedMembers.length) {\\n      for (const member of initializedMembers) {\\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\\n          enumName\\n        });\\n      }\\n      return defaultedMembers;\\n    } else {\\n      for (const member of defaultedMembers) {\\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\\n          enumName\\n        });\\n      }\\n      return initializedMembers;\\n    }\\n  }\\n  flowEnumParseExplicitType({\\n    enumName\\n  }) {\\n    if (!this.eatContextual(102)) return null;\\n    if (!tokenIsIdentifier(this.state.type)) {\\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\\n        enumName\\n      });\\n    }\\n    const {\\n      value\\n    } = this.state;\\n    this.next();\\n    if (value !== \\\"boolean\\\" && value !== \\\"number\\\" && value !== \\\"string\\\" && value !== \\\"symbol\\\") {\\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\\n        enumName,\\n        invalidEnumType: value\\n      });\\n    }\\n    return value;\\n  }\\n  flowEnumBody(node, id) {\\n    const enumName = id.name;\\n    const nameLoc = id.loc.start;\\n    const explicitType = this.flowEnumParseExplicitType({\\n      enumName\\n    });\\n    this.expect(5);\\n    const {\\n      members,\\n      hasUnknownMembers\\n    } = this.flowEnumMembers({\\n      enumName,\\n      explicitType\\n    });\\n    node.hasUnknownMembers = hasUnknownMembers;\\n    switch (explicitType) {\\n      case \\\"boolean\\\":\\n        node.explicitType = true;\\n        node.members = members.booleanMembers;\\n        this.expect(8);\\n        return this.finishNode(node, \\\"EnumBooleanBody\\\");\\n      case \\\"number\\\":\\n        node.explicitType = true;\\n        node.members = members.numberMembers;\\n        this.expect(8);\\n        return this.finishNode(node, \\\"EnumNumberBody\\\");\\n      case \\\"string\\\":\\n        node.explicitType = true;\\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\\n          enumName\\n        });\\n        this.expect(8);\\n        return this.finishNode(node, \\\"EnumStringBody\\\");\\n      case \\\"symbol\\\":\\n        node.members = members.defaultedMembers;\\n        this.expect(8);\\n        return this.finishNode(node, \\\"EnumSymbolBody\\\");\\n      default:\\n        {\\n          const empty = () => {\\n            node.members = [];\\n            this.expect(8);\\n            return this.finishNode(node, \\\"EnumStringBody\\\");\\n          };\\n          node.explicitType = false;\\n          const boolsLen = members.booleanMembers.length;\\n          const numsLen = members.numberMembers.length;\\n          const strsLen = members.stringMembers.length;\\n          const defaultedLen = members.defaultedMembers.length;\\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\\n            return empty();\\n          } else if (!boolsLen && !numsLen) {\\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\\n              enumName\\n            });\\n            this.expect(8);\\n            return this.finishNode(node, \\\"EnumStringBody\\\");\\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\\n            for (const member of members.defaultedMembers) {\\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\\n                enumName,\\n                memberName: member.id.name\\n              });\\n            }\\n            node.members = members.booleanMembers;\\n            this.expect(8);\\n            return this.finishNode(node, \\\"EnumBooleanBody\\\");\\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\\n            for (const member of members.defaultedMembers) {\\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\\n                enumName,\\n                memberName: member.id.name\\n              });\\n            }\\n            node.members = members.numberMembers;\\n            this.expect(8);\\n            return this.finishNode(node, \\\"EnumNumberBody\\\");\\n          } else {\\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\\n              enumName\\n            });\\n            return empty();\\n          }\\n        }\\n    }\\n  }\\n  flowParseEnumDeclaration(node) {\\n    const id = this.parseIdentifier();\\n    node.id = id;\\n    node.body = this.flowEnumBody(this.startNode(), id);\\n    return this.finishNode(node, \\\"EnumDeclaration\\\");\\n  }\\n  isLookaheadToken_lt() {\\n    const next = this.nextTokenStart();\\n    if (this.input.charCodeAt(next) === 60) {\\n      const afterNext = this.input.charCodeAt(next + 1);\\n      return afterNext !== 60 && afterNext !== 61;\\n    }\\n    return false;\\n  }\\n  maybeUnwrapTypeCastExpression(node) {\\n    return node.type === \\\"TypeCastExpression\\\" ? node.expression : node;\\n  }\\n};\\nconst entities = {\\n  __proto__: null,\\n  quot: \\\"\\\\u0022\\\",\\n  amp: \\\"&\\\",\\n  apos: \\\"\\\\u0027\\\",\\n  lt: \\\"<\\\",\\n  gt: \\\">\\\",\\n  nbsp: \\\"\\\\u00A0\\\",\\n  iexcl: \\\"\\\\u00A1\\\",\\n  cent: \\\"\\\\u00A2\\\",\\n  pound: \\\"\\\\u00A3\\\",\\n  curren: \\\"\\\\u00A4\\\",\\n  yen: \\\"\\\\u00A5\\\",\\n  brvbar: \\\"\\\\u00A6\\\",\\n  sect: \\\"\\\\u00A7\\\",\\n  uml: \\\"\\\\u00A8\\\",\\n  copy: \\\"\\\\u00A9\\\",\\n  ordf: \\\"\\\\u00AA\\\",\\n  laquo: \\\"\\\\u00AB\\\",\\n  not: \\\"\\\\u00AC\\\",\\n  shy: \\\"\\\\u00AD\\\",\\n  reg: \\\"\\\\u00AE\\\",\\n  macr: \\\"\\\\u00AF\\\",\\n  deg: \\\"\\\\u00B0\\\",\\n  plusmn: \\\"\\\\u00B1\\\",\\n  sup2: \\\"\\\\u00B2\\\",\\n  sup3: \\\"\\\\u00B3\\\",\\n  acute: \\\"\\\\u00B4\\\",\\n  micro: \\\"\\\\u00B5\\\",\\n  para: \\\"\\\\u00B6\\\",\\n  middot: \\\"\\\\u00B7\\\",\\n  cedil: \\\"\\\\u00B8\\\",\\n  sup1: \\\"\\\\u00B9\\\",\\n  ordm: \\\"\\\\u00BA\\\",\\n  raquo: \\\"\\\\u00BB\\\",\\n  frac14: \\\"\\\\u00BC\\\",\\n  frac12: \\\"\\\\u00BD\\\",\\n  frac34: \\\"\\\\u00BE\\\",\\n  iquest: \\\"\\\\u00BF\\\",\\n  Agrave: \\\"\\\\u00C0\\\",\\n  Aacute: \\\"\\\\u00C1\\\",\\n  Acirc: \\\"\\\\u00C2\\\",\\n  Atilde: \\\"\\\\u00C3\\\",\\n  Auml: \\\"\\\\u00C4\\\",\\n  Aring: \\\"\\\\u00C5\\\",\\n  AElig: \\\"\\\\u00C6\\\",\\n  Ccedil: \\\"\\\\u00C7\\\",\\n  Egrave: \\\"\\\\u00C8\\\",\\n  Eacute: \\\"\\\\u00C9\\\",\\n  Ecirc: \\\"\\\\u00CA\\\",\\n  Euml: \\\"\\\\u00CB\\\",\\n  Igrave: \\\"\\\\u00CC\\\",\\n  Iacute: \\\"\\\\u00CD\\\",\\n  Icirc: \\\"\\\\u00CE\\\",\\n  Iuml: \\\"\\\\u00CF\\\",\\n  ETH: \\\"\\\\u00D0\\\",\\n  Ntilde: \\\"\\\\u00D1\\\",\\n  Ograve: \\\"\\\\u00D2\\\",\\n  Oacute: \\\"\\\\u00D3\\\",\\n  Ocirc: \\\"\\\\u00D4\\\",\\n  Otilde: \\\"\\\\u00D5\\\",\\n  Ouml: \\\"\\\\u00D6\\\",\\n  times: \\\"\\\\u00D7\\\",\\n  Oslash: \\\"\\\\u00D8\\\",\\n  Ugrave: \\\"\\\\u00D9\\\",\\n  Uacute: \\\"\\\\u00DA\\\",\\n  Ucirc: \\\"\\\\u00DB\\\",\\n  Uuml: \\\"\\\\u00DC\\\",\\n  Yacute: \\\"\\\\u00DD\\\",\\n  THORN: \\\"\\\\u00DE\\\",\\n  szlig: \\\"\\\\u00DF\\\",\\n  agrave: \\\"\\\\u00E0\\\",\\n  aacute: \\\"\\\\u00E1\\\",\\n  acirc: \\\"\\\\u00E2\\\",\\n  atilde: \\\"\\\\u00E3\\\",\\n  auml: \\\"\\\\u00E4\\\",\\n  aring: \\\"\\\\u00E5\\\",\\n  aelig: \\\"\\\\u00E6\\\",\\n  ccedil: \\\"\\\\u00E7\\\",\\n  egrave: \\\"\\\\u00E8\\\",\\n  eacute: \\\"\\\\u00E9\\\",\\n  ecirc: \\\"\\\\u00EA\\\",\\n  euml: \\\"\\\\u00EB\\\",\\n  igrave: \\\"\\\\u00EC\\\",\\n  iacute: \\\"\\\\u00ED\\\",\\n  icirc: \\\"\\\\u00EE\\\",\\n  iuml: \\\"\\\\u00EF\\\",\\n  eth: \\\"\\\\u00F0\\\",\\n  ntilde: \\\"\\\\u00F1\\\",\\n  ograve: \\\"\\\\u00F2\\\",\\n  oacute: \\\"\\\\u00F3\\\",\\n  ocirc: \\\"\\\\u00F4\\\",\\n  otilde: \\\"\\\\u00F5\\\",\\n  ouml: \\\"\\\\u00F6\\\",\\n  divide: \\\"\\\\u00F7\\\",\\n  oslash: \\\"\\\\u00F8\\\",\\n  ugrave: \\\"\\\\u00F9\\\",\\n  uacute: \\\"\\\\u00FA\\\",\\n  ucirc: \\\"\\\\u00FB\\\",\\n  uuml: \\\"\\\\u00FC\\\",\\n  yacute: \\\"\\\\u00FD\\\",\\n  thorn: \\\"\\\\u00FE\\\",\\n  yuml: \\\"\\\\u00FF\\\",\\n  OElig: \\\"\\\\u0152\\\",\\n  oelig: \\\"\\\\u0153\\\",\\n  Scaron: \\\"\\\\u0160\\\",\\n  scaron: \\\"\\\\u0161\\\",\\n  Yuml: \\\"\\\\u0178\\\",\\n  fnof: \\\"\\\\u0192\\\",\\n  circ: \\\"\\\\u02C6\\\",\\n  tilde: \\\"\\\\u02DC\\\",\\n  Alpha: \\\"\\\\u0391\\\",\\n  Beta: \\\"\\\\u0392\\\",\\n  Gamma: \\\"\\\\u0393\\\",\\n  Delta: \\\"\\\\u0394\\\",\\n  Epsilon: \\\"\\\\u0395\\\",\\n  Zeta: \\\"\\\\u0396\\\",\\n  Eta: \\\"\\\\u0397\\\",\\n  Theta: \\\"\\\\u0398\\\",\\n  Iota: \\\"\\\\u0399\\\",\\n  Kappa: \\\"\\\\u039A\\\",\\n  Lambda: \\\"\\\\u039B\\\",\\n  Mu: \\\"\\\\u039C\\\",\\n  Nu: \\\"\\\\u039D\\\",\\n  Xi: \\\"\\\\u039E\\\",\\n  Omicron: \\\"\\\\u039F\\\",\\n  Pi: \\\"\\\\u03A0\\\",\\n  Rho: \\\"\\\\u03A1\\\",\\n  Sigma: \\\"\\\\u03A3\\\",\\n  Tau: \\\"\\\\u03A4\\\",\\n  Upsilon: \\\"\\\\u03A5\\\",\\n  Phi: \\\"\\\\u03A6\\\",\\n  Chi: \\\"\\\\u03A7\\\",\\n  Psi: \\\"\\\\u03A8\\\",\\n  Omega: \\\"\\\\u03A9\\\",\\n  alpha: \\\"\\\\u03B1\\\",\\n  beta: \\\"\\\\u03B2\\\",\\n  gamma: \\\"\\\\u03B3\\\",\\n  delta: \\\"\\\\u03B4\\\",\\n  epsilon: \\\"\\\\u03B5\\\",\\n  zeta: \\\"\\\\u03B6\\\",\\n  eta: \\\"\\\\u03B7\\\",\\n  theta: \\\"\\\\u03B8\\\",\\n  iota: \\\"\\\\u03B9\\\",\\n  kappa: \\\"\\\\u03BA\\\",\\n  lambda: \\\"\\\\u03BB\\\",\\n  mu: \\\"\\\\u03BC\\\",\\n  nu: \\\"\\\\u03BD\\\",\\n  xi: \\\"\\\\u03BE\\\",\\n  omicron: \\\"\\\\u03BF\\\",\\n  pi: \\\"\\\\u03C0\\\",\\n  rho: \\\"\\\\u03C1\\\",\\n  sigmaf: \\\"\\\\u03C2\\\",\\n  sigma: \\\"\\\\u03C3\\\",\\n  tau: \\\"\\\\u03C4\\\",\\n  upsilon: \\\"\\\\u03C5\\\",\\n  phi: \\\"\\\\u03C6\\\",\\n  chi: \\\"\\\\u03C7\\\",\\n  psi: \\\"\\\\u03C8\\\",\\n  omega: \\\"\\\\u03C9\\\",\\n  thetasym: \\\"\\\\u03D1\\\",\\n  upsih: \\\"\\\\u03D2\\\",\\n  piv: \\\"\\\\u03D6\\\",\\n  ensp: \\\"\\\\u2002\\\",\\n  emsp: \\\"\\\\u2003\\\",\\n  thinsp: \\\"\\\\u2009\\\",\\n  zwnj: \\\"\\\\u200C\\\",\\n  zwj: \\\"\\\\u200D\\\",\\n  lrm: \\\"\\\\u200E\\\",\\n  rlm: \\\"\\\\u200F\\\",\\n  ndash: \\\"\\\\u2013\\\",\\n  mdash: \\\"\\\\u2014\\\",\\n  lsquo: \\\"\\\\u2018\\\",\\n  rsquo: \\\"\\\\u2019\\\",\\n  sbquo: \\\"\\\\u201A\\\",\\n  ldquo: \\\"\\\\u201C\\\",\\n  rdquo: \\\"\\\\u201D\\\",\\n  bdquo: \\\"\\\\u201E\\\",\\n  dagger: \\\"\\\\u2020\\\",\\n  Dagger: \\\"\\\\u2021\\\",\\n  bull: \\\"\\\\u2022\\\",\\n  hellip: \\\"\\\\u2026\\\",\\n  permil: \\\"\\\\u2030\\\",\\n  prime: \\\"\\\\u2032\\\",\\n  Prime: \\\"\\\\u2033\\\",\\n  lsaquo: \\\"\\\\u2039\\\",\\n  rsaquo: \\\"\\\\u203A\\\",\\n  oline: \\\"\\\\u203E\\\",\\n  frasl: \\\"\\\\u2044\\\",\\n  euro: \\\"\\\\u20AC\\\",\\n  image: \\\"\\\\u2111\\\",\\n  weierp: \\\"\\\\u2118\\\",\\n  real: \\\"\\\\u211C\\\",\\n  trade: \\\"\\\\u2122\\\",\\n  alefsym: \\\"\\\\u2135\\\",\\n  larr: \\\"\\\\u2190\\\",\\n  uarr: \\\"\\\\u2191\\\",\\n  rarr: \\\"\\\\u2192\\\",\\n  darr: \\\"\\\\u2193\\\",\\n  harr: \\\"\\\\u2194\\\",\\n  crarr: \\\"\\\\u21B5\\\",\\n  lArr: \\\"\\\\u21D0\\\",\\n  uArr: \\\"\\\\u21D1\\\",\\n  rArr: \\\"\\\\u21D2\\\",\\n  dArr: \\\"\\\\u21D3\\\",\\n  hArr: \\\"\\\\u21D4\\\",\\n  forall: \\\"\\\\u2200\\\",\\n  part: \\\"\\\\u2202\\\",\\n  exist: \\\"\\\\u2203\\\",\\n  empty: \\\"\\\\u2205\\\",\\n  nabla: \\\"\\\\u2207\\\",\\n  isin: \\\"\\\\u2208\\\",\\n  notin: \\\"\\\\u2209\\\",\\n  ni: \\\"\\\\u220B\\\",\\n  prod: \\\"\\\\u220F\\\",\\n  sum: \\\"\\\\u2211\\\",\\n  minus: \\\"\\\\u2212\\\",\\n  lowast: \\\"\\\\u2217\\\",\\n  radic: \\\"\\\\u221A\\\",\\n  prop: \\\"\\\\u221D\\\",\\n  infin: \\\"\\\\u221E\\\",\\n  ang: \\\"\\\\u2220\\\",\\n  and: \\\"\\\\u2227\\\",\\n  or: \\\"\\\\u2228\\\",\\n  cap: \\\"\\\\u2229\\\",\\n  cup: \\\"\\\\u222A\\\",\\n  int: \\\"\\\\u222B\\\",\\n  there4: \\\"\\\\u2234\\\",\\n  sim: \\\"\\\\u223C\\\",\\n  cong: \\\"\\\\u2245\\\",\\n  asymp: \\\"\\\\u2248\\\",\\n  ne: \\\"\\\\u2260\\\",\\n  equiv: \\\"\\\\u2261\\\",\\n  le: \\\"\\\\u2264\\\",\\n  ge: \\\"\\\\u2265\\\",\\n  sub: \\\"\\\\u2282\\\",\\n  sup: \\\"\\\\u2283\\\",\\n  nsub: \\\"\\\\u2284\\\",\\n  sube: \\\"\\\\u2286\\\",\\n  supe: \\\"\\\\u2287\\\",\\n  oplus: \\\"\\\\u2295\\\",\\n  otimes: \\\"\\\\u2297\\\",\\n  perp: \\\"\\\\u22A5\\\",\\n  sdot: \\\"\\\\u22C5\\\",\\n  lceil: \\\"\\\\u2308\\\",\\n  rceil: \\\"\\\\u2309\\\",\\n  lfloor: \\\"\\\\u230A\\\",\\n  rfloor: \\\"\\\\u230B\\\",\\n  lang: \\\"\\\\u2329\\\",\\n  rang: \\\"\\\\u232A\\\",\\n  loz: \\\"\\\\u25CA\\\",\\n  spades: \\\"\\\\u2660\\\",\\n  clubs: \\\"\\\\u2663\\\",\\n  hearts: \\\"\\\\u2665\\\",\\n  diams: \\\"\\\\u2666\\\"\\n};\\nconst JsxErrors = ParseErrorEnum`jsx`({\\n  AttributeIsEmpty: \\\"JSX attributes must only be assigned a non-empty expression.\\\",\\n  MissingClosingTagElement: ({\\n    openingTagName\\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\\n  MissingClosingTagFragment: \\\"Expected corresponding JSX closing tag for <>.\\\",\\n  UnexpectedSequenceExpression: \\\"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\\\",\\n  UnexpectedToken: ({\\n    unexpected,\\n    HTMLEntity\\n  }) => `Unexpected token \\\\`${unexpected}\\\\`. Did you mean \\\\`${HTMLEntity}\\\\` or \\\\`{'${unexpected}'}\\\\`?`,\\n  UnsupportedJsxValue: \\\"JSX value should be either an expression or a quoted JSX text.\\\",\\n  UnterminatedJsxContent: \\\"Unterminated JSX contents.\\\",\\n  UnwrappedAdjacentJSXElements: \\\"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\\\"\\n});\\nfunction isFragment(object) {\\n  return object ? object.type === \\\"JSXOpeningFragment\\\" || object.type === \\\"JSXClosingFragment\\\" : false;\\n}\\nfunction getQualifiedJSXName(object) {\\n  if (object.type === \\\"JSXIdentifier\\\") {\\n    return object.name;\\n  }\\n  if (object.type === \\\"JSXNamespacedName\\\") {\\n    return object.namespace.name + \\\":\\\" + object.name.name;\\n  }\\n  if (object.type === \\\"JSXMemberExpression\\\") {\\n    return getQualifiedJSXName(object.object) + \\\".\\\" + getQualifiedJSXName(object.property);\\n  }\\n  throw new Error(\\\"Node had unexpected type: \\\" + object.type);\\n}\\nvar jsx = superClass => class JSXParserMixin extends superClass {\\n  jsxReadToken() {\\n    let out = \\\"\\\";\\n    let chunkStart = this.state.pos;\\n    for (;;) {\\n      if (this.state.pos >= this.length) {\\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\\n      }\\n      const ch = this.input.charCodeAt(this.state.pos);\\n      switch (ch) {\\n        case 60:\\n        case 123:\\n          if (this.state.pos === this.state.start) {\\n            if (ch === 60 && this.state.canStartJSXElement) {\\n              ++this.state.pos;\\n              this.finishToken(142);\\n            } else {\\n              super.getTokenFromCode(ch);\\n            }\\n            return;\\n          }\\n          out += this.input.slice(chunkStart, this.state.pos);\\n          this.finishToken(141, out);\\n          return;\\n        case 38:\\n          out += this.input.slice(chunkStart, this.state.pos);\\n          out += this.jsxReadEntity();\\n          chunkStart = this.state.pos;\\n          break;\\n        case 62:\\n        case 125:\\n        default:\\n          if (isNewLine(ch)) {\\n            out += this.input.slice(chunkStart, this.state.pos);\\n            out += this.jsxReadNewLine(true);\\n            chunkStart = this.state.pos;\\n          } else {\\n            ++this.state.pos;\\n          }\\n      }\\n    }\\n  }\\n  jsxReadNewLine(normalizeCRLF) {\\n    const ch = this.input.charCodeAt(this.state.pos);\\n    let out;\\n    ++this.state.pos;\\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\\n      ++this.state.pos;\\n      out = normalizeCRLF ? \\\"\\\\n\\\" : \\\"\\\\r\\\\n\\\";\\n    } else {\\n      out = String.fromCharCode(ch);\\n    }\\n    ++this.state.curLine;\\n    this.state.lineStart = this.state.pos;\\n    return out;\\n  }\\n  jsxReadString(quote) {\\n    let out = \\\"\\\";\\n    let chunkStart = ++this.state.pos;\\n    for (;;) {\\n      if (this.state.pos >= this.length) {\\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\\n      }\\n      const ch = this.input.charCodeAt(this.state.pos);\\n      if (ch === quote) break;\\n      if (ch === 38) {\\n        out += this.input.slice(chunkStart, this.state.pos);\\n        out += this.jsxReadEntity();\\n        chunkStart = this.state.pos;\\n      } else if (isNewLine(ch)) {\\n        out += this.input.slice(chunkStart, this.state.pos);\\n        out += this.jsxReadNewLine(false);\\n        chunkStart = this.state.pos;\\n      } else {\\n        ++this.state.pos;\\n      }\\n    }\\n    out += this.input.slice(chunkStart, this.state.pos++);\\n    this.finishToken(133, out);\\n  }\\n  jsxReadEntity() {\\n    const startPos = ++this.state.pos;\\n    if (this.codePointAtPos(this.state.pos) === 35) {\\n      ++this.state.pos;\\n      let radix = 10;\\n      if (this.codePointAtPos(this.state.pos) === 120) {\\n        radix = 16;\\n        ++this.state.pos;\\n      }\\n      const codePoint = this.readInt(radix, undefined, false, \\\"bail\\\");\\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\\n        ++this.state.pos;\\n        return String.fromCodePoint(codePoint);\\n      }\\n    } else {\\n      let count = 0;\\n      let semi = false;\\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\\n        ++this.state.pos;\\n      }\\n      if (semi) {\\n        const desc = this.input.slice(startPos, this.state.pos);\\n        const entity = entities[desc];\\n        ++this.state.pos;\\n        if (entity) {\\n          return entity;\\n        }\\n      }\\n    }\\n    this.state.pos = startPos;\\n    return \\\"&\\\";\\n  }\\n  jsxReadWord() {\\n    let ch;\\n    const start = this.state.pos;\\n    do {\\n      ch = this.input.charCodeAt(++this.state.pos);\\n    } while (isIdentifierChar(ch) || ch === 45);\\n    this.finishToken(140, this.input.slice(start, this.state.pos));\\n  }\\n  jsxParseIdentifier() {\\n    const node = this.startNode();\\n    if (this.match(140)) {\\n      node.name = this.state.value;\\n    } else if (tokenIsKeyword(this.state.type)) {\\n      node.name = tokenLabelName(this.state.type);\\n    } else {\\n      this.unexpected();\\n    }\\n    this.next();\\n    return this.finishNode(node, \\\"JSXIdentifier\\\");\\n  }\\n  jsxParseNamespacedName() {\\n    const startLoc = this.state.startLoc;\\n    const name = this.jsxParseIdentifier();\\n    if (!this.eat(14)) return name;\\n    const node = this.startNodeAt(startLoc);\\n    node.namespace = name;\\n    node.name = this.jsxParseIdentifier();\\n    return this.finishNode(node, \\\"JSXNamespacedName\\\");\\n  }\\n  jsxParseElementName() {\\n    const startLoc = this.state.startLoc;\\n    let node = this.jsxParseNamespacedName();\\n    if (node.type === \\\"JSXNamespacedName\\\") {\\n      return node;\\n    }\\n    while (this.eat(16)) {\\n      const newNode = this.startNodeAt(startLoc);\\n      newNode.object = node;\\n      newNode.property = this.jsxParseIdentifier();\\n      node = this.finishNode(newNode, \\\"JSXMemberExpression\\\");\\n    }\\n    return node;\\n  }\\n  jsxParseAttributeValue() {\\n    let node;\\n    switch (this.state.type) {\\n      case 5:\\n        node = this.startNode();\\n        this.setContext(types.brace);\\n        this.next();\\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\\n        if (node.expression.type === \\\"JSXEmptyExpression\\\") {\\n          this.raise(JsxErrors.AttributeIsEmpty, node);\\n        }\\n        return node;\\n      case 142:\\n      case 133:\\n        return this.parseExprAtom();\\n      default:\\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\\n    }\\n  }\\n  jsxParseEmptyExpression() {\\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\\n    return this.finishNodeAt(node, \\\"JSXEmptyExpression\\\", this.state.startLoc);\\n  }\\n  jsxParseSpreadChild(node) {\\n    this.next();\\n    node.expression = this.parseExpression();\\n    this.setContext(types.j_expr);\\n    this.state.canStartJSXElement = true;\\n    this.expect(8);\\n    return this.finishNode(node, \\\"JSXSpreadChild\\\");\\n  }\\n  jsxParseExpressionContainer(node, previousContext) {\\n    if (this.match(8)) {\\n      node.expression = this.jsxParseEmptyExpression();\\n    } else {\\n      const expression = this.parseExpression();\\n      node.expression = expression;\\n    }\\n    this.setContext(previousContext);\\n    this.state.canStartJSXElement = true;\\n    this.expect(8);\\n    return this.finishNode(node, \\\"JSXExpressionContainer\\\");\\n  }\\n  jsxParseAttribute() {\\n    const node = this.startNode();\\n    if (this.match(5)) {\\n      this.setContext(types.brace);\\n      this.next();\\n      this.expect(21);\\n      node.argument = this.parseMaybeAssignAllowIn();\\n      this.setContext(types.j_oTag);\\n      this.state.canStartJSXElement = true;\\n      this.expect(8);\\n      return this.finishNode(node, \\\"JSXSpreadAttribute\\\");\\n    }\\n    node.name = this.jsxParseNamespacedName();\\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\\n    return this.finishNode(node, \\\"JSXAttribute\\\");\\n  }\\n  jsxParseOpeningElementAt(startLoc) {\\n    const node = this.startNodeAt(startLoc);\\n    if (this.eat(143)) {\\n      return this.finishNode(node, \\\"JSXOpeningFragment\\\");\\n    }\\n    node.name = this.jsxParseElementName();\\n    return this.jsxParseOpeningElementAfterName(node);\\n  }\\n  jsxParseOpeningElementAfterName(node) {\\n    const attributes = [];\\n    while (!this.match(56) && !this.match(143)) {\\n      attributes.push(this.jsxParseAttribute());\\n    }\\n    node.attributes = attributes;\\n    node.selfClosing = this.eat(56);\\n    this.expect(143);\\n    return this.finishNode(node, \\\"JSXOpeningElement\\\");\\n  }\\n  jsxParseClosingElementAt(startLoc) {\\n    const node = this.startNodeAt(startLoc);\\n    if (this.eat(143)) {\\n      return this.finishNode(node, \\\"JSXClosingFragment\\\");\\n    }\\n    node.name = this.jsxParseElementName();\\n    this.expect(143);\\n    return this.finishNode(node, \\\"JSXClosingElement\\\");\\n  }\\n  jsxParseElementAt(startLoc) {\\n    const node = this.startNodeAt(startLoc);\\n    const children = [];\\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\\n    let closingElement = null;\\n    if (!openingElement.selfClosing) {\\n      contents: for (;;) {\\n        switch (this.state.type) {\\n          case 142:\\n            startLoc = this.state.startLoc;\\n            this.next();\\n            if (this.eat(56)) {\\n              closingElement = this.jsxParseClosingElementAt(startLoc);\\n              break contents;\\n            }\\n            children.push(this.jsxParseElementAt(startLoc));\\n            break;\\n          case 141:\\n            children.push(this.parseExprAtom());\\n            break;\\n          case 5:\\n            {\\n              const node = this.startNode();\\n              this.setContext(types.brace);\\n              this.next();\\n              if (this.match(21)) {\\n                children.push(this.jsxParseSpreadChild(node));\\n              } else {\\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\\n              }\\n              break;\\n            }\\n          default:\\n            this.unexpected();\\n        }\\n      }\\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\\n          openingTagName: getQualifiedJSXName(openingElement.name)\\n        });\\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\\n            openingTagName: getQualifiedJSXName(openingElement.name)\\n          });\\n        }\\n      }\\n    }\\n    if (isFragment(openingElement)) {\\n      node.openingFragment = openingElement;\\n      node.closingFragment = closingElement;\\n    } else {\\n      node.openingElement = openingElement;\\n      node.closingElement = closingElement;\\n    }\\n    node.children = children;\\n    if (this.match(47)) {\\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\\n    }\\n    return isFragment(openingElement) ? this.finishNode(node, \\\"JSXFragment\\\") : this.finishNode(node, \\\"JSXElement\\\");\\n  }\\n  jsxParseElement() {\\n    const startLoc = this.state.startLoc;\\n    this.next();\\n    return this.jsxParseElementAt(startLoc);\\n  }\\n  setContext(newContext) {\\n    const {\\n      context\\n    } = this.state;\\n    context[context.length - 1] = newContext;\\n  }\\n  parseExprAtom(refExpressionErrors) {\\n    if (this.match(141)) {\\n      return this.parseLiteral(this.state.value, \\\"JSXText\\\");\\n    } else if (this.match(142)) {\\n      return this.jsxParseElement();\\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\\n      this.replaceToken(142);\\n      return this.jsxParseElement();\\n    } else {\\n      return super.parseExprAtom(refExpressionErrors);\\n    }\\n  }\\n  skipSpace() {\\n    const curContext = this.curContext();\\n    if (!curContext.preserveSpace) super.skipSpace();\\n  }\\n  getTokenFromCode(code) {\\n    const context = this.curContext();\\n    if (context === types.j_expr) {\\n      this.jsxReadToken();\\n      return;\\n    }\\n    if (context === types.j_oTag || context === types.j_cTag) {\\n      if (isIdentifierStart(code)) {\\n        this.jsxReadWord();\\n        return;\\n      }\\n      if (code === 62) {\\n        ++this.state.pos;\\n        this.finishToken(143);\\n        return;\\n      }\\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\\n        this.jsxReadString(code);\\n        return;\\n      }\\n    }\\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\\n      ++this.state.pos;\\n      this.finishToken(142);\\n      return;\\n    }\\n    super.getTokenFromCode(code);\\n  }\\n  updateContext(prevType) {\\n    const {\\n      context,\\n      type\\n    } = this.state;\\n    if (type === 56 && prevType === 142) {\\n      context.splice(-2, 2, types.j_cTag);\\n      this.state.canStartJSXElement = false;\\n    } else if (type === 142) {\\n      context.push(types.j_oTag);\\n    } else if (type === 143) {\\n      const out = context[context.length - 1];\\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\\n        context.pop();\\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\\n      } else {\\n        this.setContext(types.j_expr);\\n        this.state.canStartJSXElement = true;\\n      }\\n    } else {\\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\\n    }\\n  }\\n};\\nclass TypeScriptScope extends Scope {\\n  constructor(...args) {\\n    super(...args);\\n    this.tsNames = new Map();\\n  }\\n}\\nclass TypeScriptScopeHandler extends ScopeHandler {\\n  constructor(...args) {\\n    super(...args);\\n    this.importsStack = [];\\n  }\\n  createScope(flags) {\\n    this.importsStack.push(new Set());\\n    return new TypeScriptScope(flags);\\n  }\\n  enter(flags) {\\n    if (flags == 256) {\\n      this.importsStack.push(new Set());\\n    }\\n    super.enter(flags);\\n  }\\n  exit() {\\n    const flags = super.exit();\\n    if (flags == 256) {\\n      this.importsStack.pop();\\n    }\\n    return flags;\\n  }\\n  hasImport(name, allowShadow) {\\n    const len = this.importsStack.length;\\n    if (this.importsStack[len - 1].has(name)) {\\n      return true;\\n    }\\n    if (!allowShadow && len > 1) {\\n      for (let i = 0; i < len - 1; i++) {\\n        if (this.importsStack[i].has(name)) return true;\\n      }\\n    }\\n    return false;\\n  }\\n  declareName(name, bindingType, loc) {\\n    if (bindingType & 4096) {\\n      if (this.hasImport(name, true)) {\\n        this.parser.raise(Errors.VarRedeclaration, loc, {\\n          identifierName: name\\n        });\\n      }\\n      this.importsStack[this.importsStack.length - 1].add(name);\\n      return;\\n    }\\n    const scope = this.currentScope();\\n    let type = scope.tsNames.get(name) || 0;\\n    if (bindingType & 1024) {\\n      this.maybeExportDefined(scope, name);\\n      scope.tsNames.set(name, type | 16);\\n      return;\\n    }\\n    super.declareName(name, bindingType, loc);\\n    if (bindingType & 2) {\\n      if (!(bindingType & 1)) {\\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\\n        this.maybeExportDefined(scope, name);\\n      }\\n      type = type | 1;\\n    }\\n    if (bindingType & 256) {\\n      type = type | 2;\\n    }\\n    if (bindingType & 512) {\\n      type = type | 4;\\n    }\\n    if (bindingType & 128) {\\n      type = type | 8;\\n    }\\n    if (type) scope.tsNames.set(name, type);\\n  }\\n  isRedeclaredInScope(scope, name, bindingType) {\\n    const type = scope.tsNames.get(name);\\n    if ((type & 2) > 0) {\\n      if (bindingType & 256) {\\n        const isConst = !!(bindingType & 512);\\n        const wasConst = (type & 4) > 0;\\n        return isConst !== wasConst;\\n      }\\n      return true;\\n    }\\n    if (bindingType & 128 && (type & 8) > 0) {\\n      if (scope.names.get(name) & 2) {\\n        return !!(bindingType & 1);\\n      } else {\\n        return false;\\n      }\\n    }\\n    if (bindingType & 2 && (type & 1) > 0) {\\n      return true;\\n    }\\n    return super.isRedeclaredInScope(scope, name, bindingType);\\n  }\\n  checkLocalExport(id) {\\n    const {\\n      name\\n    } = id;\\n    if (this.hasImport(name)) return;\\n    const len = this.scopeStack.length;\\n    for (let i = len - 1; i >= 0; i--) {\\n      const scope = this.scopeStack[i];\\n      const type = scope.tsNames.get(name);\\n      if ((type & 1) > 0 || (type & 16) > 0) {\\n        return;\\n      }\\n    }\\n    super.checkLocalExport(id);\\n  }\\n}\\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\\nconst unwrapParenthesizedExpression = node => {\\n  return node.type === \\\"ParenthesizedExpression\\\" ? unwrapParenthesizedExpression(node.expression) : node;\\n};\\nclass LValParser extends NodeUtils {\\n  toAssignable(node, isLHS = false) {\\n    var _node$extra, _node$extra3;\\n    let parenthesized = undefined;\\n    if (node.type === \\\"ParenthesizedExpression\\\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\\n      parenthesized = unwrapParenthesizedExpression(node);\\n      if (isLHS) {\\n        if (parenthesized.type === \\\"Identifier\\\") {\\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\\n        } else if (parenthesized.type !== \\\"MemberExpression\\\" && !this.isOptionalMemberExpression(parenthesized)) {\\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\\n        }\\n      } else {\\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\\n      }\\n    }\\n    switch (node.type) {\\n      case \\\"Identifier\\\":\\n      case \\\"ObjectPattern\\\":\\n      case \\\"ArrayPattern\\\":\\n      case \\\"AssignmentPattern\\\":\\n      case \\\"RestElement\\\":\\n        break;\\n      case \\\"ObjectExpression\\\":\\n        node.type = \\\"ObjectPattern\\\";\\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\\n          var _node$extra2;\\n          const prop = node.properties[i];\\n          const isLast = i === last;\\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\\n          if (isLast && prop.type === \\\"RestElement\\\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\\n          }\\n        }\\n        break;\\n      case \\\"ObjectProperty\\\":\\n        {\\n          const {\\n            key,\\n            value\\n          } = node;\\n          if (this.isPrivateName(key)) {\\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\\n          }\\n          this.toAssignable(value, isLHS);\\n          break;\\n        }\\n      case \\\"SpreadElement\\\":\\n        {\\n          throw new Error(\\\"Internal @babel/parser error (this is a bug, please report it).\\\" + \\\" SpreadElement should be converted by .toAssignable's caller.\\\");\\n        }\\n      case \\\"ArrayExpression\\\":\\n        node.type = \\\"ArrayPattern\\\";\\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\\n        break;\\n      case \\\"AssignmentExpression\\\":\\n        if (node.operator !== \\\"=\\\") {\\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\\n        }\\n        node.type = \\\"AssignmentPattern\\\";\\n        delete node.operator;\\n        this.toAssignable(node.left, isLHS);\\n        break;\\n      case \\\"ParenthesizedExpression\\\":\\n        this.toAssignable(parenthesized, isLHS);\\n        break;\\n    }\\n  }\\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\\n    if (prop.type === \\\"ObjectMethod\\\") {\\n      this.raise(prop.kind === \\\"get\\\" || prop.kind === \\\"set\\\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\\n    } else if (prop.type === \\\"SpreadElement\\\") {\\n      prop.type = \\\"RestElement\\\";\\n      const arg = prop.argument;\\n      this.checkToRestConversion(arg, false);\\n      this.toAssignable(arg, isLHS);\\n      if (!isLast) {\\n        this.raise(Errors.RestTrailingComma, prop);\\n      }\\n    } else {\\n      this.toAssignable(prop, isLHS);\\n    }\\n  }\\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\\n    const end = exprList.length - 1;\\n    for (let i = 0; i <= end; i++) {\\n      const elt = exprList[i];\\n      if (!elt) continue;\\n      if (elt.type === \\\"SpreadElement\\\") {\\n        elt.type = \\\"RestElement\\\";\\n        const arg = elt.argument;\\n        this.checkToRestConversion(arg, true);\\n        this.toAssignable(arg, isLHS);\\n      } else {\\n        this.toAssignable(elt, isLHS);\\n      }\\n      if (elt.type === \\\"RestElement\\\") {\\n        if (i < end) {\\n          this.raise(Errors.RestTrailingComma, elt);\\n        } else if (trailingCommaLoc) {\\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\\n        }\\n      }\\n    }\\n  }\\n  isAssignable(node, isBinding) {\\n    switch (node.type) {\\n      case \\\"Identifier\\\":\\n      case \\\"ObjectPattern\\\":\\n      case \\\"ArrayPattern\\\":\\n      case \\\"AssignmentPattern\\\":\\n      case \\\"RestElement\\\":\\n        return true;\\n      case \\\"ObjectExpression\\\":\\n        {\\n          const last = node.properties.length - 1;\\n          return node.properties.every((prop, i) => {\\n            return prop.type !== \\\"ObjectMethod\\\" && (i === last || prop.type !== \\\"SpreadElement\\\") && this.isAssignable(prop);\\n          });\\n        }\\n      case \\\"ObjectProperty\\\":\\n        return this.isAssignable(node.value);\\n      case \\\"SpreadElement\\\":\\n        return this.isAssignable(node.argument);\\n      case \\\"ArrayExpression\\\":\\n        return node.elements.every(element => element === null || this.isAssignable(element));\\n      case \\\"AssignmentExpression\\\":\\n        return node.operator === \\\"=\\\";\\n      case \\\"ParenthesizedExpression\\\":\\n        return this.isAssignable(node.expression);\\n      case \\\"MemberExpression\\\":\\n      case \\\"OptionalMemberExpression\\\":\\n        return !isBinding;\\n      default:\\n        return false;\\n    }\\n  }\\n  toReferencedList(exprList, isParenthesizedExpr) {\\n    return exprList;\\n  }\\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\\n    this.toReferencedList(exprList, isParenthesizedExpr);\\n    for (const expr of exprList) {\\n      if ((expr == null ? void 0 : expr.type) === \\\"ArrayExpression\\\") {\\n        this.toReferencedListDeep(expr.elements);\\n      }\\n    }\\n  }\\n  parseSpread(refExpressionErrors) {\\n    const node = this.startNode();\\n    this.next();\\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\\n    return this.finishNode(node, \\\"SpreadElement\\\");\\n  }\\n  parseRestBinding() {\\n    const node = this.startNode();\\n    this.next();\\n    node.argument = this.parseBindingAtom();\\n    return this.finishNode(node, \\\"RestElement\\\");\\n  }\\n  parseBindingAtom() {\\n    switch (this.state.type) {\\n      case 0:\\n        {\\n          const node = this.startNode();\\n          this.next();\\n          node.elements = this.parseBindingList(3, 93, 1);\\n          return this.finishNode(node, \\\"ArrayPattern\\\");\\n        }\\n      case 5:\\n        return this.parseObjectLike(8, true);\\n    }\\n    return this.parseIdentifier();\\n  }\\n  parseBindingList(close, closeCharCode, flags) {\\n    const allowEmpty = flags & 1;\\n    const elts = [];\\n    let first = true;\\n    while (!this.eat(close)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        this.expect(12);\\n      }\\n      if (allowEmpty && this.match(12)) {\\n        elts.push(null);\\n      } else if (this.eat(close)) {\\n        break;\\n      } else if (this.match(21)) {\\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));\\n        if (!this.checkCommaAfterRest(closeCharCode)) {\\n          this.expect(close);\\n          break;\\n        }\\n      } else {\\n        const decorators = [];\\n        if (this.match(26) && this.hasPlugin(\\\"decorators\\\")) {\\n          this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\\n        }\\n        while (this.match(26)) {\\n          decorators.push(this.parseDecorator());\\n        }\\n        elts.push(this.parseAssignableListItem(flags, decorators));\\n      }\\n    }\\n    return elts;\\n  }\\n  parseBindingRestProperty(prop) {\\n    this.next();\\n    prop.argument = this.parseIdentifier();\\n    this.checkCommaAfterRest(125);\\n    return this.finishNode(prop, \\\"RestElement\\\");\\n  }\\n  parseBindingProperty() {\\n    const prop = this.startNode();\\n    const {\\n      type,\\n      startLoc\\n    } = this.state;\\n    if (type === 21) {\\n      return this.parseBindingRestProperty(prop);\\n    } else if (type === 138) {\\n      this.expectPlugin(\\\"destructuringPrivate\\\", startLoc);\\n      this.classScope.usePrivateName(this.state.value, startLoc);\\n      prop.key = this.parsePrivateName();\\n    } else {\\n      this.parsePropertyName(prop);\\n    }\\n    prop.method = false;\\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\\n  }\\n  parseAssignableListItem(flags, decorators) {\\n    const left = this.parseMaybeDefault();\\n    this.parseAssignableListItemTypes(left, flags);\\n    const elt = this.parseMaybeDefault(left.loc.start, left);\\n    if (decorators.length) {\\n      left.decorators = decorators;\\n    }\\n    return elt;\\n  }\\n  parseAssignableListItemTypes(param, flags) {\\n    return param;\\n  }\\n  parseMaybeDefault(startLoc, left) {\\n    var _startLoc, _left;\\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\\n    if (!this.eat(29)) return left;\\n    const node = this.startNodeAt(startLoc);\\n    node.left = left;\\n    node.right = this.parseMaybeAssignAllowIn();\\n    return this.finishNode(node, \\\"AssignmentPattern\\\");\\n  }\\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\\n    return getOwn$1({\\n      AssignmentPattern: \\\"left\\\",\\n      RestElement: \\\"argument\\\",\\n      ObjectProperty: \\\"value\\\",\\n      ParenthesizedExpression: \\\"expression\\\",\\n      ArrayPattern: \\\"elements\\\",\\n      ObjectPattern: \\\"properties\\\"\\n    }, type);\\n  }\\n  isOptionalMemberExpression(expression) {\\n    return expression.type === \\\"OptionalMemberExpression\\\";\\n  }\\n  checkLVal(expression, {\\n    in: ancestor,\\n    binding = 64,\\n    checkClashes = false,\\n    strictModeChanged = false,\\n    hasParenthesizedAncestor = false\\n  }) {\\n    var _expression$extra;\\n    const type = expression.type;\\n    if (this.isObjectMethod(expression)) return;\\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\\n    if (isOptionalMemberExpression || type === \\\"MemberExpression\\\") {\\n      if (isOptionalMemberExpression) {\\n        this.expectPlugin(\\\"optionalChainingAssign\\\", expression.loc.start);\\n        if (ancestor.type !== \\\"AssignmentExpression\\\") {\\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\\n            ancestor\\n          });\\n        }\\n      }\\n      if (binding !== 64) {\\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\\n      }\\n      return;\\n    }\\n    if (type === \\\"Identifier\\\") {\\n      this.checkIdentifier(expression, binding, strictModeChanged);\\n      const {\\n        name\\n      } = expression;\\n      if (checkClashes) {\\n        if (checkClashes.has(name)) {\\n          this.raise(Errors.ParamDupe, expression);\\n        } else {\\n          checkClashes.add(name);\\n        }\\n      }\\n      return;\\n    }\\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \\\"AssignmentExpression\\\", binding);\\n    if (validity === true) return;\\n    if (validity === false) {\\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\\n      this.raise(ParseErrorClass, expression, {\\n        ancestor\\n      });\\n      return;\\n    }\\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \\\"ParenthesizedExpression\\\"];\\n    const nextAncestor = type === \\\"ArrayPattern\\\" || type === \\\"ObjectPattern\\\" ? {\\n      type\\n    } : ancestor;\\n    for (const child of [].concat(expression[key])) {\\n      if (child) {\\n        this.checkLVal(child, {\\n          in: nextAncestor,\\n          binding,\\n          checkClashes,\\n          strictModeChanged,\\n          hasParenthesizedAncestor: isParenthesizedExpression\\n        });\\n      }\\n    }\\n  }\\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\\n      if (bindingType === 64) {\\n        this.raise(Errors.StrictEvalArguments, at, {\\n          referenceName: at.name\\n        });\\n      } else {\\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\\n          bindingName: at.name\\n        });\\n      }\\n    }\\n    if (bindingType & 8192 && at.name === \\\"let\\\") {\\n      this.raise(Errors.LetInLexicalBinding, at);\\n    }\\n    if (!(bindingType & 64)) {\\n      this.declareNameFromIdentifier(at, bindingType);\\n    }\\n  }\\n  declareNameFromIdentifier(identifier, binding) {\\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\\n  }\\n  checkToRestConversion(node, allowPattern) {\\n    switch (node.type) {\\n      case \\\"ParenthesizedExpression\\\":\\n        this.checkToRestConversion(node.expression, allowPattern);\\n        break;\\n      case \\\"Identifier\\\":\\n      case \\\"MemberExpression\\\":\\n        break;\\n      case \\\"ArrayExpression\\\":\\n      case \\\"ObjectExpression\\\":\\n        if (allowPattern) break;\\n      default:\\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\\n    }\\n  }\\n  checkCommaAfterRest(close) {\\n    if (!this.match(12)) {\\n      return false;\\n    }\\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\\n    return true;\\n  }\\n}\\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\\nfunction nonNull(x) {\\n  if (x == null) {\\n    throw new Error(`Unexpected ${x} value.`);\\n  }\\n  return x;\\n}\\nfunction assert(x) {\\n  if (!x) {\\n    throw new Error(\\\"Assert fail\\\");\\n  }\\n}\\nconst TSErrors = ParseErrorEnum`typescript`({\\n  AbstractMethodHasImplementation: ({\\n    methodName\\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\\n  AbstractPropertyHasInitializer: ({\\n    propertyName\\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\\n  AccesorCannotDeclareThisParameter: \\\"'get' and 'set' accessors cannot declare 'this' parameters.\\\",\\n  AccesorCannotHaveTypeParameters: \\\"An accessor cannot have type parameters.\\\",\\n  AccessorCannotBeOptional: \\\"An 'accessor' property cannot be declared optional.\\\",\\n  ClassMethodHasDeclare: \\\"Class methods cannot have the 'declare' modifier.\\\",\\n  ClassMethodHasReadonly: \\\"Class methods cannot have the 'readonly' modifier.\\\",\\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \\\"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\\\",\\n  ConstructorHasTypeParameters: \\\"Type parameters cannot appear on a constructor declaration.\\\",\\n  DeclareAccessor: ({\\n    kind\\n  }) => `'declare' is not allowed in ${kind}ters.`,\\n  DeclareClassFieldHasInitializer: \\\"Initializers are not allowed in ambient contexts.\\\",\\n  DeclareFunctionHasImplementation: \\\"An implementation cannot be declared in ambient contexts.\\\",\\n  DuplicateAccessibilityModifier: ({\\n    modifier\\n  }) => `Accessibility modifier already seen.`,\\n  DuplicateModifier: ({\\n    modifier\\n  }) => `Duplicate modifier: '${modifier}'.`,\\n  EmptyHeritageClauseType: ({\\n    token\\n  }) => `'${token}' list cannot be empty.`,\\n  EmptyTypeArguments: \\\"Type argument list cannot be empty.\\\",\\n  EmptyTypeParameters: \\\"Type parameter list cannot be empty.\\\",\\n  ExpectedAmbientAfterExportDeclare: \\\"'export declare' must be followed by an ambient declaration.\\\",\\n  ImportAliasHasImportType: \\\"An import alias can not use 'import type'.\\\",\\n  ImportReflectionHasImportType: \\\"An `import module` declaration can not use `type` modifier\\\",\\n  IncompatibleModifiers: ({\\n    modifiers\\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\\n  IndexSignatureHasAbstract: \\\"Index signatures cannot have the 'abstract' modifier.\\\",\\n  IndexSignatureHasAccessibility: ({\\n    modifier\\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\\n  IndexSignatureHasDeclare: \\\"Index signatures cannot have the 'declare' modifier.\\\",\\n  IndexSignatureHasOverride: \\\"'override' modifier cannot appear on an index signature.\\\",\\n  IndexSignatureHasStatic: \\\"Index signatures cannot have the 'static' modifier.\\\",\\n  InitializerNotAllowedInAmbientContext: \\\"Initializers are not allowed in ambient contexts.\\\",\\n  InvalidModifierOnTypeMember: ({\\n    modifier\\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\\n  InvalidModifierOnTypeParameter: ({\\n    modifier\\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\\n  InvalidModifierOnTypeParameterPositions: ({\\n    modifier\\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\\n  InvalidModifiersOrder: ({\\n    orderedModifiers\\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\\n  InvalidPropertyAccessAfterInstantiationExpression: \\\"Invalid property access after an instantiation expression. \\\" + \\\"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\\\",\\n  InvalidTupleMemberLabel: \\\"Tuple members must be labeled with a simple identifier.\\\",\\n  MissingInterfaceName: \\\"'interface' declarations must be followed by an identifier.\\\",\\n  NonAbstractClassHasAbstractMethod: \\\"Abstract methods can only appear within an abstract class.\\\",\\n  NonClassMethodPropertyHasAbstractModifer: \\\"'abstract' modifier can only appear on a class, method, or property declaration.\\\",\\n  OptionalTypeBeforeRequired: \\\"A required element cannot follow an optional element.\\\",\\n  OverrideNotInSubClass: \\\"This member cannot have an 'override' modifier because its containing class does not extend another class.\\\",\\n  PatternIsOptional: \\\"A binding pattern parameter cannot be optional in an implementation signature.\\\",\\n  PrivateElementHasAbstract: \\\"Private elements cannot have the 'abstract' modifier.\\\",\\n  PrivateElementHasAccessibility: ({\\n    modifier\\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\\n  ReadonlyForMethodSignature: \\\"'readonly' modifier can only appear on a property declaration or index signature.\\\",\\n  ReservedArrowTypeParam: \\\"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\\\",\\n  ReservedTypeAssertion: \\\"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\\\",\\n  SetAccesorCannotHaveOptionalParameter: \\\"A 'set' accessor cannot have an optional parameter.\\\",\\n  SetAccesorCannotHaveRestParameter: \\\"A 'set' accessor cannot have rest parameter.\\\",\\n  SetAccesorCannotHaveReturnType: \\\"A 'set' accessor cannot have a return type annotation.\\\",\\n  SingleTypeParameterWithoutTrailingComma: ({\\n    typeParameterName\\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\\n  StaticBlockCannotHaveModifier: \\\"Static class blocks cannot have any modifier.\\\",\\n  TupleOptionalAfterType: \\\"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\\\",\\n  TypeAnnotationAfterAssign: \\\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\\\",\\n  TypeImportCannotSpecifyDefaultAndNamed: \\\"A type-only import can specify a default import or named bindings, but not both.\\\",\\n  TypeModifierIsUsedInTypeExports: \\\"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\\\",\\n  TypeModifierIsUsedInTypeImports: \\\"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\\\",\\n  UnexpectedParameterModifier: \\\"A parameter property is only allowed in a constructor implementation.\\\",\\n  UnexpectedReadonly: \\\"'readonly' type modifier is only permitted on array and tuple literal types.\\\",\\n  UnexpectedTypeAnnotation: \\\"Did not expect a type annotation here.\\\",\\n  UnexpectedTypeCastInParameter: \\\"Unexpected type cast in parameter position.\\\",\\n  UnsupportedImportTypeArgument: \\\"Argument in a type import must be a string literal.\\\",\\n  UnsupportedParameterPropertyKind: \\\"A parameter property may not be declared using a binding pattern.\\\",\\n  UnsupportedSignatureParameterKind: ({\\n    type\\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\\n});\\nfunction keywordTypeFromName(value) {\\n  switch (value) {\\n    case \\\"any\\\":\\n      return \\\"TSAnyKeyword\\\";\\n    case \\\"boolean\\\":\\n      return \\\"TSBooleanKeyword\\\";\\n    case \\\"bigint\\\":\\n      return \\\"TSBigIntKeyword\\\";\\n    case \\\"never\\\":\\n      return \\\"TSNeverKeyword\\\";\\n    case \\\"number\\\":\\n      return \\\"TSNumberKeyword\\\";\\n    case \\\"object\\\":\\n      return \\\"TSObjectKeyword\\\";\\n    case \\\"string\\\":\\n      return \\\"TSStringKeyword\\\";\\n    case \\\"symbol\\\":\\n      return \\\"TSSymbolKeyword\\\";\\n    case \\\"undefined\\\":\\n      return \\\"TSUndefinedKeyword\\\";\\n    case \\\"unknown\\\":\\n      return \\\"TSUnknownKeyword\\\";\\n    default:\\n      return undefined;\\n  }\\n}\\nfunction tsIsAccessModifier(modifier) {\\n  return modifier === \\\"private\\\" || modifier === \\\"public\\\" || modifier === \\\"protected\\\";\\n}\\nfunction tsIsVarianceAnnotations(modifier) {\\n  return modifier === \\\"in\\\" || modifier === \\\"out\\\";\\n}\\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\\n  constructor(...args) {\\n    super(...args);\\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\\n      allowedModifiers: [\\\"in\\\", \\\"out\\\"],\\n      disallowedModifiers: [\\\"const\\\", \\\"public\\\", \\\"private\\\", \\\"protected\\\", \\\"readonly\\\", \\\"declare\\\", \\\"abstract\\\", \\\"override\\\"],\\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\\n    });\\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\\n      allowedModifiers: [\\\"const\\\"],\\n      disallowedModifiers: [\\\"in\\\", \\\"out\\\"],\\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\\n    });\\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\\n      allowedModifiers: [\\\"in\\\", \\\"out\\\", \\\"const\\\"],\\n      disallowedModifiers: [\\\"public\\\", \\\"private\\\", \\\"protected\\\", \\\"readonly\\\", \\\"declare\\\", \\\"abstract\\\", \\\"override\\\"],\\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\\n    });\\n  }\\n  getScopeHandler() {\\n    return TypeScriptScopeHandler;\\n  }\\n  tsIsIdentifier() {\\n    return tokenIsIdentifier(this.state.type);\\n  }\\n  tsTokenCanFollowModifier() {\\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\\n  }\\n  tsNextTokenCanFollowModifier() {\\n    this.next();\\n    return this.tsTokenCanFollowModifier();\\n  }\\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\\n      return undefined;\\n    }\\n    const modifier = this.state.value;\\n    if (allowedModifiers.indexOf(modifier) !== -1) {\\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\\n        return undefined;\\n      }\\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\\n        return modifier;\\n      }\\n    }\\n    return undefined;\\n  }\\n  tsParseModifiers({\\n    allowedModifiers,\\n    disallowedModifiers,\\n    stopOnStartOfClassStaticBlock,\\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\\n  }, modified) {\\n    const enforceOrder = (loc, modifier, before, after) => {\\n      if (modifier === before && modified[after]) {\\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\\n          orderedModifiers: [before, after]\\n        });\\n      }\\n    };\\n    const incompatible = (loc, modifier, mod1, mod2) => {\\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\\n          modifiers: [mod1, mod2]\\n        });\\n      }\\n    };\\n    for (;;) {\\n      const {\\n        startLoc\\n      } = this.state;\\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\\n      if (!modifier) break;\\n      if (tsIsAccessModifier(modifier)) {\\n        if (modified.accessibility) {\\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\\n            modifier\\n          });\\n        } else {\\n          enforceOrder(startLoc, modifier, modifier, \\\"override\\\");\\n          enforceOrder(startLoc, modifier, modifier, \\\"static\\\");\\n          enforceOrder(startLoc, modifier, modifier, \\\"readonly\\\");\\n          modified.accessibility = modifier;\\n        }\\n      } else if (tsIsVarianceAnnotations(modifier)) {\\n        if (modified[modifier]) {\\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\\n            modifier\\n          });\\n        }\\n        modified[modifier] = true;\\n        enforceOrder(startLoc, modifier, \\\"in\\\", \\\"out\\\");\\n      } else {\\n        if (Object.hasOwnProperty.call(modified, modifier)) {\\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\\n            modifier\\n          });\\n        } else {\\n          enforceOrder(startLoc, modifier, \\\"static\\\", \\\"readonly\\\");\\n          enforceOrder(startLoc, modifier, \\\"static\\\", \\\"override\\\");\\n          enforceOrder(startLoc, modifier, \\\"override\\\", \\\"readonly\\\");\\n          enforceOrder(startLoc, modifier, \\\"abstract\\\", \\\"override\\\");\\n          incompatible(startLoc, modifier, \\\"declare\\\", \\\"override\\\");\\n          incompatible(startLoc, modifier, \\\"static\\\", \\\"abstract\\\");\\n        }\\n        modified[modifier] = true;\\n      }\\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\\n        this.raise(errorTemplate, startLoc, {\\n          modifier\\n        });\\n      }\\n    }\\n  }\\n  tsIsListTerminator(kind) {\\n    switch (kind) {\\n      case \\\"EnumMembers\\\":\\n      case \\\"TypeMembers\\\":\\n        return this.match(8);\\n      case \\\"HeritageClauseElement\\\":\\n        return this.match(5);\\n      case \\\"TupleElementTypes\\\":\\n        return this.match(3);\\n      case \\\"TypeParametersOrArguments\\\":\\n        return this.match(48);\\n    }\\n  }\\n  tsParseList(kind, parseElement) {\\n    const result = [];\\n    while (!this.tsIsListTerminator(kind)) {\\n      result.push(parseElement());\\n    }\\n    return result;\\n  }\\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\\n  }\\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\\n    const result = [];\\n    let trailingCommaPos = -1;\\n    for (;;) {\\n      if (this.tsIsListTerminator(kind)) {\\n        break;\\n      }\\n      trailingCommaPos = -1;\\n      const element = parseElement();\\n      if (element == null) {\\n        return undefined;\\n      }\\n      result.push(element);\\n      if (this.eat(12)) {\\n        trailingCommaPos = this.state.lastTokStartLoc.index;\\n        continue;\\n      }\\n      if (this.tsIsListTerminator(kind)) {\\n        break;\\n      }\\n      if (expectSuccess) {\\n        this.expect(12);\\n      }\\n      return undefined;\\n    }\\n    if (refTrailingCommaPos) {\\n      refTrailingCommaPos.value = trailingCommaPos;\\n    }\\n    return result;\\n  }\\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\\n    if (!skipFirstToken) {\\n      if (bracket) {\\n        this.expect(0);\\n      } else {\\n        this.expect(47);\\n      }\\n    }\\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\\n    if (bracket) {\\n      this.expect(3);\\n    } else {\\n      this.expect(48);\\n    }\\n    return result;\\n  }\\n  tsParseImportType() {\\n    const node = this.startNode();\\n    this.expect(83);\\n    this.expect(10);\\n    if (!this.match(133)) {\\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\\n    }\\n    node.argument = super.parseExprAtom();\\n    this.expect(11);\\n    if (this.eat(16)) {\\n      node.qualifier = this.tsParseEntityName();\\n    }\\n    if (this.match(47)) {\\n      node.typeParameters = this.tsParseTypeArguments();\\n    }\\n    return this.finishNode(node, \\\"TSImportType\\\");\\n  }\\n  tsParseEntityName(allowReservedWords = true) {\\n    let entity = this.parseIdentifier(allowReservedWords);\\n    while (this.eat(16)) {\\n      const node = this.startNodeAtNode(entity);\\n      node.left = entity;\\n      node.right = this.parseIdentifier(allowReservedWords);\\n      entity = this.finishNode(node, \\\"TSQualifiedName\\\");\\n    }\\n    return entity;\\n  }\\n  tsParseTypeReference() {\\n    const node = this.startNode();\\n    node.typeName = this.tsParseEntityName();\\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\\n      node.typeParameters = this.tsParseTypeArguments();\\n    }\\n    return this.finishNode(node, \\\"TSTypeReference\\\");\\n  }\\n  tsParseThisTypePredicate(lhs) {\\n    this.next();\\n    const node = this.startNodeAtNode(lhs);\\n    node.parameterName = lhs;\\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\\n    node.asserts = false;\\n    return this.finishNode(node, \\\"TSTypePredicate\\\");\\n  }\\n  tsParseThisTypeNode() {\\n    const node = this.startNode();\\n    this.next();\\n    return this.finishNode(node, \\\"TSThisType\\\");\\n  }\\n  tsParseTypeQuery() {\\n    const node = this.startNode();\\n    this.expect(87);\\n    if (this.match(83)) {\\n      node.exprName = this.tsParseImportType();\\n    } else {\\n      node.exprName = this.tsParseEntityName();\\n    }\\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\\n      node.typeParameters = this.tsParseTypeArguments();\\n    }\\n    return this.finishNode(node, \\\"TSTypeQuery\\\");\\n  }\\n  tsParseTypeParameter(parseModifiers) {\\n    const node = this.startNode();\\n    parseModifiers(node);\\n    node.name = this.tsParseTypeParameterName();\\n    node.constraint = this.tsEatThenParseType(81);\\n    node.default = this.tsEatThenParseType(29);\\n    return this.finishNode(node, \\\"TSTypeParameter\\\");\\n  }\\n  tsTryParseTypeParameters(parseModifiers) {\\n    if (this.match(47)) {\\n      return this.tsParseTypeParameters(parseModifiers);\\n    }\\n  }\\n  tsParseTypeParameters(parseModifiers) {\\n    const node = this.startNode();\\n    if (this.match(47) || this.match(142)) {\\n      this.next();\\n    } else {\\n      this.unexpected();\\n    }\\n    const refTrailingCommaPos = {\\n      value: -1\\n    };\\n    node.params = this.tsParseBracketedList(\\\"TypeParametersOrArguments\\\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\\n    if (node.params.length === 0) {\\n      this.raise(TSErrors.EmptyTypeParameters, node);\\n    }\\n    if (refTrailingCommaPos.value !== -1) {\\n      this.addExtra(node, \\\"trailingComma\\\", refTrailingCommaPos.value);\\n    }\\n    return this.finishNode(node, \\\"TSTypeParameterDeclaration\\\");\\n  }\\n  tsFillSignature(returnToken, signature) {\\n    const returnTokenRequired = returnToken === 19;\\n    const paramsKey = \\\"parameters\\\";\\n    const returnTypeKey = \\\"typeAnnotation\\\";\\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\\n    this.expect(10);\\n    signature[paramsKey] = this.tsParseBindingListForSignature();\\n    if (returnTokenRequired) {\\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\\n    } else if (this.match(returnToken)) {\\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\\n    }\\n  }\\n  tsParseBindingListForSignature() {\\n    const list = super.parseBindingList(11, 41, 2);\\n    for (const pattern of list) {\\n      const {\\n        type\\n      } = pattern;\\n      if (type === \\\"AssignmentPattern\\\" || type === \\\"TSParameterProperty\\\") {\\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\\n          type\\n        });\\n      }\\n    }\\n    return list;\\n  }\\n  tsParseTypeMemberSemicolon() {\\n    if (!this.eat(12) && !this.isLineTerminator()) {\\n      this.expect(13);\\n    }\\n  }\\n  tsParseSignatureMember(kind, node) {\\n    this.tsFillSignature(14, node);\\n    this.tsParseTypeMemberSemicolon();\\n    return this.finishNode(node, kind);\\n  }\\n  tsIsUnambiguouslyIndexSignature() {\\n    this.next();\\n    if (tokenIsIdentifier(this.state.type)) {\\n      this.next();\\n      return this.match(14);\\n    }\\n    return false;\\n  }\\n  tsTryParseIndexSignature(node) {\\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\\n      return;\\n    }\\n    this.expect(0);\\n    const id = this.parseIdentifier();\\n    id.typeAnnotation = this.tsParseTypeAnnotation();\\n    this.resetEndLocation(id);\\n    this.expect(3);\\n    node.parameters = [id];\\n    const type = this.tsTryParseTypeAnnotation();\\n    if (type) node.typeAnnotation = type;\\n    this.tsParseTypeMemberSemicolon();\\n    return this.finishNode(node, \\\"TSIndexSignature\\\");\\n  }\\n  tsParsePropertyOrMethodSignature(node, readonly) {\\n    if (this.eat(17)) node.optional = true;\\n    const nodeAny = node;\\n    if (this.match(10) || this.match(47)) {\\n      if (readonly) {\\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\\n      }\\n      const method = nodeAny;\\n      if (method.kind && this.match(47)) {\\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());\\n      }\\n      this.tsFillSignature(14, method);\\n      this.tsParseTypeMemberSemicolon();\\n      const paramsKey = \\\"parameters\\\";\\n      const returnTypeKey = \\\"typeAnnotation\\\";\\n      if (method.kind === \\\"get\\\") {\\n        if (method[paramsKey].length > 0) {\\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\\n          if (this.isThisParam(method[paramsKey][0])) {\\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\\n          }\\n        }\\n      } else if (method.kind === \\\"set\\\") {\\n        if (method[paramsKey].length !== 1) {\\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\\n        } else {\\n          const firstParameter = method[paramsKey][0];\\n          if (this.isThisParam(firstParameter)) {\\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\\n          }\\n          if (firstParameter.type === \\\"Identifier\\\" && firstParameter.optional) {\\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());\\n          }\\n          if (firstParameter.type === \\\"RestElement\\\") {\\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());\\n          }\\n        }\\n        if (method[returnTypeKey]) {\\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);\\n        }\\n      } else {\\n        method.kind = \\\"method\\\";\\n      }\\n      return this.finishNode(method, \\\"TSMethodSignature\\\");\\n    } else {\\n      const property = nodeAny;\\n      if (readonly) property.readonly = true;\\n      const type = this.tsTryParseTypeAnnotation();\\n      if (type) property.typeAnnotation = type;\\n      this.tsParseTypeMemberSemicolon();\\n      return this.finishNode(property, \\\"TSPropertySignature\\\");\\n    }\\n  }\\n  tsParseTypeMember() {\\n    const node = this.startNode();\\n    if (this.match(10) || this.match(47)) {\\n      return this.tsParseSignatureMember(\\\"TSCallSignatureDeclaration\\\", node);\\n    }\\n    if (this.match(77)) {\\n      const id = this.startNode();\\n      this.next();\\n      if (this.match(10) || this.match(47)) {\\n        return this.tsParseSignatureMember(\\\"TSConstructSignatureDeclaration\\\", node);\\n      } else {\\n        node.key = this.createIdentifier(id, \\\"new\\\");\\n        return this.tsParsePropertyOrMethodSignature(node, false);\\n      }\\n    }\\n    this.tsParseModifiers({\\n      allowedModifiers: [\\\"readonly\\\"],\\n      disallowedModifiers: [\\\"declare\\\", \\\"abstract\\\", \\\"private\\\", \\\"protected\\\", \\\"public\\\", \\\"static\\\", \\\"override\\\"]\\n    }, node);\\n    const idx = this.tsTryParseIndexSignature(node);\\n    if (idx) {\\n      return idx;\\n    }\\n    super.parsePropertyName(node);\\n    if (!node.computed && node.key.type === \\\"Identifier\\\" && (node.key.name === \\\"get\\\" || node.key.name === \\\"set\\\") && this.tsTokenCanFollowModifier()) {\\n      node.kind = node.key.name;\\n      super.parsePropertyName(node);\\n    }\\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\\n  }\\n  tsParseTypeLiteral() {\\n    const node = this.startNode();\\n    node.members = this.tsParseObjectTypeMembers();\\n    return this.finishNode(node, \\\"TSTypeLiteral\\\");\\n  }\\n  tsParseObjectTypeMembers() {\\n    this.expect(5);\\n    const members = this.tsParseList(\\\"TypeMembers\\\", this.tsParseTypeMember.bind(this));\\n    this.expect(8);\\n    return members;\\n  }\\n  tsIsStartOfMappedType() {\\n    this.next();\\n    if (this.eat(53)) {\\n      return this.isContextual(122);\\n    }\\n    if (this.isContextual(122)) {\\n      this.next();\\n    }\\n    if (!this.match(0)) {\\n      return false;\\n    }\\n    this.next();\\n    if (!this.tsIsIdentifier()) {\\n      return false;\\n    }\\n    this.next();\\n    return this.match(58);\\n  }\\n  tsParseMappedTypeParameter() {\\n    const node = this.startNode();\\n    node.name = this.tsParseTypeParameterName();\\n    node.constraint = this.tsExpectThenParseType(58);\\n    return this.finishNode(node, \\\"TSTypeParameter\\\");\\n  }\\n  tsParseMappedType() {\\n    const node = this.startNode();\\n    this.expect(5);\\n    if (this.match(53)) {\\n      node.readonly = this.state.value;\\n      this.next();\\n      this.expectContextual(122);\\n    } else if (this.eatContextual(122)) {\\n      node.readonly = true;\\n    }\\n    this.expect(0);\\n    node.typeParameter = this.tsParseMappedTypeParameter();\\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\\n    this.expect(3);\\n    if (this.match(53)) {\\n      node.optional = this.state.value;\\n      this.next();\\n      this.expect(17);\\n    } else if (this.eat(17)) {\\n      node.optional = true;\\n    }\\n    node.typeAnnotation = this.tsTryParseType();\\n    this.semicolon();\\n    this.expect(8);\\n    return this.finishNode(node, \\\"TSMappedType\\\");\\n  }\\n  tsParseTupleType() {\\n    const node = this.startNode();\\n    node.elementTypes = this.tsParseBracketedList(\\\"TupleElementTypes\\\", this.tsParseTupleElementType.bind(this), true, false);\\n    let seenOptionalElement = false;\\n    node.elementTypes.forEach(elementNode => {\\n      const {\\n        type\\n      } = elementNode;\\n      if (seenOptionalElement && type !== \\\"TSRestType\\\" && type !== \\\"TSOptionalType\\\" && !(type === \\\"TSNamedTupleMember\\\" && elementNode.optional)) {\\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\\n      }\\n      seenOptionalElement || (seenOptionalElement = type === \\\"TSNamedTupleMember\\\" && elementNode.optional || type === \\\"TSOptionalType\\\");\\n    });\\n    return this.finishNode(node, \\\"TSTupleType\\\");\\n  }\\n  tsParseTupleElementType() {\\n    const {\\n      startLoc\\n    } = this.state;\\n    const rest = this.eat(21);\\n    let labeled;\\n    let label;\\n    let optional;\\n    let type;\\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\\n    if (chAfterWord === 58) {\\n      labeled = true;\\n      optional = false;\\n      label = this.parseIdentifier(true);\\n      this.expect(14);\\n      type = this.tsParseType();\\n    } else if (chAfterWord === 63) {\\n      optional = true;\\n      const startLoc = this.state.startLoc;\\n      const wordName = this.state.value;\\n      const typeOrLabel = this.tsParseNonArrayType();\\n      if (this.lookaheadCharCode() === 58) {\\n        labeled = true;\\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\\n        this.expect(17);\\n        this.expect(14);\\n        type = this.tsParseType();\\n      } else {\\n        labeled = false;\\n        type = typeOrLabel;\\n        this.expect(17);\\n      }\\n    } else {\\n      type = this.tsParseType();\\n      optional = this.eat(17);\\n      labeled = this.eat(14);\\n    }\\n    if (labeled) {\\n      let labeledNode;\\n      if (label) {\\n        labeledNode = this.startNodeAtNode(label);\\n        labeledNode.optional = optional;\\n        labeledNode.label = label;\\n        labeledNode.elementType = type;\\n        if (this.eat(17)) {\\n          labeledNode.optional = true;\\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\\n        }\\n      } else {\\n        labeledNode = this.startNodeAtNode(type);\\n        labeledNode.optional = optional;\\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\\n        labeledNode.label = type;\\n        labeledNode.elementType = this.tsParseType();\\n      }\\n      type = this.finishNode(labeledNode, \\\"TSNamedTupleMember\\\");\\n    } else if (optional) {\\n      const optionalTypeNode = this.startNodeAtNode(type);\\n      optionalTypeNode.typeAnnotation = type;\\n      type = this.finishNode(optionalTypeNode, \\\"TSOptionalType\\\");\\n    }\\n    if (rest) {\\n      const restNode = this.startNodeAt(startLoc);\\n      restNode.typeAnnotation = type;\\n      type = this.finishNode(restNode, \\\"TSRestType\\\");\\n    }\\n    return type;\\n  }\\n  tsParseParenthesizedType() {\\n    const node = this.startNode();\\n    this.expect(10);\\n    node.typeAnnotation = this.tsParseType();\\n    this.expect(11);\\n    return this.finishNode(node, \\\"TSParenthesizedType\\\");\\n  }\\n  tsParseFunctionOrConstructorType(type, abstract) {\\n    const node = this.startNode();\\n    if (type === \\\"TSConstructorType\\\") {\\n      node.abstract = !!abstract;\\n      if (abstract) this.next();\\n      this.next();\\n    }\\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\\n    return this.finishNode(node, type);\\n  }\\n  tsParseLiteralTypeNode() {\\n    const node = this.startNode();\\n    switch (this.state.type) {\\n      case 134:\\n      case 135:\\n      case 133:\\n      case 85:\\n      case 86:\\n        node.literal = super.parseExprAtom();\\n        break;\\n      default:\\n        this.unexpected();\\n    }\\n    return this.finishNode(node, \\\"TSLiteralType\\\");\\n  }\\n  tsParseTemplateLiteralType() {\\n    const node = this.startNode();\\n    node.literal = super.parseTemplate(false);\\n    return this.finishNode(node, \\\"TSLiteralType\\\");\\n  }\\n  parseTemplateSubstitution() {\\n    if (this.state.inType) return this.tsParseType();\\n    return super.parseTemplateSubstitution();\\n  }\\n  tsParseThisTypeOrThisTypePredicate() {\\n    const thisKeyword = this.tsParseThisTypeNode();\\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\\n      return this.tsParseThisTypePredicate(thisKeyword);\\n    } else {\\n      return thisKeyword;\\n    }\\n  }\\n  tsParseNonArrayType() {\\n    switch (this.state.type) {\\n      case 133:\\n      case 134:\\n      case 135:\\n      case 85:\\n      case 86:\\n        return this.tsParseLiteralTypeNode();\\n      case 53:\\n        if (this.state.value === \\\"-\\\") {\\n          const node = this.startNode();\\n          const nextToken = this.lookahead();\\n          if (nextToken.type !== 134 && nextToken.type !== 135) {\\n            this.unexpected();\\n          }\\n          node.literal = this.parseMaybeUnary();\\n          return this.finishNode(node, \\\"TSLiteralType\\\");\\n        }\\n        break;\\n      case 78:\\n        return this.tsParseThisTypeOrThisTypePredicate();\\n      case 87:\\n        return this.tsParseTypeQuery();\\n      case 83:\\n        return this.tsParseImportType();\\n      case 5:\\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\\n      case 0:\\n        return this.tsParseTupleType();\\n      case 10:\\n        return this.tsParseParenthesizedType();\\n      case 25:\\n      case 24:\\n        return this.tsParseTemplateLiteralType();\\n      default:\\n        {\\n          const {\\n            type\\n          } = this.state;\\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\\n            const nodeType = type === 88 ? \\\"TSVoidKeyword\\\" : type === 84 ? \\\"TSNullKeyword\\\" : keywordTypeFromName(this.state.value);\\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\\n              const node = this.startNode();\\n              this.next();\\n              return this.finishNode(node, nodeType);\\n            }\\n            return this.tsParseTypeReference();\\n          }\\n        }\\n    }\\n    this.unexpected();\\n  }\\n  tsParseArrayTypeOrHigher() {\\n    let type = this.tsParseNonArrayType();\\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\\n      if (this.match(3)) {\\n        const node = this.startNodeAtNode(type);\\n        node.elementType = type;\\n        this.expect(3);\\n        type = this.finishNode(node, \\\"TSArrayType\\\");\\n      } else {\\n        const node = this.startNodeAtNode(type);\\n        node.objectType = type;\\n        node.indexType = this.tsParseType();\\n        this.expect(3);\\n        type = this.finishNode(node, \\\"TSIndexedAccessType\\\");\\n      }\\n    }\\n    return type;\\n  }\\n  tsParseTypeOperator() {\\n    const node = this.startNode();\\n    const operator = this.state.value;\\n    this.next();\\n    node.operator = operator;\\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\\n    if (operator === \\\"readonly\\\") {\\n      this.tsCheckTypeAnnotationForReadOnly(node);\\n    }\\n    return this.finishNode(node, \\\"TSTypeOperator\\\");\\n  }\\n  tsCheckTypeAnnotationForReadOnly(node) {\\n    switch (node.typeAnnotation.type) {\\n      case \\\"TSTupleType\\\":\\n      case \\\"TSArrayType\\\":\\n        return;\\n      default:\\n        this.raise(TSErrors.UnexpectedReadonly, node);\\n    }\\n  }\\n  tsParseInferType() {\\n    const node = this.startNode();\\n    this.expectContextual(115);\\n    const typeParameter = this.startNode();\\n    typeParameter.name = this.tsParseTypeParameterName();\\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\\n    node.typeParameter = this.finishNode(typeParameter, \\\"TSTypeParameter\\\");\\n    return this.finishNode(node, \\\"TSInferType\\\");\\n  }\\n  tsParseConstraintForInferType() {\\n    if (this.eat(81)) {\\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\\n        return constraint;\\n      }\\n    }\\n  }\\n  tsParseTypeOperatorOrHigher() {\\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\\n  }\\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\\n    const node = this.startNode();\\n    const hasLeadingOperator = this.eat(operator);\\n    const types = [];\\n    do {\\n      types.push(parseConstituentType());\\n    } while (this.eat(operator));\\n    if (types.length === 1 && !hasLeadingOperator) {\\n      return types[0];\\n    }\\n    node.types = types;\\n    return this.finishNode(node, kind);\\n  }\\n  tsParseIntersectionTypeOrHigher() {\\n    return this.tsParseUnionOrIntersectionType(\\\"TSIntersectionType\\\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\\n  }\\n  tsParseUnionTypeOrHigher() {\\n    return this.tsParseUnionOrIntersectionType(\\\"TSUnionType\\\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\\n  }\\n  tsIsStartOfFunctionType() {\\n    if (this.match(47)) {\\n      return true;\\n    }\\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\\n  }\\n  tsSkipParameterStart() {\\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\\n      this.next();\\n      return true;\\n    }\\n    if (this.match(5)) {\\n      const {\\n        errors\\n      } = this.state;\\n      const previousErrorCount = errors.length;\\n      try {\\n        this.parseObjectLike(8, true);\\n        return errors.length === previousErrorCount;\\n      } catch (_unused) {\\n        return false;\\n      }\\n    }\\n    if (this.match(0)) {\\n      this.next();\\n      const {\\n        errors\\n      } = this.state;\\n      const previousErrorCount = errors.length;\\n      try {\\n        super.parseBindingList(3, 93, 1);\\n        return errors.length === previousErrorCount;\\n      } catch (_unused2) {\\n        return false;\\n      }\\n    }\\n    return false;\\n  }\\n  tsIsUnambiguouslyStartOfFunctionType() {\\n    this.next();\\n    if (this.match(11) || this.match(21)) {\\n      return true;\\n    }\\n    if (this.tsSkipParameterStart()) {\\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\\n        return true;\\n      }\\n      if (this.match(11)) {\\n        this.next();\\n        if (this.match(19)) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\\n    return this.tsInType(() => {\\n      const t = this.startNode();\\n      this.expect(returnToken);\\n      const node = this.startNode();\\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\\n      if (asserts && this.match(78)) {\\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\\n        if (thisTypePredicate.type === \\\"TSThisType\\\") {\\n          node.parameterName = thisTypePredicate;\\n          node.asserts = true;\\n          node.typeAnnotation = null;\\n          thisTypePredicate = this.finishNode(node, \\\"TSTypePredicate\\\");\\n        } else {\\n          this.resetStartLocationFromNode(thisTypePredicate, node);\\n          thisTypePredicate.asserts = true;\\n        }\\n        t.typeAnnotation = thisTypePredicate;\\n        return this.finishNode(t, \\\"TSTypeAnnotation\\\");\\n      }\\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\\n      if (!typePredicateVariable) {\\n        if (!asserts) {\\n          return this.tsParseTypeAnnotation(false, t);\\n        }\\n        node.parameterName = this.parseIdentifier();\\n        node.asserts = asserts;\\n        node.typeAnnotation = null;\\n        t.typeAnnotation = this.finishNode(node, \\\"TSTypePredicate\\\");\\n        return this.finishNode(t, \\\"TSTypeAnnotation\\\");\\n      }\\n      const type = this.tsParseTypeAnnotation(false);\\n      node.parameterName = typePredicateVariable;\\n      node.typeAnnotation = type;\\n      node.asserts = asserts;\\n      t.typeAnnotation = this.finishNode(node, \\\"TSTypePredicate\\\");\\n      return this.finishNode(t, \\\"TSTypeAnnotation\\\");\\n    });\\n  }\\n  tsTryParseTypeOrTypePredicateAnnotation() {\\n    if (this.match(14)) {\\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\\n    }\\n  }\\n  tsTryParseTypeAnnotation() {\\n    if (this.match(14)) {\\n      return this.tsParseTypeAnnotation();\\n    }\\n  }\\n  tsTryParseType() {\\n    return this.tsEatThenParseType(14);\\n  }\\n  tsParseTypePredicatePrefix() {\\n    const id = this.parseIdentifier();\\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\\n      this.next();\\n      return id;\\n    }\\n  }\\n  tsParseTypePredicateAsserts() {\\n    if (this.state.type !== 109) {\\n      return false;\\n    }\\n    const containsEsc = this.state.containsEsc;\\n    this.next();\\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\\n      return false;\\n    }\\n    if (containsEsc) {\\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\\n        reservedWord: \\\"asserts\\\"\\n      });\\n    }\\n    return true;\\n  }\\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\\n    this.tsInType(() => {\\n      if (eatColon) this.expect(14);\\n      t.typeAnnotation = this.tsParseType();\\n    });\\n    return this.finishNode(t, \\\"TSTypeAnnotation\\\");\\n  }\\n  tsParseType() {\\n    assert(this.state.inType);\\n    const type = this.tsParseNonConditionalType();\\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\\n      return type;\\n    }\\n    const node = this.startNodeAtNode(type);\\n    node.checkType = type;\\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\\n    this.expect(17);\\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\\n    this.expect(14);\\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\\n    return this.finishNode(node, \\\"TSConditionalType\\\");\\n  }\\n  isAbstractConstructorSignature() {\\n    return this.isContextual(124) && this.lookahead().type === 77;\\n  }\\n  tsParseNonConditionalType() {\\n    if (this.tsIsStartOfFunctionType()) {\\n      return this.tsParseFunctionOrConstructorType(\\\"TSFunctionType\\\");\\n    }\\n    if (this.match(77)) {\\n      return this.tsParseFunctionOrConstructorType(\\\"TSConstructorType\\\");\\n    } else if (this.isAbstractConstructorSignature()) {\\n      return this.tsParseFunctionOrConstructorType(\\\"TSConstructorType\\\", true);\\n    }\\n    return this.tsParseUnionTypeOrHigher();\\n  }\\n  tsParseTypeAssertion() {\\n    if (this.getPluginOption(\\\"typescript\\\", \\\"disallowAmbiguousJSXLike\\\")) {\\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\\n    }\\n    const node = this.startNode();\\n    node.typeAnnotation = this.tsInType(() => {\\n      this.next();\\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\\n    });\\n    this.expect(48);\\n    node.expression = this.parseMaybeUnary();\\n    return this.finishNode(node, \\\"TSTypeAssertion\\\");\\n  }\\n  tsParseHeritageClause(token) {\\n    const originalStartLoc = this.state.startLoc;\\n    const delimitedList = this.tsParseDelimitedList(\\\"HeritageClauseElement\\\", () => {\\n      const node = this.startNode();\\n      node.expression = this.tsParseEntityName();\\n      if (this.match(47)) {\\n        node.typeParameters = this.tsParseTypeArguments();\\n      }\\n      return this.finishNode(node, \\\"TSExpressionWithTypeArguments\\\");\\n    });\\n    if (!delimitedList.length) {\\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\\n        token\\n      });\\n    }\\n    return delimitedList;\\n  }\\n  tsParseInterfaceDeclaration(node, properties = {}) {\\n    if (this.hasFollowingLineBreak()) return null;\\n    this.expectContextual(129);\\n    if (properties.declare) node.declare = true;\\n    if (tokenIsIdentifier(this.state.type)) {\\n      node.id = this.parseIdentifier();\\n      this.checkIdentifier(node.id, 130);\\n    } else {\\n      node.id = null;\\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\\n    }\\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\\n    if (this.eat(81)) {\\n      node.extends = this.tsParseHeritageClause(\\\"extends\\\");\\n    }\\n    const body = this.startNode();\\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\\n    node.body = this.finishNode(body, \\\"TSInterfaceBody\\\");\\n    return this.finishNode(node, \\\"TSInterfaceDeclaration\\\");\\n  }\\n  tsParseTypeAliasDeclaration(node) {\\n    node.id = this.parseIdentifier();\\n    this.checkIdentifier(node.id, 2);\\n    node.typeAnnotation = this.tsInType(() => {\\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\\n      this.expect(29);\\n      if (this.isContextual(114) && this.lookahead().type !== 16) {\\n        const node = this.startNode();\\n        this.next();\\n        return this.finishNode(node, \\\"TSIntrinsicKeyword\\\");\\n      }\\n      return this.tsParseType();\\n    });\\n    this.semicolon();\\n    return this.finishNode(node, \\\"TSTypeAliasDeclaration\\\");\\n  }\\n  tsInNoContext(cb) {\\n    const oldContext = this.state.context;\\n    this.state.context = [oldContext[0]];\\n    try {\\n      return cb();\\n    } finally {\\n      this.state.context = oldContext;\\n    }\\n  }\\n  tsInType(cb) {\\n    const oldInType = this.state.inType;\\n    this.state.inType = true;\\n    try {\\n      return cb();\\n    } finally {\\n      this.state.inType = oldInType;\\n    }\\n  }\\n  tsInDisallowConditionalTypesContext(cb) {\\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\\n    this.state.inDisallowConditionalTypesContext = true;\\n    try {\\n      return cb();\\n    } finally {\\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\\n    }\\n  }\\n  tsInAllowConditionalTypesContext(cb) {\\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\\n    this.state.inDisallowConditionalTypesContext = false;\\n    try {\\n      return cb();\\n    } finally {\\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\\n    }\\n  }\\n  tsEatThenParseType(token) {\\n    if (this.match(token)) {\\n      return this.tsNextThenParseType();\\n    }\\n  }\\n  tsExpectThenParseType(token) {\\n    return this.tsInType(() => {\\n      this.expect(token);\\n      return this.tsParseType();\\n    });\\n  }\\n  tsNextThenParseType() {\\n    return this.tsInType(() => {\\n      this.next();\\n      return this.tsParseType();\\n    });\\n  }\\n  tsParseEnumMember() {\\n    const node = this.startNode();\\n    node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\\n    if (this.eat(29)) {\\n      node.initializer = super.parseMaybeAssignAllowIn();\\n    }\\n    return this.finishNode(node, \\\"TSEnumMember\\\");\\n  }\\n  tsParseEnumDeclaration(node, properties = {}) {\\n    if (properties.const) node.const = true;\\n    if (properties.declare) node.declare = true;\\n    this.expectContextual(126);\\n    node.id = this.parseIdentifier();\\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\\n    this.expect(5);\\n    node.members = this.tsParseDelimitedList(\\\"EnumMembers\\\", this.tsParseEnumMember.bind(this));\\n    this.expect(8);\\n    return this.finishNode(node, \\\"TSEnumDeclaration\\\");\\n  }\\n  tsParseModuleBlock() {\\n    const node = this.startNode();\\n    this.scope.enter(0);\\n    this.expect(5);\\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\\n    this.scope.exit();\\n    return this.finishNode(node, \\\"TSModuleBlock\\\");\\n  }\\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\\n    node.id = this.parseIdentifier();\\n    if (!nested) {\\n      this.checkIdentifier(node.id, 1024);\\n    }\\n    if (this.eat(16)) {\\n      const inner = this.startNode();\\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\\n      node.body = inner;\\n    } else {\\n      this.scope.enter(256);\\n      this.prodParam.enter(0);\\n      node.body = this.tsParseModuleBlock();\\n      this.prodParam.exit();\\n      this.scope.exit();\\n    }\\n    return this.finishNode(node, \\\"TSModuleDeclaration\\\");\\n  }\\n  tsParseAmbientExternalModuleDeclaration(node) {\\n    if (this.isContextual(112)) {\\n      node.global = true;\\n      node.id = this.parseIdentifier();\\n    } else if (this.match(133)) {\\n      node.id = super.parseStringLiteral(this.state.value);\\n    } else {\\n      this.unexpected();\\n    }\\n    if (this.match(5)) {\\n      this.scope.enter(256);\\n      this.prodParam.enter(0);\\n      node.body = this.tsParseModuleBlock();\\n      this.prodParam.exit();\\n      this.scope.exit();\\n    } else {\\n      this.semicolon();\\n    }\\n    return this.finishNode(node, \\\"TSModuleDeclaration\\\");\\n  }\\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\\n    node.isExport = isExport || false;\\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\\n    this.checkIdentifier(node.id, 4096);\\n    this.expect(29);\\n    const moduleReference = this.tsParseModuleReference();\\n    if (node.importKind === \\\"type\\\" && moduleReference.type !== \\\"TSExternalModuleReference\\\") {\\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\\n    }\\n    node.moduleReference = moduleReference;\\n    this.semicolon();\\n    return this.finishNode(node, \\\"TSImportEqualsDeclaration\\\");\\n  }\\n  tsIsExternalModuleReference() {\\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\\n  }\\n  tsParseModuleReference() {\\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\\n  }\\n  tsParseExternalModuleReference() {\\n    const node = this.startNode();\\n    this.expectContextual(119);\\n    this.expect(10);\\n    if (!this.match(133)) {\\n      this.unexpected();\\n    }\\n    node.expression = super.parseExprAtom();\\n    this.expect(11);\\n    this.sawUnambiguousESM = true;\\n    return this.finishNode(node, \\\"TSExternalModuleReference\\\");\\n  }\\n  tsLookAhead(f) {\\n    const state = this.state.clone();\\n    const res = f();\\n    this.state = state;\\n    return res;\\n  }\\n  tsTryParseAndCatch(f) {\\n    const result = this.tryParse(abort => f() || abort());\\n    if (result.aborted || !result.node) return;\\n    if (result.error) this.state = result.failState;\\n    return result.node;\\n  }\\n  tsTryParse(f) {\\n    const state = this.state.clone();\\n    const result = f();\\n    if (result !== undefined && result !== false) {\\n      return result;\\n    }\\n    this.state = state;\\n  }\\n  tsTryParseDeclare(nany) {\\n    if (this.isLineTerminator()) {\\n      return;\\n    }\\n    let startType = this.state.type;\\n    let kind;\\n    if (this.isContextual(100)) {\\n      startType = 74;\\n      kind = \\\"let\\\";\\n    }\\n    return this.tsInAmbientContext(() => {\\n      switch (startType) {\\n        case 68:\\n          nany.declare = true;\\n          return super.parseFunctionStatement(nany, false, false);\\n        case 80:\\n          nany.declare = true;\\n          return this.parseClass(nany, true, false);\\n        case 126:\\n          return this.tsParseEnumDeclaration(nany, {\\n            declare: true\\n          });\\n        case 112:\\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\\n        case 75:\\n        case 74:\\n          if (!this.match(75) || !this.isLookaheadContextual(\\\"enum\\\")) {\\n            nany.declare = true;\\n            return this.parseVarStatement(nany, kind || this.state.value, true);\\n          }\\n          this.expect(75);\\n          return this.tsParseEnumDeclaration(nany, {\\n            const: true,\\n            declare: true\\n          });\\n        case 129:\\n          {\\n            const result = this.tsParseInterfaceDeclaration(nany, {\\n              declare: true\\n            });\\n            if (result) return result;\\n          }\\n        default:\\n          if (tokenIsIdentifier(startType)) {\\n            return this.tsParseDeclaration(nany, this.state.value, true, null);\\n          }\\n      }\\n    });\\n  }\\n  tsTryParseExportDeclaration() {\\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\\n  }\\n  tsParseExpressionStatement(node, expr, decorators) {\\n    switch (expr.name) {\\n      case \\\"declare\\\":\\n        {\\n          const declaration = this.tsTryParseDeclare(node);\\n          if (declaration) {\\n            declaration.declare = true;\\n          }\\n          return declaration;\\n        }\\n      case \\\"global\\\":\\n        if (this.match(5)) {\\n          this.scope.enter(256);\\n          this.prodParam.enter(0);\\n          const mod = node;\\n          mod.global = true;\\n          mod.id = expr;\\n          mod.body = this.tsParseModuleBlock();\\n          this.scope.exit();\\n          this.prodParam.exit();\\n          return this.finishNode(mod, \\\"TSModuleDeclaration\\\");\\n        }\\n        break;\\n      default:\\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\\n    }\\n  }\\n  tsParseDeclaration(node, value, next, decorators) {\\n    switch (value) {\\n      case \\\"abstract\\\":\\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\\n          return this.tsParseAbstractDeclaration(node, decorators);\\n        }\\n        break;\\n      case \\\"module\\\":\\n        if (this.tsCheckLineTerminator(next)) {\\n          if (this.match(133)) {\\n            return this.tsParseAmbientExternalModuleDeclaration(node);\\n          } else if (tokenIsIdentifier(this.state.type)) {\\n            return this.tsParseModuleOrNamespaceDeclaration(node);\\n          }\\n        }\\n        break;\\n      case \\\"namespace\\\":\\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\\n          return this.tsParseModuleOrNamespaceDeclaration(node);\\n        }\\n        break;\\n      case \\\"type\\\":\\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\\n          return this.tsParseTypeAliasDeclaration(node);\\n        }\\n        break;\\n    }\\n  }\\n  tsCheckLineTerminator(next) {\\n    if (next) {\\n      if (this.hasFollowingLineBreak()) return false;\\n      this.next();\\n      return true;\\n    }\\n    return !this.isLineTerminator();\\n  }\\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\\n    if (!this.match(47)) return;\\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\\n    this.state.maybeInArrowParameters = true;\\n    const res = this.tsTryParseAndCatch(() => {\\n      const node = this.startNodeAt(startLoc);\\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\\n      super.parseFunctionParams(node);\\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\\n      this.expect(19);\\n      return node;\\n    });\\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\\n    if (!res) return;\\n    return super.parseArrowExpression(res, null, true);\\n  }\\n  tsParseTypeArgumentsInExpression() {\\n    if (this.reScan_lt() !== 47) return;\\n    return this.tsParseTypeArguments();\\n  }\\n  tsParseTypeArguments() {\\n    const node = this.startNode();\\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\\n      this.expect(47);\\n      return this.tsParseDelimitedList(\\\"TypeParametersOrArguments\\\", this.tsParseType.bind(this));\\n    }));\\n    if (node.params.length === 0) {\\n      this.raise(TSErrors.EmptyTypeArguments, node);\\n    } else if (!this.state.inType && this.curContext() === types.brace) {\\n      this.reScan_lt_gt();\\n    }\\n    this.expect(48);\\n    return this.finishNode(node, \\\"TSTypeParameterInstantiation\\\");\\n  }\\n  tsIsDeclarationStart() {\\n    return tokenIsTSDeclarationStart(this.state.type);\\n  }\\n  isExportDefaultSpecifier() {\\n    if (this.tsIsDeclarationStart()) return false;\\n    return super.isExportDefaultSpecifier();\\n  }\\n  parseAssignableListItem(flags, decorators) {\\n    const startLoc = this.state.startLoc;\\n    const modified = {};\\n    this.tsParseModifiers({\\n      allowedModifiers: [\\\"public\\\", \\\"private\\\", \\\"protected\\\", \\\"override\\\", \\\"readonly\\\"]\\n    }, modified);\\n    const accessibility = modified.accessibility;\\n    const override = modified.override;\\n    const readonly = modified.readonly;\\n    if (!(flags & 4) && (accessibility || readonly || override)) {\\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\\n    }\\n    const left = this.parseMaybeDefault();\\n    this.parseAssignableListItemTypes(left, flags);\\n    const elt = this.parseMaybeDefault(left.loc.start, left);\\n    if (accessibility || readonly || override) {\\n      const pp = this.startNodeAt(startLoc);\\n      if (decorators.length) {\\n        pp.decorators = decorators;\\n      }\\n      if (accessibility) pp.accessibility = accessibility;\\n      if (readonly) pp.readonly = readonly;\\n      if (override) pp.override = override;\\n      if (elt.type !== \\\"Identifier\\\" && elt.type !== \\\"AssignmentPattern\\\") {\\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\\n      }\\n      pp.parameter = elt;\\n      return this.finishNode(pp, \\\"TSParameterProperty\\\");\\n    }\\n    if (decorators.length) {\\n      left.decorators = decorators;\\n    }\\n    return elt;\\n  }\\n  isSimpleParameter(node) {\\n    return node.type === \\\"TSParameterProperty\\\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\\n  }\\n  tsDisallowOptionalPattern(node) {\\n    for (const param of node.params) {\\n      if (param.type !== \\\"Identifier\\\" && param.optional && !this.state.isAmbientContext) {\\n        this.raise(TSErrors.PatternIsOptional, param);\\n      }\\n    }\\n  }\\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\\n    this.tsDisallowOptionalPattern(node);\\n  }\\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\\n    if (this.match(14)) {\\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\\n    }\\n    const bodilessType = type === \\\"FunctionDeclaration\\\" ? \\\"TSDeclareFunction\\\" : type === \\\"ClassMethod\\\" || type === \\\"ClassPrivateMethod\\\" ? \\\"TSDeclareMethod\\\" : undefined;\\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\\n      return this.finishNode(node, bodilessType);\\n    }\\n    if (bodilessType === \\\"TSDeclareFunction\\\" && this.state.isAmbientContext) {\\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\\n      if (node.declare) {\\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\\n      }\\n    }\\n    this.tsDisallowOptionalPattern(node);\\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\\n  }\\n  registerFunctionStatementId(node) {\\n    if (!node.body && node.id) {\\n      this.checkIdentifier(node.id, 1024);\\n    } else {\\n      super.registerFunctionStatementId(node);\\n    }\\n  }\\n  tsCheckForInvalidTypeCasts(items) {\\n    items.forEach(node => {\\n      if ((node == null ? void 0 : node.type) === \\\"TSTypeCastExpression\\\") {\\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\\n      }\\n    });\\n  }\\n  toReferencedList(exprList, isInParens) {\\n    this.tsCheckForInvalidTypeCasts(exprList);\\n    return exprList;\\n  }\\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\\n    if (node.type === \\\"ArrayExpression\\\") {\\n      this.tsCheckForInvalidTypeCasts(node.elements);\\n    }\\n    return node;\\n  }\\n  parseSubscript(base, startLoc, noCalls, state) {\\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\\n      this.state.canStartJSXElement = false;\\n      this.next();\\n      const nonNullExpression = this.startNodeAt(startLoc);\\n      nonNullExpression.expression = base;\\n      return this.finishNode(nonNullExpression, \\\"TSNonNullExpression\\\");\\n    }\\n    let isOptionalCall = false;\\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\\n      if (noCalls) {\\n        state.stop = true;\\n        return base;\\n      }\\n      state.optionalChainMember = isOptionalCall = true;\\n      this.next();\\n    }\\n    if (this.match(47) || this.match(51)) {\\n      let missingParenErrorLoc;\\n      const result = this.tsTryParseAndCatch(() => {\\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\\n          if (asyncArrowFn) {\\n            return asyncArrowFn;\\n          }\\n        }\\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\\n        if (!typeArguments) return;\\n        if (isOptionalCall && !this.match(10)) {\\n          missingParenErrorLoc = this.state.curPosition();\\n          return;\\n        }\\n        if (tokenIsTemplate(this.state.type)) {\\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\\n          result.typeParameters = typeArguments;\\n          return result;\\n        }\\n        if (!noCalls && this.eat(10)) {\\n          const node = this.startNodeAt(startLoc);\\n          node.callee = base;\\n          node.arguments = this.parseCallExpressionArguments(11, false);\\n          this.tsCheckForInvalidTypeCasts(node.arguments);\\n          node.typeParameters = typeArguments;\\n          if (state.optionalChainMember) {\\n            node.optional = isOptionalCall;\\n          }\\n          return this.finishCallExpression(node, state.optionalChainMember);\\n        }\\n        const tokenType = this.state.type;\\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\\n          return;\\n        }\\n        const node = this.startNodeAt(startLoc);\\n        node.expression = base;\\n        node.typeParameters = typeArguments;\\n        return this.finishNode(node, \\\"TSInstantiationExpression\\\");\\n      });\\n      if (missingParenErrorLoc) {\\n        this.unexpected(missingParenErrorLoc, 10);\\n      }\\n      if (result) {\\n        if (result.type === \\\"TSInstantiationExpression\\\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\\n        }\\n        return result;\\n      }\\n    }\\n    return super.parseSubscript(base, startLoc, noCalls, state);\\n  }\\n  parseNewCallee(node) {\\n    var _callee$extra;\\n    super.parseNewCallee(node);\\n    const {\\n      callee\\n    } = node;\\n    if (callee.type === \\\"TSInstantiationExpression\\\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\\n      node.typeParameters = callee.typeParameters;\\n      node.callee = callee.expression;\\n    }\\n  }\\n  parseExprOp(left, leftStartLoc, minPrec) {\\n    let isSatisfies;\\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\\n      const node = this.startNodeAt(leftStartLoc);\\n      node.expression = left;\\n      node.typeAnnotation = this.tsInType(() => {\\n        this.next();\\n        if (this.match(75)) {\\n          if (isSatisfies) {\\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\\n              keyword: \\\"const\\\"\\n            });\\n          }\\n          return this.tsParseTypeReference();\\n        }\\n        return this.tsParseType();\\n      });\\n      this.finishNode(node, isSatisfies ? \\\"TSSatisfiesExpression\\\" : \\\"TSAsExpression\\\");\\n      this.reScan_lt_gt();\\n      return this.parseExprOp(node, leftStartLoc, minPrec);\\n    }\\n    return super.parseExprOp(left, leftStartLoc, minPrec);\\n  }\\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\\n    if (!this.state.isAmbientContext) {\\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\\n    }\\n  }\\n  checkImportReflection(node) {\\n    super.checkImportReflection(node);\\n    if (node.module && node.importKind !== \\\"value\\\") {\\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\\n    }\\n  }\\n  checkDuplicateExports() {}\\n  isPotentialImportPhase(isExport) {\\n    if (super.isPotentialImportPhase(isExport)) return true;\\n    if (this.isContextual(130)) {\\n      const ch = this.lookaheadCharCode();\\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\\n    }\\n    return !isExport && this.isContextual(87);\\n  }\\n  applyImportPhase(node, isExport, phase, loc) {\\n    super.applyImportPhase(node, isExport, phase, loc);\\n    if (isExport) {\\n      node.exportKind = phase === \\\"type\\\" ? \\\"type\\\" : \\\"value\\\";\\n    } else {\\n      node.importKind = phase === \\\"type\\\" || phase === \\\"typeof\\\" ? phase : \\\"value\\\";\\n    }\\n  }\\n  parseImport(node) {\\n    if (this.match(133)) {\\n      node.importKind = \\\"value\\\";\\n      return super.parseImport(node);\\n    }\\n    let importNode;\\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\\n      node.importKind = \\\"value\\\";\\n      return this.tsParseImportEqualsDeclaration(node);\\n    } else if (this.isContextual(130)) {\\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\\n      if (this.lookaheadCharCode() === 61) {\\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\\n      } else {\\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\\n      }\\n    } else {\\n      importNode = super.parseImport(node);\\n    }\\n    if (importNode.importKind === \\\"type\\\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \\\"ImportDefaultSpecifier\\\") {\\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\\n    }\\n    return importNode;\\n  }\\n  parseExport(node, decorators) {\\n    if (this.match(83)) {\\n      this.next();\\n      let maybeDefaultIdentifier = null;\\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\\n      } else {\\n        node.importKind = \\\"value\\\";\\n      }\\n      return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);\\n    } else if (this.eat(29)) {\\n      const assign = node;\\n      assign.expression = super.parseExpression();\\n      this.semicolon();\\n      this.sawUnambiguousESM = true;\\n      return this.finishNode(assign, \\\"TSExportAssignment\\\");\\n    } else if (this.eatContextual(93)) {\\n      const decl = node;\\n      this.expectContextual(128);\\n      decl.id = this.parseIdentifier();\\n      this.semicolon();\\n      return this.finishNode(decl, \\\"TSNamespaceExportDeclaration\\\");\\n    } else {\\n      return super.parseExport(node, decorators);\\n    }\\n  }\\n  isAbstractClass() {\\n    return this.isContextual(124) && this.lookahead().type === 80;\\n  }\\n  parseExportDefaultExpression() {\\n    if (this.isAbstractClass()) {\\n      const cls = this.startNode();\\n      this.next();\\n      cls.abstract = true;\\n      return this.parseClass(cls, true, true);\\n    }\\n    if (this.match(129)) {\\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\\n      if (result) return result;\\n    }\\n    return super.parseExportDefaultExpression();\\n  }\\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\\n    const {\\n      isAmbientContext\\n    } = this.state;\\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\\n    if (!isAmbientContext) return declaration;\\n    for (const {\\n      id,\\n      init\\n    } of declaration.declarations) {\\n      if (!init) continue;\\n      if (kind !== \\\"const\\\" || !!id.typeAnnotation) {\\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\\\"estree\\\"))) {\\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\\n      }\\n    }\\n    return declaration;\\n  }\\n  parseStatementContent(flags, decorators) {\\n    if (this.match(75) && this.isLookaheadContextual(\\\"enum\\\")) {\\n      const node = this.startNode();\\n      this.expect(75);\\n      return this.tsParseEnumDeclaration(node, {\\n        const: true\\n      });\\n    }\\n    if (this.isContextual(126)) {\\n      return this.tsParseEnumDeclaration(this.startNode());\\n    }\\n    if (this.isContextual(129)) {\\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\\n      if (result) return result;\\n    }\\n    return super.parseStatementContent(flags, decorators);\\n  }\\n  parseAccessModifier() {\\n    return this.tsParseModifier([\\\"public\\\", \\\"protected\\\", \\\"private\\\"]);\\n  }\\n  tsHasSomeModifiers(member, modifiers) {\\n    return modifiers.some(modifier => {\\n      if (tsIsAccessModifier(modifier)) {\\n        return member.accessibility === modifier;\\n      }\\n      return !!member[modifier];\\n    });\\n  }\\n  tsIsStartOfStaticBlocks() {\\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\\n  }\\n  parseClassMember(classBody, member, state) {\\n    const modifiers = [\\\"declare\\\", \\\"private\\\", \\\"public\\\", \\\"protected\\\", \\\"override\\\", \\\"abstract\\\", \\\"readonly\\\", \\\"static\\\"];\\n    this.tsParseModifiers({\\n      allowedModifiers: modifiers,\\n      disallowedModifiers: [\\\"in\\\", \\\"out\\\"],\\n      stopOnStartOfClassStaticBlock: true,\\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\\n    }, member);\\n    const callParseClassMemberWithIsStatic = () => {\\n      if (this.tsIsStartOfStaticBlocks()) {\\n        this.next();\\n        this.next();\\n        if (this.tsHasSomeModifiers(member, modifiers)) {\\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\\n        }\\n        super.parseClassStaticBlock(classBody, member);\\n      } else {\\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\\n      }\\n    };\\n    if (member.declare) {\\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\\n    } else {\\n      callParseClassMemberWithIsStatic();\\n    }\\n  }\\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\\n    const idx = this.tsTryParseIndexSignature(member);\\n    if (idx) {\\n      classBody.body.push(idx);\\n      if (member.abstract) {\\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\\n      }\\n      if (member.accessibility) {\\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\\n          modifier: member.accessibility\\n        });\\n      }\\n      if (member.declare) {\\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\\n      }\\n      if (member.override) {\\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\\n      }\\n      return;\\n    }\\n    if (!this.state.inAbstractClass && member.abstract) {\\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\\n    }\\n    if (member.override) {\\n      if (!state.hadSuperClass) {\\n        this.raise(TSErrors.OverrideNotInSubClass, member);\\n      }\\n    }\\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\\n  }\\n  parsePostMemberNameModifiers(methodOrProp) {\\n    const optional = this.eat(17);\\n    if (optional) methodOrProp.optional = true;\\n    if (methodOrProp.readonly && this.match(10)) {\\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\\n    }\\n    if (methodOrProp.declare && this.match(10)) {\\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\\n    }\\n  }\\n  parseExpressionStatement(node, expr, decorators) {\\n    const decl = expr.type === \\\"Identifier\\\" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;\\n    return decl || super.parseExpressionStatement(node, expr, decorators);\\n  }\\n  shouldParseExportDeclaration() {\\n    if (this.tsIsDeclarationStart()) return true;\\n    return super.shouldParseExportDeclaration();\\n  }\\n  parseConditional(expr, startLoc, refExpressionErrors) {\\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\\n    }\\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\\n    if (!result.node) {\\n      if (result.error) {\\n        super.setOptionalParametersError(refExpressionErrors, result.error);\\n      }\\n      return expr;\\n    }\\n    if (result.error) this.state = result.failState;\\n    return result.node;\\n  }\\n  parseParenItem(node, startLoc) {\\n    node = super.parseParenItem(node, startLoc);\\n    if (this.eat(17)) {\\n      node.optional = true;\\n      this.resetEndLocation(node);\\n    }\\n    if (this.match(14)) {\\n      const typeCastNode = this.startNodeAt(startLoc);\\n      typeCastNode.expression = node;\\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\\n      return this.finishNode(typeCastNode, \\\"TSTypeCastExpression\\\");\\n    }\\n    return node;\\n  }\\n  parseExportDeclaration(node) {\\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\\n    }\\n    const startLoc = this.state.startLoc;\\n    const isDeclare = this.eatContextual(125);\\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\\n    }\\n    const isIdentifier = tokenIsIdentifier(this.state.type);\\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\\n    if (!declaration) return null;\\n    if (declaration.type === \\\"TSInterfaceDeclaration\\\" || declaration.type === \\\"TSTypeAliasDeclaration\\\" || isDeclare) {\\n      node.exportKind = \\\"type\\\";\\n    }\\n    if (isDeclare) {\\n      this.resetStartLocation(declaration, startLoc);\\n      declaration.declare = true;\\n    }\\n    return declaration;\\n  }\\n  parseClassId(node, isStatement, optionalId, bindingType) {\\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\\n      return;\\n    }\\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\\n    if (typeParameters) node.typeParameters = typeParameters;\\n  }\\n  parseClassPropertyAnnotation(node) {\\n    if (!node.optional) {\\n      if (this.eat(35)) {\\n        node.definite = true;\\n      } else if (this.eat(17)) {\\n        node.optional = true;\\n      }\\n    }\\n    const type = this.tsTryParseTypeAnnotation();\\n    if (type) node.typeAnnotation = type;\\n  }\\n  parseClassProperty(node) {\\n    this.parseClassPropertyAnnotation(node);\\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\\n    }\\n    if (node.abstract && this.match(29)) {\\n      const {\\n        key\\n      } = node;\\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\\n        propertyName: key.type === \\\"Identifier\\\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\\n      });\\n    }\\n    return super.parseClassProperty(node);\\n  }\\n  parseClassPrivateProperty(node) {\\n    if (node.abstract) {\\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\\n    }\\n    if (node.accessibility) {\\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\\n        modifier: node.accessibility\\n      });\\n    }\\n    this.parseClassPropertyAnnotation(node);\\n    return super.parseClassPrivateProperty(node);\\n  }\\n  parseClassAccessorProperty(node) {\\n    this.parseClassPropertyAnnotation(node);\\n    if (node.optional) {\\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\\n    }\\n    return super.parseClassAccessorProperty(node);\\n  }\\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\\n    if (typeParameters && isConstructor) {\\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\\n    }\\n    const {\\n      declare = false,\\n      kind\\n    } = method;\\n    if (declare && (kind === \\\"get\\\" || kind === \\\"set\\\")) {\\n      this.raise(TSErrors.DeclareAccessor, method, {\\n        kind\\n      });\\n    }\\n    if (typeParameters) method.typeParameters = typeParameters;\\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\\n  }\\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\\n    if (typeParameters) method.typeParameters = typeParameters;\\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\\n  }\\n  declareClassPrivateMethodInScope(node, kind) {\\n    if (node.type === \\\"TSDeclareMethod\\\") return;\\n    if (node.type === \\\"MethodDefinition\\\" && !node.value.body) return;\\n    super.declareClassPrivateMethodInScope(node, kind);\\n  }\\n  parseClassSuper(node) {\\n    super.parseClassSuper(node);\\n    if (node.superClass && (this.match(47) || this.match(51))) {\\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\\n    }\\n    if (this.eatContextual(113)) {\\n      node.implements = this.tsParseHeritageClause(\\\"implements\\\");\\n    }\\n  }\\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\\n    if (typeParameters) prop.typeParameters = typeParameters;\\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\\n  }\\n  parseFunctionParams(node, isConstructor) {\\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\\n    if (typeParameters) node.typeParameters = typeParameters;\\n    super.parseFunctionParams(node, isConstructor);\\n  }\\n  parseVarId(decl, kind) {\\n    super.parseVarId(decl, kind);\\n    if (decl.id.type === \\\"Identifier\\\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\\n      decl.definite = true;\\n    }\\n    const type = this.tsTryParseTypeAnnotation();\\n    if (type) {\\n      decl.id.typeAnnotation = type;\\n      this.resetEndLocation(decl.id);\\n    }\\n  }\\n  parseAsyncArrowFromCallExpression(node, call) {\\n    if (this.match(14)) {\\n      node.returnType = this.tsParseTypeAnnotation();\\n    }\\n    return super.parseAsyncArrowFromCallExpression(node, call);\\n  }\\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\\n    let state;\\n    let jsx;\\n    let typeCast;\\n    if (this.hasPlugin(\\\"jsx\\\") && (this.match(142) || this.match(47))) {\\n      state = this.state.clone();\\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\\n      if (!jsx.error) return jsx.node;\\n      const {\\n        context\\n      } = this.state;\\n      const currentContext = context[context.length - 1];\\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\\n        context.pop();\\n      }\\n    }\\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\\n    }\\n    if (!state || state === this.state) state = this.state.clone();\\n    let typeParameters;\\n    const arrow = this.tryParse(abort => {\\n      var _expr$extra, _typeParameters;\\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\\n      if (expr.type !== \\\"ArrowFunctionExpression\\\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\\n        abort();\\n      }\\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\\n        this.resetStartLocationFromNode(expr, typeParameters);\\n      }\\n      expr.typeParameters = typeParameters;\\n      return expr;\\n    }, state);\\n    if (!arrow.error && !arrow.aborted) {\\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\\n      return arrow.node;\\n    }\\n    if (!jsx) {\\n      assert(!this.hasPlugin(\\\"jsx\\\"));\\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\\n      if (!typeCast.error) return typeCast.node;\\n    }\\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\\n      this.state = jsx.failState;\\n      return jsx.node;\\n    }\\n    if (arrow.node) {\\n      this.state = arrow.failState;\\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\\n      return arrow.node;\\n    }\\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\\n      this.state = typeCast.failState;\\n      return typeCast.node;\\n    }\\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\\n  }\\n  reportReservedArrowTypeParam(node) {\\n    var _node$extra;\\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\\\"typescript\\\", \\\"disallowAmbiguousJSXLike\\\")) {\\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\\n    }\\n  }\\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\\n    if (!this.hasPlugin(\\\"jsx\\\") && this.match(47)) {\\n      return this.tsParseTypeAssertion();\\n    }\\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\\n  }\\n  parseArrow(node) {\\n    if (this.match(14)) {\\n      const result = this.tryParse(abort => {\\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\\n        return returnType;\\n      });\\n      if (result.aborted) return;\\n      if (!result.thrown) {\\n        if (result.error) this.state = result.failState;\\n        node.returnType = result.node;\\n      }\\n    }\\n    return super.parseArrow(node);\\n  }\\n  parseAssignableListItemTypes(param, flags) {\\n    if (!(flags & 2)) return param;\\n    if (this.eat(17)) {\\n      param.optional = true;\\n    }\\n    const type = this.tsTryParseTypeAnnotation();\\n    if (type) param.typeAnnotation = type;\\n    this.resetEndLocation(param);\\n    return param;\\n  }\\n  isAssignable(node, isBinding) {\\n    switch (node.type) {\\n      case \\\"TSTypeCastExpression\\\":\\n        return this.isAssignable(node.expression, isBinding);\\n      case \\\"TSParameterProperty\\\":\\n        return true;\\n      default:\\n        return super.isAssignable(node, isBinding);\\n    }\\n  }\\n  toAssignable(node, isLHS = false) {\\n    switch (node.type) {\\n      case \\\"ParenthesizedExpression\\\":\\n        this.toAssignableParenthesizedExpression(node, isLHS);\\n        break;\\n      case \\\"TSAsExpression\\\":\\n      case \\\"TSSatisfiesExpression\\\":\\n      case \\\"TSNonNullExpression\\\":\\n      case \\\"TSTypeAssertion\\\":\\n        if (isLHS) {\\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\\n        } else {\\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\\n        }\\n        this.toAssignable(node.expression, isLHS);\\n        break;\\n      case \\\"AssignmentExpression\\\":\\n        if (!isLHS && node.left.type === \\\"TSTypeCastExpression\\\") {\\n          node.left = this.typeCastToParameter(node.left);\\n        }\\n      default:\\n        super.toAssignable(node, isLHS);\\n    }\\n  }\\n  toAssignableParenthesizedExpression(node, isLHS) {\\n    switch (node.expression.type) {\\n      case \\\"TSAsExpression\\\":\\n      case \\\"TSSatisfiesExpression\\\":\\n      case \\\"TSNonNullExpression\\\":\\n      case \\\"TSTypeAssertion\\\":\\n      case \\\"ParenthesizedExpression\\\":\\n        this.toAssignable(node.expression, isLHS);\\n        break;\\n      default:\\n        super.toAssignable(node, isLHS);\\n    }\\n  }\\n  checkToRestConversion(node, allowPattern) {\\n    switch (node.type) {\\n      case \\\"TSAsExpression\\\":\\n      case \\\"TSSatisfiesExpression\\\":\\n      case \\\"TSTypeAssertion\\\":\\n      case \\\"TSNonNullExpression\\\":\\n        this.checkToRestConversion(node.expression, false);\\n        break;\\n      default:\\n        super.checkToRestConversion(node, allowPattern);\\n    }\\n  }\\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\\n    return getOwn({\\n      TSTypeCastExpression: true,\\n      TSParameterProperty: \\\"parameter\\\",\\n      TSNonNullExpression: \\\"expression\\\",\\n      TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\\\"expression\\\", true],\\n      TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\\\"expression\\\", true],\\n      TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && [\\\"expression\\\", true]\\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\\n  }\\n  parseBindingAtom() {\\n    if (this.state.type === 78) {\\n      return this.parseIdentifier(true);\\n    }\\n    return super.parseBindingAtom();\\n  }\\n  parseMaybeDecoratorArguments(expr) {\\n    if (this.match(47) || this.match(51)) {\\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\\n      if (this.match(10)) {\\n        const call = super.parseMaybeDecoratorArguments(expr);\\n        call.typeParameters = typeArguments;\\n        return call;\\n      }\\n      this.unexpected(null, 10);\\n    }\\n    return super.parseMaybeDecoratorArguments(expr);\\n  }\\n  checkCommaAfterRest(close) {\\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\\n      this.next();\\n      return false;\\n    }\\n    return super.checkCommaAfterRest(close);\\n  }\\n  isClassMethod() {\\n    return this.match(47) || super.isClassMethod();\\n  }\\n  isClassProperty() {\\n    return this.match(35) || this.match(14) || super.isClassProperty();\\n  }\\n  parseMaybeDefault(startLoc, left) {\\n    const node = super.parseMaybeDefault(startLoc, left);\\n    if (node.type === \\\"AssignmentPattern\\\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\\n    }\\n    return node;\\n  }\\n  getTokenFromCode(code) {\\n    if (this.state.inType) {\\n      if (code === 62) {\\n        this.finishOp(48, 1);\\n        return;\\n      }\\n      if (code === 60) {\\n        this.finishOp(47, 1);\\n        return;\\n      }\\n    }\\n    super.getTokenFromCode(code);\\n  }\\n  reScan_lt_gt() {\\n    const {\\n      type\\n    } = this.state;\\n    if (type === 47) {\\n      this.state.pos -= 1;\\n      this.readToken_lt();\\n    } else if (type === 48) {\\n      this.state.pos -= 1;\\n      this.readToken_gt();\\n    }\\n  }\\n  reScan_lt() {\\n    const {\\n      type\\n    } = this.state;\\n    if (type === 51) {\\n      this.state.pos -= 2;\\n      this.finishOp(47, 1);\\n      return 47;\\n    }\\n    return type;\\n  }\\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\\n    for (let i = 0; i < exprList.length; i++) {\\n      const expr = exprList[i];\\n      if ((expr == null ? void 0 : expr.type) === \\\"TSTypeCastExpression\\\") {\\n        exprList[i] = this.typeCastToParameter(expr);\\n      }\\n    }\\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\\n  }\\n  typeCastToParameter(node) {\\n    node.expression.typeAnnotation = node.typeAnnotation;\\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\\n    return node.expression;\\n  }\\n  shouldParseArrow(params) {\\n    if (this.match(14)) {\\n      return params.every(expr => this.isAssignable(expr, true));\\n    }\\n    return super.shouldParseArrow(params);\\n  }\\n  shouldParseAsyncArrow() {\\n    return this.match(14) || super.shouldParseAsyncArrow();\\n  }\\n  canHaveLeadingDecorator() {\\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\\n  }\\n  jsxParseOpeningElementAfterName(node) {\\n    if (this.match(47) || this.match(51)) {\\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\\n      if (typeArguments) node.typeParameters = typeArguments;\\n    }\\n    return super.jsxParseOpeningElementAfterName(node);\\n  }\\n  getGetterSetterExpectedParamCount(method) {\\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\\n    const params = this.getObjectOrClassMethodParams(method);\\n    const firstParam = params[0];\\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\\n    return hasContextParam ? baseCount + 1 : baseCount;\\n  }\\n  parseCatchClauseParam() {\\n    const param = super.parseCatchClauseParam();\\n    const type = this.tsTryParseTypeAnnotation();\\n    if (type) {\\n      param.typeAnnotation = type;\\n      this.resetEndLocation(param);\\n    }\\n    return param;\\n  }\\n  tsInAmbientContext(cb) {\\n    const oldIsAmbientContext = this.state.isAmbientContext;\\n    this.state.isAmbientContext = true;\\n    try {\\n      return cb();\\n    } finally {\\n      this.state.isAmbientContext = oldIsAmbientContext;\\n    }\\n  }\\n  parseClass(node, isStatement, optionalId) {\\n    const oldInAbstractClass = this.state.inAbstractClass;\\n    this.state.inAbstractClass = !!node.abstract;\\n    try {\\n      return super.parseClass(node, isStatement, optionalId);\\n    } finally {\\n      this.state.inAbstractClass = oldInAbstractClass;\\n    }\\n  }\\n  tsParseAbstractDeclaration(node, decorators) {\\n    if (this.match(80)) {\\n      node.abstract = true;\\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\\n    } else if (this.isContextual(129)) {\\n      if (!this.hasFollowingLineBreak()) {\\n        node.abstract = true;\\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\\n        return this.tsParseInterfaceDeclaration(node);\\n      }\\n    } else {\\n      this.unexpected(null, 80);\\n    }\\n  }\\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\\n    if (method.abstract) {\\n      const hasBody = this.hasPlugin(\\\"estree\\\") ? !!method.value.body : !!method.body;\\n      if (hasBody) {\\n        const {\\n          key\\n        } = method;\\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\\n          methodName: key.type === \\\"Identifier\\\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\\n        });\\n      }\\n    }\\n    return method;\\n  }\\n  tsParseTypeParameterName() {\\n    const typeName = this.parseIdentifier();\\n    return typeName.name;\\n  }\\n  shouldParseAsAmbientContext() {\\n    return !!this.getPluginOption(\\\"typescript\\\", \\\"dts\\\");\\n  }\\n  parse() {\\n    if (this.shouldParseAsAmbientContext()) {\\n      this.state.isAmbientContext = true;\\n    }\\n    return super.parse();\\n  }\\n  getExpression() {\\n    if (this.shouldParseAsAmbientContext()) {\\n      this.state.isAmbientContext = true;\\n    }\\n    return super.getExpression();\\n  }\\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\\n    if (!isString && isMaybeTypeOnly) {\\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\\n      return this.finishNode(node, \\\"ExportSpecifier\\\");\\n    }\\n    node.exportKind = \\\"value\\\";\\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\\n  }\\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\\n    if (!importedIsString && isMaybeTypeOnly) {\\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\\n      return this.finishNode(specifier, \\\"ImportSpecifier\\\");\\n    }\\n    specifier.importKind = \\\"value\\\";\\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\\n  }\\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\\n    const leftOfAsKey = isImport ? \\\"imported\\\" : \\\"local\\\";\\n    const rightOfAsKey = isImport ? \\\"local\\\" : \\\"exported\\\";\\n    let leftOfAs = node[leftOfAsKey];\\n    let rightOfAs;\\n    let hasTypeSpecifier = false;\\n    let canParseAsKeyword = true;\\n    const loc = leftOfAs.loc.start;\\n    if (this.isContextual(93)) {\\n      const firstAs = this.parseIdentifier();\\n      if (this.isContextual(93)) {\\n        const secondAs = this.parseIdentifier();\\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\\n          hasTypeSpecifier = true;\\n          leftOfAs = firstAs;\\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\\n          canParseAsKeyword = false;\\n        } else {\\n          rightOfAs = secondAs;\\n          canParseAsKeyword = false;\\n        }\\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\\n        canParseAsKeyword = false;\\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\\n      } else {\\n        hasTypeSpecifier = true;\\n        leftOfAs = firstAs;\\n      }\\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\\n      hasTypeSpecifier = true;\\n      if (isImport) {\\n        leftOfAs = this.parseIdentifier(true);\\n        if (!this.isContextual(93)) {\\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\\n        }\\n      } else {\\n        leftOfAs = this.parseModuleExportName();\\n      }\\n    }\\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\\n    }\\n    node[leftOfAsKey] = leftOfAs;\\n    node[rightOfAsKey] = rightOfAs;\\n    const kindKey = isImport ? \\\"importKind\\\" : \\\"exportKind\\\";\\n    node[kindKey] = hasTypeSpecifier ? \\\"type\\\" : \\\"value\\\";\\n    if (canParseAsKeyword && this.eatContextual(93)) {\\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\\n    }\\n    if (!node[rightOfAsKey]) {\\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\\n    }\\n    if (isImport) {\\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\\n    }\\n  }\\n};\\nfunction isPossiblyLiteralEnum(expression) {\\n  if (expression.type !== \\\"MemberExpression\\\") return false;\\n  const {\\n    computed,\\n    property\\n  } = expression;\\n  if (computed && property.type !== \\\"StringLiteral\\\" && (property.type !== \\\"TemplateLiteral\\\" || property.expressions.length > 0)) {\\n    return false;\\n  }\\n  return isUncomputedMemberExpressionChain(expression.object);\\n}\\nfunction isValidAmbientConstInitializer(expression, estree) {\\n  var _expression$extra;\\n  const {\\n    type\\n  } = expression;\\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\\n    return false;\\n  }\\n  if (estree) {\\n    if (type === \\\"Literal\\\") {\\n      const {\\n        value\\n      } = expression;\\n      if (typeof value === \\\"string\\\" || typeof value === \\\"boolean\\\") {\\n        return true;\\n      }\\n    }\\n  } else {\\n    if (type === \\\"StringLiteral\\\" || type === \\\"BooleanLiteral\\\") {\\n      return true;\\n    }\\n  }\\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\\n    return true;\\n  }\\n  if (type === \\\"TemplateLiteral\\\" && expression.expressions.length === 0) {\\n    return true;\\n  }\\n  if (isPossiblyLiteralEnum(expression)) {\\n    return true;\\n  }\\n  return false;\\n}\\nfunction isNumber(expression, estree) {\\n  if (estree) {\\n    return expression.type === \\\"Literal\\\" && (typeof expression.value === \\\"number\\\" || \\\"bigint\\\" in expression);\\n  }\\n  return expression.type === \\\"NumericLiteral\\\" || expression.type === \\\"BigIntLiteral\\\";\\n}\\nfunction isNegativeNumber(expression, estree) {\\n  if (expression.type === \\\"UnaryExpression\\\") {\\n    const {\\n      operator,\\n      argument\\n    } = expression;\\n    if (operator === \\\"-\\\" && isNumber(argument, estree)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\nfunction isUncomputedMemberExpressionChain(expression) {\\n  if (expression.type === \\\"Identifier\\\") return true;\\n  if (expression.type !== \\\"MemberExpression\\\" || expression.computed) {\\n    return false;\\n  }\\n  return isUncomputedMemberExpressionChain(expression.object);\\n}\\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\\n  ClassNameIsRequired: \\\"A class name is required.\\\",\\n  UnexpectedSpace: \\\"Unexpected space in placeholder.\\\"\\n});\\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\\n  parsePlaceholder(expectedNode) {\\n    if (this.match(144)) {\\n      const node = this.startNode();\\n      this.next();\\n      this.assertNoSpace();\\n      node.name = super.parseIdentifier(true);\\n      this.assertNoSpace();\\n      this.expect(144);\\n      return this.finishPlaceholder(node, expectedNode);\\n    }\\n  }\\n  finishPlaceholder(node, expectedNode) {\\n    const isFinished = !!(node.expectedNode && node.type === \\\"Placeholder\\\");\\n    node.expectedNode = expectedNode;\\n    return isFinished ? node : this.finishNode(node, \\\"Placeholder\\\");\\n  }\\n  getTokenFromCode(code) {\\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\\n      this.finishOp(144, 2);\\n    } else {\\n      super.getTokenFromCode(code);\\n    }\\n  }\\n  parseExprAtom(refExpressionErrors) {\\n    return this.parsePlaceholder(\\\"Expression\\\") || super.parseExprAtom(refExpressionErrors);\\n  }\\n  parseIdentifier(liberal) {\\n    return this.parsePlaceholder(\\\"Identifier\\\") || super.parseIdentifier(liberal);\\n  }\\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\\n    if (word !== undefined) {\\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\\n    }\\n  }\\n  parseBindingAtom() {\\n    return this.parsePlaceholder(\\\"Pattern\\\") || super.parseBindingAtom();\\n  }\\n  isValidLVal(type, isParenthesized, binding) {\\n    return type === \\\"Placeholder\\\" || super.isValidLVal(type, isParenthesized, binding);\\n  }\\n  toAssignable(node, isLHS) {\\n    if (node && node.type === \\\"Placeholder\\\" && node.expectedNode === \\\"Expression\\\") {\\n      node.expectedNode = \\\"Pattern\\\";\\n    } else {\\n      super.toAssignable(node, isLHS);\\n    }\\n  }\\n  chStartsBindingIdentifier(ch, pos) {\\n    if (super.chStartsBindingIdentifier(ch, pos)) {\\n      return true;\\n    }\\n    const nextToken = this.lookahead();\\n    if (nextToken.type === 144) {\\n      return true;\\n    }\\n    return false;\\n  }\\n  verifyBreakContinue(node, isBreak) {\\n    if (node.label && node.label.type === \\\"Placeholder\\\") return;\\n    super.verifyBreakContinue(node, isBreak);\\n  }\\n  parseExpressionStatement(node, expr) {\\n    var _expr$extra;\\n    if (expr.type !== \\\"Placeholder\\\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\\n      return super.parseExpressionStatement(node, expr);\\n    }\\n    if (this.match(14)) {\\n      const stmt = node;\\n      stmt.label = this.finishPlaceholder(expr, \\\"Identifier\\\");\\n      this.next();\\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\\n      return this.finishNode(stmt, \\\"LabeledStatement\\\");\\n    }\\n    this.semicolon();\\n    node.name = expr.name;\\n    return this.finishPlaceholder(node, \\\"Statement\\\");\\n  }\\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\\n    return this.parsePlaceholder(\\\"BlockStatement\\\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\\n  }\\n  parseFunctionId(requireId) {\\n    return this.parsePlaceholder(\\\"Identifier\\\") || super.parseFunctionId(requireId);\\n  }\\n  parseClass(node, isStatement, optionalId) {\\n    const type = isStatement ? \\\"ClassDeclaration\\\" : \\\"ClassExpression\\\";\\n    this.next();\\n    const oldStrict = this.state.strict;\\n    const placeholder = this.parsePlaceholder(\\\"Identifier\\\");\\n    if (placeholder) {\\n      if (this.match(81) || this.match(144) || this.match(5)) {\\n        node.id = placeholder;\\n      } else if (optionalId || !isStatement) {\\n        node.id = null;\\n        node.body = this.finishPlaceholder(placeholder, \\\"ClassBody\\\");\\n        return this.finishNode(node, type);\\n      } else {\\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\\n      }\\n    } else {\\n      this.parseClassId(node, isStatement, optionalId);\\n    }\\n    super.parseClassSuper(node);\\n    node.body = this.parsePlaceholder(\\\"ClassBody\\\") || super.parseClassBody(!!node.superClass, oldStrict);\\n    return this.finishNode(node, type);\\n  }\\n  parseExport(node, decorators) {\\n    const placeholder = this.parsePlaceholder(\\\"Identifier\\\");\\n    if (!placeholder) return super.parseExport(node, decorators);\\n    if (!this.isContextual(98) && !this.match(12)) {\\n      node.specifiers = [];\\n      node.source = null;\\n      node.declaration = this.finishPlaceholder(placeholder, \\\"Declaration\\\");\\n      return this.finishNode(node, \\\"ExportNamedDeclaration\\\");\\n    }\\n    this.expectPlugin(\\\"exportDefaultFrom\\\");\\n    const specifier = this.startNode();\\n    specifier.exported = placeholder;\\n    node.specifiers = [this.finishNode(specifier, \\\"ExportDefaultSpecifier\\\")];\\n    return super.parseExport(node, decorators);\\n  }\\n  isExportDefaultSpecifier() {\\n    if (this.match(65)) {\\n      const next = this.nextTokenStart();\\n      if (this.isUnparsedContextual(next, \\\"from\\\")) {\\n        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {\\n          return true;\\n        }\\n      }\\n    }\\n    return super.isExportDefaultSpecifier();\\n  }\\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\\n    var _specifiers;\\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\\n      return true;\\n    }\\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\\n  }\\n  checkExport(node) {\\n    const {\\n      specifiers\\n    } = node;\\n    if (specifiers != null && specifiers.length) {\\n      node.specifiers = specifiers.filter(node => node.exported.type === \\\"Placeholder\\\");\\n    }\\n    super.checkExport(node);\\n    node.specifiers = specifiers;\\n  }\\n  parseImport(node) {\\n    const placeholder = this.parsePlaceholder(\\\"Identifier\\\");\\n    if (!placeholder) return super.parseImport(node);\\n    node.specifiers = [];\\n    if (!this.isContextual(98) && !this.match(12)) {\\n      node.source = this.finishPlaceholder(placeholder, \\\"StringLiteral\\\");\\n      this.semicolon();\\n      return this.finishNode(node, \\\"ImportDeclaration\\\");\\n    }\\n    const specifier = this.startNodeAtNode(placeholder);\\n    specifier.local = placeholder;\\n    node.specifiers.push(this.finishNode(specifier, \\\"ImportDefaultSpecifier\\\"));\\n    if (this.eat(12)) {\\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\\n    }\\n    this.expectContextual(98);\\n    node.source = this.parseImportSource();\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ImportDeclaration\\\");\\n  }\\n  parseImportSource() {\\n    return this.parsePlaceholder(\\\"StringLiteral\\\") || super.parseImportSource();\\n  }\\n  assertNoSpace() {\\n    if (this.state.start > this.state.lastTokEndLoc.index) {\\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\\n    }\\n  }\\n};\\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\\n  parseV8Intrinsic() {\\n    if (this.match(54)) {\\n      const v8IntrinsicStartLoc = this.state.startLoc;\\n      const node = this.startNode();\\n      this.next();\\n      if (tokenIsIdentifier(this.state.type)) {\\n        const name = this.parseIdentifierName();\\n        const identifier = this.createIdentifier(node, name);\\n        identifier.type = \\\"V8IntrinsicIdentifier\\\";\\n        if (this.match(10)) {\\n          return identifier;\\n        }\\n      }\\n      this.unexpected(v8IntrinsicStartLoc);\\n    }\\n  }\\n  parseExprAtom(refExpressionErrors) {\\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\\n  }\\n};\\nfunction hasPlugin(plugins, expectedConfig) {\\n  const [expectedName, expectedOptions] = typeof expectedConfig === \\\"string\\\" ? [expectedConfig, {}] : expectedConfig;\\n  const expectedKeys = Object.keys(expectedOptions);\\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\\n  return plugins.some(p => {\\n    if (typeof p === \\\"string\\\") {\\n      return expectedOptionsIsEmpty && p === expectedName;\\n    } else {\\n      const [pluginName, pluginOptions] = p;\\n      if (pluginName !== expectedName) {\\n        return false;\\n      }\\n      for (const key of expectedKeys) {\\n        if (pluginOptions[key] !== expectedOptions[key]) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }\\n  });\\n}\\nfunction getPluginOption(plugins, name, option) {\\n  const plugin = plugins.find(plugin => {\\n    if (Array.isArray(plugin)) {\\n      return plugin[0] === name;\\n    } else {\\n      return plugin === name;\\n    }\\n  });\\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\\n    return plugin[1][option];\\n  }\\n  return null;\\n}\\nconst PIPELINE_PROPOSALS = [\\\"minimal\\\", \\\"fsharp\\\", \\\"hack\\\", \\\"smart\\\"];\\nconst TOPIC_TOKENS = [\\\"^^\\\", \\\"@@\\\", \\\"^\\\", \\\"%\\\", \\\"#\\\"];\\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\\\"hash\\\", \\\"bar\\\"];\\nfunction validatePlugins(plugins) {\\n  if (hasPlugin(plugins, \\\"decorators\\\")) {\\n    if (hasPlugin(plugins, \\\"decorators-legacy\\\")) {\\n      throw new Error(\\\"Cannot use the decorators and decorators-legacy plugin together\\\");\\n    }\\n    const decoratorsBeforeExport = getPluginOption(plugins, \\\"decorators\\\", \\\"decoratorsBeforeExport\\\");\\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \\\"boolean\\\") {\\n      throw new Error(\\\"'decoratorsBeforeExport' must be a boolean, if specified.\\\");\\n    }\\n    const allowCallParenthesized = getPluginOption(plugins, \\\"decorators\\\", \\\"allowCallParenthesized\\\");\\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \\\"boolean\\\") {\\n      throw new Error(\\\"'allowCallParenthesized' must be a boolean.\\\");\\n    }\\n  }\\n  if (hasPlugin(plugins, \\\"flow\\\") && hasPlugin(plugins, \\\"typescript\\\")) {\\n    throw new Error(\\\"Cannot combine flow and typescript plugins.\\\");\\n  }\\n  if (hasPlugin(plugins, \\\"placeholders\\\") && hasPlugin(plugins, \\\"v8intrinsic\\\")) {\\n    throw new Error(\\\"Cannot combine placeholders and v8intrinsic plugins.\\\");\\n  }\\n  if (hasPlugin(plugins, \\\"pipelineOperator\\\")) {\\n    const proposal = getPluginOption(plugins, \\\"pipelineOperator\\\", \\\"proposal\\\");\\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\\\"${p}\\\"`).join(\\\", \\\");\\n      throw new Error(`\\\"pipelineOperator\\\" requires \\\"proposal\\\" option whose value must be one of: ${proposalList}.`);\\n    }\\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\\\"recordAndTuple\\\", {\\n      syntaxType: \\\"hash\\\"\\n    }]);\\n    if (proposal === \\\"hack\\\") {\\n      if (hasPlugin(plugins, \\\"placeholders\\\")) {\\n        throw new Error(\\\"Cannot combine placeholders plugin and Hack-style pipes.\\\");\\n      }\\n      if (hasPlugin(plugins, \\\"v8intrinsic\\\")) {\\n        throw new Error(\\\"Cannot combine v8intrinsic plugin and Hack-style pipes.\\\");\\n      }\\n      const topicToken = getPluginOption(plugins, \\\"pipelineOperator\\\", \\\"topicToken\\\");\\n      if (!TOPIC_TOKENS.includes(topicToken)) {\\n        const tokenList = TOPIC_TOKENS.map(t => `\\\"${t}\\\"`).join(\\\", \\\");\\n        throw new Error(`\\\"pipelineOperator\\\" in \\\"proposal\\\": \\\"hack\\\" mode also requires a \\\"topicToken\\\" option whose value must be one of: ${tokenList}.`);\\n      }\\n      if (topicToken === \\\"#\\\" && tupleSyntaxIsHash) {\\n        throw new Error('Plugin conflict between `[\\\"pipelineOperator\\\", { proposal: \\\"hack\\\", topicToken: \\\"#\\\" }]` and `[\\\"recordAndtuple\\\", { syntaxType: \\\"hash\\\"}]`.');\\n      }\\n    } else if (proposal === \\\"smart\\\" && tupleSyntaxIsHash) {\\n      throw new Error('Plugin conflict between `[\\\"pipelineOperator\\\", { proposal: \\\"smart\\\" }]` and `[\\\"recordAndtuple\\\", { syntaxType: \\\"hash\\\"}]`.');\\n    }\\n  }\\n  if (hasPlugin(plugins, \\\"moduleAttributes\\\")) {\\n    {\\n      if (hasPlugin(plugins, \\\"importAssertions\\\") || hasPlugin(plugins, \\\"importAttributes\\\")) {\\n        throw new Error(\\\"Cannot combine importAssertions, importAttributes and moduleAttributes plugins.\\\");\\n      }\\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \\\"moduleAttributes\\\", \\\"version\\\");\\n      if (moduleAttributesVersionPluginOption !== \\\"may-2020\\\") {\\n        throw new Error(\\\"The 'moduleAttributes' plugin requires a 'version' option,\\\" + \\\" representing the last proposal update. Currently, the\\\" + \\\" only supported value is 'may-2020'.\\\");\\n      }\\n    }\\n  }\\n  if (hasPlugin(plugins, \\\"importAssertions\\\") && hasPlugin(plugins, \\\"importAttributes\\\")) {\\n    throw new Error(\\\"Cannot combine importAssertions and importAttributes plugins.\\\");\\n  }\\n  if (hasPlugin(plugins, \\\"recordAndTuple\\\") && getPluginOption(plugins, \\\"recordAndTuple\\\", \\\"syntaxType\\\") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \\\"recordAndTuple\\\", \\\"syntaxType\\\"))) {\\n    throw new Error(\\\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \\\" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\\\", \\\"));\\n  }\\n  if (hasPlugin(plugins, \\\"asyncDoExpressions\\\") && !hasPlugin(plugins, \\\"doExpressions\\\")) {\\n    const error = new Error(\\\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\\\");\\n    error.missingPlugins = \\\"doExpressions\\\";\\n    throw error;\\n  }\\n  if (hasPlugin(plugins, \\\"optionalChainingAssign\\\") && getPluginOption(plugins, \\\"optionalChainingAssign\\\", \\\"version\\\") !== \\\"2023-07\\\") {\\n    throw new Error(\\\"The 'optionalChainingAssign' plugin requires a 'version' option,\\\" + \\\" representing the last proposal update. Currently, the\\\" + \\\" only supported value is '2023-07'.\\\");\\n  }\\n}\\nconst mixinPlugins = {\\n  estree,\\n  jsx,\\n  flow,\\n  typescript,\\n  v8intrinsic,\\n  placeholders\\n};\\nconst mixinPluginNames = Object.keys(mixinPlugins);\\nconst defaultOptions = {\\n  sourceType: \\\"script\\\",\\n  sourceFilename: undefined,\\n  startColumn: 0,\\n  startLine: 1,\\n  allowAwaitOutsideFunction: false,\\n  allowReturnOutsideFunction: false,\\n  allowNewTargetOutsideFunction: false,\\n  allowImportExportEverywhere: false,\\n  allowSuperOutsideMethod: false,\\n  allowUndeclaredExports: false,\\n  plugins: [],\\n  strictMode: null,\\n  ranges: false,\\n  tokens: false,\\n  createImportExpressions: false,\\n  createParenthesizedExpressions: false,\\n  errorRecovery: false,\\n  attachComment: true,\\n  annexB: true\\n};\\nfunction getOptions(opts) {\\n  if (opts == null) {\\n    return Object.assign({}, defaultOptions);\\n  }\\n  if (opts.annexB != null && opts.annexB !== false) {\\n    throw new Error(\\\"The `annexB` option can only be set to `false`.\\\");\\n  }\\n  const options = {};\\n  for (const key of Object.keys(defaultOptions)) {\\n    var _opts$key;\\n    options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];\\n  }\\n  return options;\\n}\\nclass ExpressionParser extends LValParser {\\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\\n    if (prop.type === \\\"SpreadElement\\\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\\n      return;\\n    }\\n    const key = prop.key;\\n    const name = key.type === \\\"Identifier\\\" ? key.name : key.value;\\n    if (name === \\\"__proto__\\\") {\\n      if (isRecord) {\\n        this.raise(Errors.RecordNoProto, key);\\n        return;\\n      }\\n      if (protoRef.used) {\\n        if (refExpressionErrors) {\\n          if (refExpressionErrors.doubleProtoLoc === null) {\\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\\n          }\\n        } else {\\n          this.raise(Errors.DuplicateProto, key);\\n        }\\n      }\\n      protoRef.used = true;\\n    }\\n  }\\n  shouldExitDescending(expr, potentialArrowAt) {\\n    return expr.type === \\\"ArrowFunctionExpression\\\" && expr.start === potentialArrowAt;\\n  }\\n  getExpression() {\\n    this.enterInitialScopes();\\n    this.nextToken();\\n    const expr = this.parseExpression();\\n    if (!this.match(139)) {\\n      this.unexpected();\\n    }\\n    this.finalizeRemainingComments();\\n    expr.comments = this.comments;\\n    expr.errors = this.state.errors;\\n    if (this.options.tokens) {\\n      expr.tokens = this.tokens;\\n    }\\n    return expr;\\n  }\\n  parseExpression(disallowIn, refExpressionErrors) {\\n    if (disallowIn) {\\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\\n    }\\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\\n  }\\n  parseExpressionBase(refExpressionErrors) {\\n    const startLoc = this.state.startLoc;\\n    const expr = this.parseMaybeAssign(refExpressionErrors);\\n    if (this.match(12)) {\\n      const node = this.startNodeAt(startLoc);\\n      node.expressions = [expr];\\n      while (this.eat(12)) {\\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\\n      }\\n      this.toReferencedList(node.expressions);\\n      return this.finishNode(node, \\\"SequenceExpression\\\");\\n    }\\n    return expr;\\n  }\\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\\n  }\\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\\n  }\\n  setOptionalParametersError(refExpressionErrors, resultError) {\\n    var _resultError$loc;\\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\\n  }\\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\\n    const startLoc = this.state.startLoc;\\n    if (this.isContextual(108)) {\\n      if (this.prodParam.hasYield) {\\n        let left = this.parseYield();\\n        if (afterLeftParse) {\\n          left = afterLeftParse.call(this, left, startLoc);\\n        }\\n        return left;\\n      }\\n    }\\n    let ownExpressionErrors;\\n    if (refExpressionErrors) {\\n      ownExpressionErrors = false;\\n    } else {\\n      refExpressionErrors = new ExpressionErrors();\\n      ownExpressionErrors = true;\\n    }\\n    const {\\n      type\\n    } = this.state;\\n    if (type === 10 || tokenIsIdentifier(type)) {\\n      this.state.potentialArrowAt = this.state.start;\\n    }\\n    let left = this.parseMaybeConditional(refExpressionErrors);\\n    if (afterLeftParse) {\\n      left = afterLeftParse.call(this, left, startLoc);\\n    }\\n    if (tokenIsAssignment(this.state.type)) {\\n      const node = this.startNodeAt(startLoc);\\n      const operator = this.state.value;\\n      node.operator = operator;\\n      if (this.match(29)) {\\n        this.toAssignable(left, true);\\n        node.left = left;\\n        const startIndex = startLoc.index;\\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\\n          refExpressionErrors.doubleProtoLoc = null;\\n        }\\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\\n          refExpressionErrors.shorthandAssignLoc = null;\\n        }\\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\\n          this.checkDestructuringPrivate(refExpressionErrors);\\n          refExpressionErrors.privateKeyLoc = null;\\n        }\\n      } else {\\n        node.left = left;\\n      }\\n      this.next();\\n      node.right = this.parseMaybeAssign();\\n      this.checkLVal(left, {\\n        in: this.finishNode(node, \\\"AssignmentExpression\\\")\\n      });\\n      return node;\\n    } else if (ownExpressionErrors) {\\n      this.checkExpressionErrors(refExpressionErrors, true);\\n    }\\n    return left;\\n  }\\n  parseMaybeConditional(refExpressionErrors) {\\n    const startLoc = this.state.startLoc;\\n    const potentialArrowAt = this.state.potentialArrowAt;\\n    const expr = this.parseExprOps(refExpressionErrors);\\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\\n      return expr;\\n    }\\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\\n  }\\n  parseConditional(expr, startLoc, refExpressionErrors) {\\n    if (this.eat(17)) {\\n      const node = this.startNodeAt(startLoc);\\n      node.test = expr;\\n      node.consequent = this.parseMaybeAssignAllowIn();\\n      this.expect(14);\\n      node.alternate = this.parseMaybeAssign();\\n      return this.finishNode(node, \\\"ConditionalExpression\\\");\\n    }\\n    return expr;\\n  }\\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\\n    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\\n  }\\n  parseExprOps(refExpressionErrors) {\\n    const startLoc = this.state.startLoc;\\n    const potentialArrowAt = this.state.potentialArrowAt;\\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\\n      return expr;\\n    }\\n    return this.parseExprOp(expr, startLoc, -1);\\n  }\\n  parseExprOp(left, leftStartLoc, minPrec) {\\n    if (this.isPrivateName(left)) {\\n      const value = this.getPrivateNameSV(left);\\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\\n        this.raise(Errors.PrivateInExpectedIn, left, {\\n          identifierName: value\\n        });\\n      }\\n      this.classScope.usePrivateName(value, left.loc.start);\\n    }\\n    const op = this.state.type;\\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\\n      let prec = tokenOperatorPrecedence(op);\\n      if (prec > minPrec) {\\n        if (op === 39) {\\n          this.expectPlugin(\\\"pipelineOperator\\\");\\n          if (this.state.inFSharpPipelineDirectBody) {\\n            return left;\\n          }\\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\\n        }\\n        const node = this.startNodeAt(leftStartLoc);\\n        node.left = left;\\n        node.operator = this.state.value;\\n        const logical = op === 41 || op === 42;\\n        const coalesce = op === 40;\\n        if (coalesce) {\\n          prec = tokenOperatorPrecedence(42);\\n        }\\n        this.next();\\n        if (op === 39 && this.hasPlugin([\\\"pipelineOperator\\\", {\\n          proposal: \\\"minimal\\\"\\n        }])) {\\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\\n          }\\n        }\\n        node.right = this.parseExprOpRightExpr(op, prec);\\n        const finishedNode = this.finishNode(node, logical || coalesce ? \\\"LogicalExpression\\\" : \\\"BinaryExpression\\\");\\n        const nextOp = this.state.type;\\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\\n        }\\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\\n      }\\n    }\\n    return left;\\n  }\\n  parseExprOpRightExpr(op, prec) {\\n    const startLoc = this.state.startLoc;\\n    switch (op) {\\n      case 39:\\n        switch (this.getPluginOption(\\\"pipelineOperator\\\", \\\"proposal\\\")) {\\n          case \\\"hack\\\":\\n            return this.withTopicBindingContext(() => {\\n              return this.parseHackPipeBody();\\n            });\\n          case \\\"smart\\\":\\n            return this.withTopicBindingContext(() => {\\n              if (this.prodParam.hasYield && this.isContextual(108)) {\\n                throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\\n              }\\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\\n            });\\n          case \\\"fsharp\\\":\\n            return this.withSoloAwaitPermittingContext(() => {\\n              return this.parseFSharpPipelineBody(prec);\\n            });\\n        }\\n      default:\\n        return this.parseExprOpBaseRightExpr(op, prec);\\n    }\\n  }\\n  parseExprOpBaseRightExpr(op, prec) {\\n    const startLoc = this.state.startLoc;\\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\\n  }\\n  parseHackPipeBody() {\\n    var _body$extra;\\n    const {\\n      startLoc\\n    } = this.state;\\n    const body = this.parseMaybeAssign();\\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\\n        type: body.type\\n      });\\n    }\\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\\n      this.raise(Errors.PipeTopicUnused, startLoc);\\n    }\\n    return body;\\n  }\\n  checkExponentialAfterUnary(node) {\\n    if (this.match(57)) {\\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\\n    }\\n  }\\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\\n    const startLoc = this.state.startLoc;\\n    const isAwait = this.isContextual(96);\\n    if (isAwait && this.isAwaitAllowed()) {\\n      this.next();\\n      const expr = this.parseAwait(startLoc);\\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\\n      return expr;\\n    }\\n    const update = this.match(34);\\n    const node = this.startNode();\\n    if (tokenIsPrefix(this.state.type)) {\\n      node.operator = this.state.value;\\n      node.prefix = true;\\n      if (this.match(72)) {\\n        this.expectPlugin(\\\"throwExpressions\\\");\\n      }\\n      const isDelete = this.match(89);\\n      this.next();\\n      node.argument = this.parseMaybeUnary(null, true);\\n      this.checkExpressionErrors(refExpressionErrors, true);\\n      if (this.state.strict && isDelete) {\\n        const arg = node.argument;\\n        if (arg.type === \\\"Identifier\\\") {\\n          this.raise(Errors.StrictDelete, node);\\n        } else if (this.hasPropertyAsPrivateName(arg)) {\\n          this.raise(Errors.DeletePrivateField, node);\\n        }\\n      }\\n      if (!update) {\\n        if (!sawUnary) {\\n          this.checkExponentialAfterUnary(node);\\n        }\\n        return this.finishNode(node, \\\"UnaryExpression\\\");\\n      }\\n    }\\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\\n    if (isAwait) {\\n      const {\\n        type\\n      } = this.state;\\n      const startsExpr = this.hasPlugin(\\\"v8intrinsic\\\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\\n      if (startsExpr && !this.isAmbiguousAwait()) {\\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\\n        return this.parseAwait(startLoc);\\n      }\\n    }\\n    return expr;\\n  }\\n  parseUpdate(node, update, refExpressionErrors) {\\n    if (update) {\\n      const updateExpressionNode = node;\\n      this.checkLVal(updateExpressionNode.argument, {\\n        in: this.finishNode(updateExpressionNode, \\\"UpdateExpression\\\")\\n      });\\n      return node;\\n    }\\n    const startLoc = this.state.startLoc;\\n    let expr = this.parseExprSubscripts(refExpressionErrors);\\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\\n      const node = this.startNodeAt(startLoc);\\n      node.operator = this.state.value;\\n      node.prefix = false;\\n      node.argument = expr;\\n      this.next();\\n      this.checkLVal(expr, {\\n        in: expr = this.finishNode(node, \\\"UpdateExpression\\\")\\n      });\\n    }\\n    return expr;\\n  }\\n  parseExprSubscripts(refExpressionErrors) {\\n    const startLoc = this.state.startLoc;\\n    const potentialArrowAt = this.state.potentialArrowAt;\\n    const expr = this.parseExprAtom(refExpressionErrors);\\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\\n      return expr;\\n    }\\n    return this.parseSubscripts(expr, startLoc);\\n  }\\n  parseSubscripts(base, startLoc, noCalls) {\\n    const state = {\\n      optionalChainMember: false,\\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\\n      stop: false\\n    };\\n    do {\\n      base = this.parseSubscript(base, startLoc, noCalls, state);\\n      state.maybeAsyncArrow = false;\\n    } while (!state.stop);\\n    return base;\\n  }\\n  parseSubscript(base, startLoc, noCalls, state) {\\n    const {\\n      type\\n    } = this.state;\\n    if (!noCalls && type === 15) {\\n      return this.parseBind(base, startLoc, noCalls, state);\\n    } else if (tokenIsTemplate(type)) {\\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\\n    }\\n    let optional = false;\\n    if (type === 18) {\\n      if (noCalls) {\\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\\n        if (this.lookaheadCharCode() === 40) {\\n          state.stop = true;\\n          return base;\\n        }\\n      }\\n      state.optionalChainMember = optional = true;\\n      this.next();\\n    }\\n    if (!noCalls && this.match(10)) {\\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\\n    } else {\\n      const computed = this.eat(0);\\n      if (computed || optional || this.eat(16)) {\\n        return this.parseMember(base, startLoc, state, computed, optional);\\n      } else {\\n        state.stop = true;\\n        return base;\\n      }\\n    }\\n  }\\n  parseMember(base, startLoc, state, computed, optional) {\\n    const node = this.startNodeAt(startLoc);\\n    node.object = base;\\n    node.computed = computed;\\n    if (computed) {\\n      node.property = this.parseExpression();\\n      this.expect(3);\\n    } else if (this.match(138)) {\\n      if (base.type === \\\"Super\\\") {\\n        this.raise(Errors.SuperPrivateField, startLoc);\\n      }\\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\\n      node.property = this.parsePrivateName();\\n    } else {\\n      node.property = this.parseIdentifier(true);\\n    }\\n    if (state.optionalChainMember) {\\n      node.optional = optional;\\n      return this.finishNode(node, \\\"OptionalMemberExpression\\\");\\n    } else {\\n      return this.finishNode(node, \\\"MemberExpression\\\");\\n    }\\n  }\\n  parseBind(base, startLoc, noCalls, state) {\\n    const node = this.startNodeAt(startLoc);\\n    node.object = base;\\n    this.next();\\n    node.callee = this.parseNoCallExpr();\\n    state.stop = true;\\n    return this.parseSubscripts(this.finishNode(node, \\\"BindExpression\\\"), startLoc, noCalls);\\n  }\\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\\n    let refExpressionErrors = null;\\n    this.state.maybeInArrowParameters = true;\\n    this.next();\\n    const node = this.startNodeAt(startLoc);\\n    node.callee = base;\\n    const {\\n      maybeAsyncArrow,\\n      optionalChainMember\\n    } = state;\\n    if (maybeAsyncArrow) {\\n      this.expressionScope.enter(newAsyncArrowScope());\\n      refExpressionErrors = new ExpressionErrors();\\n    }\\n    if (optionalChainMember) {\\n      node.optional = optional;\\n    }\\n    if (optional) {\\n      node.arguments = this.parseCallExpressionArguments(11);\\n    } else {\\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \\\"Import\\\", base.type !== \\\"Super\\\", node, refExpressionErrors);\\n    }\\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\\n      state.stop = true;\\n      this.checkDestructuringPrivate(refExpressionErrors);\\n      this.expressionScope.validateAsPattern();\\n      this.expressionScope.exit();\\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\\n    } else {\\n      if (maybeAsyncArrow) {\\n        this.checkExpressionErrors(refExpressionErrors, true);\\n        this.expressionScope.exit();\\n      }\\n      this.toReferencedArguments(finishedNode);\\n    }\\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\\n    return finishedNode;\\n  }\\n  toReferencedArguments(node, isParenthesizedExpr) {\\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\\n  }\\n  parseTaggedTemplateExpression(base, startLoc, state) {\\n    const node = this.startNodeAt(startLoc);\\n    node.tag = base;\\n    node.quasi = this.parseTemplate(true);\\n    if (state.optionalChainMember) {\\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\\n    }\\n    return this.finishNode(node, \\\"TaggedTemplateExpression\\\");\\n  }\\n  atPossibleAsyncArrow(base) {\\n    return base.type === \\\"Identifier\\\" && base.name === \\\"async\\\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\\n  }\\n  expectImportAttributesPlugin() {\\n    if (!this.hasPlugin(\\\"importAssertions\\\")) {\\n      this.expectPlugin(\\\"importAttributes\\\");\\n    }\\n  }\\n  finishCallExpression(node, optional) {\\n    if (node.callee.type === \\\"Import\\\") {\\n      if (node.arguments.length === 2) {\\n        {\\n          if (!this.hasPlugin(\\\"moduleAttributes\\\")) {\\n            this.expectImportAttributesPlugin();\\n          }\\n        }\\n      }\\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\\n        this.raise(Errors.ImportCallArity, node, {\\n          maxArgumentCount: this.hasPlugin(\\\"importAttributes\\\") || this.hasPlugin(\\\"importAssertions\\\") || this.hasPlugin(\\\"moduleAttributes\\\") ? 2 : 1\\n        });\\n      } else {\\n        for (const arg of node.arguments) {\\n          if (arg.type === \\\"SpreadElement\\\") {\\n            this.raise(Errors.ImportCallSpreadArgument, arg);\\n          }\\n        }\\n      }\\n    }\\n    return this.finishNode(node, optional ? \\\"OptionalCallExpression\\\" : \\\"CallExpression\\\");\\n  }\\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\\n    const elts = [];\\n    let first = true;\\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\\n    this.state.inFSharpPipelineDirectBody = false;\\n    while (!this.eat(close)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        this.expect(12);\\n        if (this.match(close)) {\\n          if (dynamicImport && !this.hasPlugin(\\\"importAttributes\\\") && !this.hasPlugin(\\\"importAssertions\\\") && !this.hasPlugin(\\\"moduleAttributes\\\")) {\\n            this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);\\n          }\\n          if (nodeForExtra) {\\n            this.addTrailingCommaExtraToNode(nodeForExtra);\\n          }\\n          this.next();\\n          break;\\n        }\\n      }\\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\\n    }\\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\\n    return elts;\\n  }\\n  shouldParseAsyncArrow() {\\n    return this.match(19) && !this.canInsertSemicolon();\\n  }\\n  parseAsyncArrowFromCallExpression(node, call) {\\n    var _call$extra;\\n    this.resetPreviousNodeTrailingComments(call);\\n    this.expect(19);\\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\\n    if (call.innerComments) {\\n      setInnerComments(node, call.innerComments);\\n    }\\n    if (call.callee.trailingComments) {\\n      setInnerComments(node, call.callee.trailingComments);\\n    }\\n    return node;\\n  }\\n  parseNoCallExpr() {\\n    const startLoc = this.state.startLoc;\\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\\n  }\\n  parseExprAtom(refExpressionErrors) {\\n    let node;\\n    let decorators = null;\\n    const {\\n      type\\n    } = this.state;\\n    switch (type) {\\n      case 79:\\n        return this.parseSuper();\\n      case 83:\\n        node = this.startNode();\\n        this.next();\\n        if (this.match(16)) {\\n          return this.parseImportMetaProperty(node);\\n        }\\n        if (this.match(10)) {\\n          if (this.options.createImportExpressions) {\\n            return this.parseImportCall(node);\\n          } else {\\n            return this.finishNode(node, \\\"Import\\\");\\n          }\\n        } else {\\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\\n          return this.finishNode(node, \\\"Import\\\");\\n        }\\n      case 78:\\n        node = this.startNode();\\n        this.next();\\n        return this.finishNode(node, \\\"ThisExpression\\\");\\n      case 90:\\n        {\\n          return this.parseDo(this.startNode(), false);\\n        }\\n      case 56:\\n      case 31:\\n        {\\n          this.readRegexp();\\n          return this.parseRegExpLiteral(this.state.value);\\n        }\\n      case 134:\\n        return this.parseNumericLiteral(this.state.value);\\n      case 135:\\n        return this.parseBigIntLiteral(this.state.value);\\n      case 136:\\n        return this.parseDecimalLiteral(this.state.value);\\n      case 133:\\n        return this.parseStringLiteral(this.state.value);\\n      case 84:\\n        return this.parseNullLiteral();\\n      case 85:\\n        return this.parseBooleanLiteral(true);\\n      case 86:\\n        return this.parseBooleanLiteral(false);\\n      case 10:\\n        {\\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\\n          return this.parseParenAndDistinguishExpression(canBeArrow);\\n        }\\n      case 2:\\n      case 1:\\n        {\\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\\n        }\\n      case 0:\\n        {\\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\\n        }\\n      case 6:\\n      case 7:\\n        {\\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\\n        }\\n      case 5:\\n        {\\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\\n        }\\n      case 68:\\n        return this.parseFunctionOrFunctionSent();\\n      case 26:\\n        decorators = this.parseDecorators();\\n      case 80:\\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\\n      case 77:\\n        return this.parseNewOrNewTarget();\\n      case 25:\\n      case 24:\\n        return this.parseTemplate(false);\\n      case 15:\\n        {\\n          node = this.startNode();\\n          this.next();\\n          node.object = null;\\n          const callee = node.callee = this.parseNoCallExpr();\\n          if (callee.type === \\\"MemberExpression\\\") {\\n            return this.finishNode(node, \\\"BindExpression\\\");\\n          } else {\\n            throw this.raise(Errors.UnsupportedBind, callee);\\n          }\\n        }\\n      case 138:\\n        {\\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\\n            identifierName: this.state.value\\n          });\\n          return this.parsePrivateName();\\n        }\\n      case 33:\\n        {\\n          return this.parseTopicReferenceThenEqualsSign(54, \\\"%\\\");\\n        }\\n      case 32:\\n        {\\n          return this.parseTopicReferenceThenEqualsSign(44, \\\"^\\\");\\n        }\\n      case 37:\\n      case 38:\\n        {\\n          return this.parseTopicReference(\\\"hack\\\");\\n        }\\n      case 44:\\n      case 54:\\n      case 27:\\n        {\\n          const pipeProposal = this.getPluginOption(\\\"pipelineOperator\\\", \\\"proposal\\\");\\n          if (pipeProposal) {\\n            return this.parseTopicReference(pipeProposal);\\n          }\\n          this.unexpected();\\n          break;\\n        }\\n      case 47:\\n        {\\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\\n            this.expectOnePlugin([\\\"jsx\\\", \\\"flow\\\", \\\"typescript\\\"]);\\n          } else {\\n            this.unexpected();\\n          }\\n          break;\\n        }\\n      default:\\n        if (tokenIsIdentifier(type)) {\\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\\n            return this.parseModuleExpression();\\n          }\\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\\n          const containsEsc = this.state.containsEsc;\\n          const id = this.parseIdentifier();\\n          if (!containsEsc && id.name === \\\"async\\\" && !this.canInsertSemicolon()) {\\n            const {\\n              type\\n            } = this.state;\\n            if (type === 68) {\\n              this.resetPreviousNodeTrailingComments(id);\\n              this.next();\\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\\n            } else if (tokenIsIdentifier(type)) {\\n              if (this.lookaheadCharCode() === 61) {\\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\\n              } else {\\n                return id;\\n              }\\n            } else if (type === 90) {\\n              this.resetPreviousNodeTrailingComments(id);\\n              return this.parseDo(this.startNodeAtNode(id), true);\\n            }\\n          }\\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\\n            this.next();\\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\\n          }\\n          return id;\\n        } else {\\n          this.unexpected();\\n        }\\n    }\\n  }\\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\\n    const pipeProposal = this.getPluginOption(\\\"pipelineOperator\\\", \\\"proposal\\\");\\n    if (pipeProposal) {\\n      this.state.type = topicTokenType;\\n      this.state.value = topicTokenValue;\\n      this.state.pos--;\\n      this.state.end--;\\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\\n      return this.parseTopicReference(pipeProposal);\\n    } else {\\n      this.unexpected();\\n    }\\n  }\\n  parseTopicReference(pipeProposal) {\\n    const node = this.startNode();\\n    const startLoc = this.state.startLoc;\\n    const tokenType = this.state.type;\\n    this.next();\\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\\n  }\\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\\n      const nodeType = pipeProposal === \\\"smart\\\" ? \\\"PipelinePrimaryTopicReference\\\" : \\\"TopicReference\\\";\\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\\n        this.raise(pipeProposal === \\\"smart\\\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);\\n      }\\n      this.registerTopicReference();\\n      return this.finishNode(node, nodeType);\\n    } else {\\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\\n        token: tokenLabelName(tokenType)\\n      });\\n    }\\n  }\\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\\n    switch (pipeProposal) {\\n      case \\\"hack\\\":\\n        {\\n          return this.hasPlugin([\\\"pipelineOperator\\\", {\\n            topicToken: tokenLabelName(tokenType)\\n          }]);\\n        }\\n      case \\\"smart\\\":\\n        return tokenType === 27;\\n      default:\\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\\n    }\\n  }\\n  parseAsyncArrowUnaryFunction(node) {\\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\\n    const params = [this.parseIdentifier()];\\n    this.prodParam.exit();\\n    if (this.hasPrecedingLineBreak()) {\\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\\n    }\\n    this.expect(19);\\n    return this.parseArrowExpression(node, params, true);\\n  }\\n  parseDo(node, isAsync) {\\n    this.expectPlugin(\\\"doExpressions\\\");\\n    if (isAsync) {\\n      this.expectPlugin(\\\"asyncDoExpressions\\\");\\n    }\\n    node.async = isAsync;\\n    this.next();\\n    const oldLabels = this.state.labels;\\n    this.state.labels = [];\\n    if (isAsync) {\\n      this.prodParam.enter(2);\\n      node.body = this.parseBlock();\\n      this.prodParam.exit();\\n    } else {\\n      node.body = this.parseBlock();\\n    }\\n    this.state.labels = oldLabels;\\n    return this.finishNode(node, \\\"DoExpression\\\");\\n  }\\n  parseSuper() {\\n    const node = this.startNode();\\n    this.next();\\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\\n      this.raise(Errors.SuperNotAllowed, node);\\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\\n      this.raise(Errors.UnexpectedSuper, node);\\n    }\\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\\n      this.raise(Errors.UnsupportedSuper, node);\\n    }\\n    return this.finishNode(node, \\\"Super\\\");\\n  }\\n  parsePrivateName() {\\n    const node = this.startNode();\\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\\n    const name = this.state.value;\\n    this.next();\\n    node.id = this.createIdentifier(id, name);\\n    return this.finishNode(node, \\\"PrivateName\\\");\\n  }\\n  parseFunctionOrFunctionSent() {\\n    const node = this.startNode();\\n    this.next();\\n    if (this.prodParam.hasYield && this.match(16)) {\\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \\\"function\\\");\\n      this.next();\\n      if (this.match(103)) {\\n        this.expectPlugin(\\\"functionSent\\\");\\n      } else if (!this.hasPlugin(\\\"functionSent\\\")) {\\n        this.unexpected();\\n      }\\n      return this.parseMetaProperty(node, meta, \\\"sent\\\");\\n    }\\n    return this.parseFunction(node);\\n  }\\n  parseMetaProperty(node, meta, propertyName) {\\n    node.meta = meta;\\n    const containsEsc = this.state.containsEsc;\\n    node.property = this.parseIdentifier(true);\\n    if (node.property.name !== propertyName || containsEsc) {\\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\\n        target: meta.name,\\n        onlyValidPropertyName: propertyName\\n      });\\n    }\\n    return this.finishNode(node, \\\"MetaProperty\\\");\\n  }\\n  parseImportMetaProperty(node) {\\n    const id = this.createIdentifier(this.startNodeAtNode(node), \\\"import\\\");\\n    this.next();\\n    if (this.isContextual(101)) {\\n      if (!this.inModule) {\\n        this.raise(Errors.ImportMetaOutsideModule, id);\\n      }\\n      this.sawUnambiguousESM = true;\\n    } else if (this.isContextual(105) || this.isContextual(97)) {\\n      const isSource = this.isContextual(105);\\n      if (!isSource) this.unexpected();\\n      this.expectPlugin(isSource ? \\\"sourcePhaseImports\\\" : \\\"deferredImportEvaluation\\\");\\n      if (!this.options.createImportExpressions) {\\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {\\n          phase: this.state.value\\n        });\\n      }\\n      this.next();\\n      node.phase = isSource ? \\\"source\\\" : \\\"defer\\\";\\n      return this.parseImportCall(node);\\n    }\\n    return this.parseMetaProperty(node, id, \\\"meta\\\");\\n  }\\n  parseLiteralAtNode(value, type, node) {\\n    this.addExtra(node, \\\"rawValue\\\", value);\\n    this.addExtra(node, \\\"raw\\\", this.input.slice(node.start, this.state.end));\\n    node.value = value;\\n    this.next();\\n    return this.finishNode(node, type);\\n  }\\n  parseLiteral(value, type) {\\n    const node = this.startNode();\\n    return this.parseLiteralAtNode(value, type, node);\\n  }\\n  parseStringLiteral(value) {\\n    return this.parseLiteral(value, \\\"StringLiteral\\\");\\n  }\\n  parseNumericLiteral(value) {\\n    return this.parseLiteral(value, \\\"NumericLiteral\\\");\\n  }\\n  parseBigIntLiteral(value) {\\n    return this.parseLiteral(value, \\\"BigIntLiteral\\\");\\n  }\\n  parseDecimalLiteral(value) {\\n    return this.parseLiteral(value, \\\"DecimalLiteral\\\");\\n  }\\n  parseRegExpLiteral(value) {\\n    const node = this.parseLiteral(value.value, \\\"RegExpLiteral\\\");\\n    node.pattern = value.pattern;\\n    node.flags = value.flags;\\n    return node;\\n  }\\n  parseBooleanLiteral(value) {\\n    const node = this.startNode();\\n    node.value = value;\\n    this.next();\\n    return this.finishNode(node, \\\"BooleanLiteral\\\");\\n  }\\n  parseNullLiteral() {\\n    const node = this.startNode();\\n    this.next();\\n    return this.finishNode(node, \\\"NullLiteral\\\");\\n  }\\n  parseParenAndDistinguishExpression(canBeArrow) {\\n    const startLoc = this.state.startLoc;\\n    let val;\\n    this.next();\\n    this.expressionScope.enter(newArrowHeadScope());\\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\\n    this.state.maybeInArrowParameters = true;\\n    this.state.inFSharpPipelineDirectBody = false;\\n    const innerStartLoc = this.state.startLoc;\\n    const exprList = [];\\n    const refExpressionErrors = new ExpressionErrors();\\n    let first = true;\\n    let spreadStartLoc;\\n    let optionalCommaStartLoc;\\n    while (!this.match(11)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\\n        if (this.match(11)) {\\n          optionalCommaStartLoc = this.state.startLoc;\\n          break;\\n        }\\n      }\\n      if (this.match(21)) {\\n        const spreadNodeStartLoc = this.state.startLoc;\\n        spreadStartLoc = this.state.startLoc;\\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\\n        if (!this.checkCommaAfterRest(41)) {\\n          break;\\n        }\\n      } else {\\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\\n      }\\n    }\\n    const innerEndLoc = this.state.lastTokEndLoc;\\n    this.expect(11);\\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\\n    let arrowNode = this.startNodeAt(startLoc);\\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\\n      this.checkDestructuringPrivate(refExpressionErrors);\\n      this.expressionScope.validateAsPattern();\\n      this.expressionScope.exit();\\n      this.parseArrowExpression(arrowNode, exprList, false);\\n      return arrowNode;\\n    }\\n    this.expressionScope.exit();\\n    if (!exprList.length) {\\n      this.unexpected(this.state.lastTokStartLoc);\\n    }\\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\\n    this.checkExpressionErrors(refExpressionErrors, true);\\n    this.toReferencedListDeep(exprList, true);\\n    if (exprList.length > 1) {\\n      val = this.startNodeAt(innerStartLoc);\\n      val.expressions = exprList;\\n      this.finishNode(val, \\\"SequenceExpression\\\");\\n      this.resetEndLocation(val, innerEndLoc);\\n    } else {\\n      val = exprList[0];\\n    }\\n    return this.wrapParenthesis(startLoc, val);\\n  }\\n  wrapParenthesis(startLoc, expression) {\\n    if (!this.options.createParenthesizedExpressions) {\\n      this.addExtra(expression, \\\"parenthesized\\\", true);\\n      this.addExtra(expression, \\\"parenStart\\\", startLoc.index);\\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\\n      return expression;\\n    }\\n    const parenExpression = this.startNodeAt(startLoc);\\n    parenExpression.expression = expression;\\n    return this.finishNode(parenExpression, \\\"ParenthesizedExpression\\\");\\n  }\\n  shouldParseArrow(params) {\\n    return !this.canInsertSemicolon();\\n  }\\n  parseArrow(node) {\\n    if (this.eat(19)) {\\n      return node;\\n    }\\n  }\\n  parseParenItem(node, startLoc) {\\n    return node;\\n  }\\n  parseNewOrNewTarget() {\\n    const node = this.startNode();\\n    this.next();\\n    if (this.match(16)) {\\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \\\"new\\\");\\n      this.next();\\n      const metaProp = this.parseMetaProperty(node, meta, \\\"target\\\");\\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {\\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\\n      }\\n      return metaProp;\\n    }\\n    return this.parseNew(node);\\n  }\\n  parseNew(node) {\\n    this.parseNewCallee(node);\\n    if (this.eat(10)) {\\n      const args = this.parseExprList(11);\\n      this.toReferencedList(args);\\n      node.arguments = args;\\n    } else {\\n      node.arguments = [];\\n    }\\n    return this.finishNode(node, \\\"NewExpression\\\");\\n  }\\n  parseNewCallee(node) {\\n    const isImport = this.match(83);\\n    const callee = this.parseNoCallExpr();\\n    node.callee = callee;\\n    if (isImport && (callee.type === \\\"Import\\\" || callee.type === \\\"ImportExpression\\\")) {\\n      this.raise(Errors.ImportCallNotNewExpression, callee);\\n    }\\n  }\\n  parseTemplateElement(isTagged) {\\n    const {\\n      start,\\n      startLoc,\\n      end,\\n      value\\n    } = this.state;\\n    const elemStart = start + 1;\\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\\n    if (value === null) {\\n      if (!isTagged) {\\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\\n      }\\n    }\\n    const isTail = this.match(24);\\n    const endOffset = isTail ? -1 : -2;\\n    const elemEnd = end + endOffset;\\n    elem.value = {\\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\\\r\\\\n?/g, \\\"\\\\n\\\"),\\n      cooked: value === null ? null : value.slice(1, endOffset)\\n    };\\n    elem.tail = isTail;\\n    this.next();\\n    const finishedNode = this.finishNode(elem, \\\"TemplateElement\\\");\\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\\n    return finishedNode;\\n  }\\n  parseTemplate(isTagged) {\\n    const node = this.startNode();\\n    node.expressions = [];\\n    let curElt = this.parseTemplateElement(isTagged);\\n    node.quasis = [curElt];\\n    while (!curElt.tail) {\\n      node.expressions.push(this.parseTemplateSubstitution());\\n      this.readTemplateContinuation();\\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\\n    }\\n    return this.finishNode(node, \\\"TemplateLiteral\\\");\\n  }\\n  parseTemplateSubstitution() {\\n    return this.parseExpression();\\n  }\\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\\n    if (isRecord) {\\n      this.expectPlugin(\\\"recordAndTuple\\\");\\n    }\\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\\n    this.state.inFSharpPipelineDirectBody = false;\\n    const propHash = Object.create(null);\\n    let first = true;\\n    const node = this.startNode();\\n    node.properties = [];\\n    this.next();\\n    while (!this.match(close)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        this.expect(12);\\n        if (this.match(close)) {\\n          this.addTrailingCommaExtraToNode(node);\\n          break;\\n        }\\n      }\\n      let prop;\\n      if (isPattern) {\\n        prop = this.parseBindingProperty();\\n      } else {\\n        prop = this.parsePropertyDefinition(refExpressionErrors);\\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\\n      }\\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \\\"SpreadElement\\\") {\\n        this.raise(Errors.InvalidRecordProperty, prop);\\n      }\\n      if (prop.shorthand) {\\n        this.addExtra(prop, \\\"shorthand\\\", true);\\n      }\\n      node.properties.push(prop);\\n    }\\n    this.next();\\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\\n    let type = \\\"ObjectExpression\\\";\\n    if (isPattern) {\\n      type = \\\"ObjectPattern\\\";\\n    } else if (isRecord) {\\n      type = \\\"RecordExpression\\\";\\n    }\\n    return this.finishNode(node, type);\\n  }\\n  addTrailingCommaExtraToNode(node) {\\n    this.addExtra(node, \\\"trailingComma\\\", this.state.lastTokStartLoc.index);\\n    this.addExtra(node, \\\"trailingCommaLoc\\\", this.state.lastTokStartLoc, false);\\n  }\\n  maybeAsyncOrAccessorProp(prop) {\\n    return !prop.computed && prop.key.type === \\\"Identifier\\\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\\n  }\\n  parsePropertyDefinition(refExpressionErrors) {\\n    let decorators = [];\\n    if (this.match(26)) {\\n      if (this.hasPlugin(\\\"decorators\\\")) {\\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\\n      }\\n      while (this.match(26)) {\\n        decorators.push(this.parseDecorator());\\n      }\\n    }\\n    const prop = this.startNode();\\n    let isAsync = false;\\n    let isAccessor = false;\\n    let startLoc;\\n    if (this.match(21)) {\\n      if (decorators.length) this.unexpected();\\n      return this.parseSpread();\\n    }\\n    if (decorators.length) {\\n      prop.decorators = decorators;\\n      decorators = [];\\n    }\\n    prop.method = false;\\n    if (refExpressionErrors) {\\n      startLoc = this.state.startLoc;\\n    }\\n    let isGenerator = this.eat(55);\\n    this.parsePropertyNamePrefixOperator(prop);\\n    const containsEsc = this.state.containsEsc;\\n    const key = this.parsePropertyName(prop, refExpressionErrors);\\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\\n      const keyName = key.name;\\n      if (keyName === \\\"async\\\" && !this.hasPrecedingLineBreak()) {\\n        isAsync = true;\\n        this.resetPreviousNodeTrailingComments(key);\\n        isGenerator = this.eat(55);\\n        this.parsePropertyName(prop);\\n      }\\n      if (keyName === \\\"get\\\" || keyName === \\\"set\\\") {\\n        isAccessor = true;\\n        this.resetPreviousNodeTrailingComments(key);\\n        prop.kind = keyName;\\n        if (this.match(55)) {\\n          isGenerator = true;\\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\\n            kind: keyName\\n          });\\n          this.next();\\n        }\\n        this.parsePropertyName(prop);\\n      }\\n    }\\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\\n  }\\n  getGetterSetterExpectedParamCount(method) {\\n    return method.kind === \\\"get\\\" ? 0 : 1;\\n  }\\n  getObjectOrClassMethodParams(method) {\\n    return method.params;\\n  }\\n  checkGetterSetterParams(method) {\\n    var _params;\\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\\n    const params = this.getObjectOrClassMethodParams(method);\\n    if (params.length !== paramCount) {\\n      this.raise(method.kind === \\\"get\\\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\\n    }\\n    if (method.kind === \\\"set\\\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \\\"RestElement\\\") {\\n      this.raise(Errors.BadSetterRestParameter, method);\\n    }\\n  }\\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\\n    if (isAccessor) {\\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \\\"ObjectMethod\\\");\\n      this.checkGetterSetterParams(finishedProp);\\n      return finishedProp;\\n    }\\n    if (isAsync || isGenerator || this.match(10)) {\\n      if (isPattern) this.unexpected();\\n      prop.kind = \\\"method\\\";\\n      prop.method = true;\\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \\\"ObjectMethod\\\");\\n    }\\n  }\\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\\n    prop.shorthand = false;\\n    if (this.eat(14)) {\\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\\n      return this.finishNode(prop, \\\"ObjectProperty\\\");\\n    }\\n    if (!prop.computed && prop.key.type === \\\"Identifier\\\") {\\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\\n      if (isPattern) {\\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\\n      } else if (this.match(29)) {\\n        const shorthandAssignLoc = this.state.startLoc;\\n        if (refExpressionErrors != null) {\\n          if (refExpressionErrors.shorthandAssignLoc === null) {\\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\\n          }\\n        } else {\\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\\n        }\\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\\n      } else {\\n        prop.value = cloneIdentifier(prop.key);\\n      }\\n      prop.shorthand = true;\\n      return this.finishNode(prop, \\\"ObjectProperty\\\");\\n    }\\n  }\\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\\n    if (!node) this.unexpected();\\n    return node;\\n  }\\n  parsePropertyName(prop, refExpressionErrors) {\\n    if (this.eat(0)) {\\n      prop.computed = true;\\n      prop.key = this.parseMaybeAssignAllowIn();\\n      this.expect(3);\\n    } else {\\n      const {\\n        type,\\n        value\\n      } = this.state;\\n      let key;\\n      if (tokenIsKeywordOrIdentifier(type)) {\\n        key = this.parseIdentifier(true);\\n      } else {\\n        switch (type) {\\n          case 134:\\n            key = this.parseNumericLiteral(value);\\n            break;\\n          case 133:\\n            key = this.parseStringLiteral(value);\\n            break;\\n          case 135:\\n            key = this.parseBigIntLiteral(value);\\n            break;\\n          case 136:\\n            key = this.parseDecimalLiteral(value);\\n            break;\\n          case 138:\\n            {\\n              const privateKeyLoc = this.state.startLoc;\\n              if (refExpressionErrors != null) {\\n                if (refExpressionErrors.privateKeyLoc === null) {\\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\\n                }\\n              } else {\\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\\n              }\\n              key = this.parsePrivateName();\\n              break;\\n            }\\n          default:\\n            this.unexpected();\\n        }\\n      }\\n      prop.key = key;\\n      if (type !== 138) {\\n        prop.computed = false;\\n      }\\n    }\\n    return prop.key;\\n  }\\n  initFunction(node, isAsync) {\\n    node.id = null;\\n    node.generator = false;\\n    node.async = isAsync;\\n  }\\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\\n    this.initFunction(node, isAsync);\\n    node.generator = isGenerator;\\n    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));\\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\\n    this.parseFunctionParams(node, isConstructor);\\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\\n    this.prodParam.exit();\\n    this.scope.exit();\\n    return finishedNode;\\n  }\\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\\n    if (isTuple) {\\n      this.expectPlugin(\\\"recordAndTuple\\\");\\n    }\\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\\n    this.state.inFSharpPipelineDirectBody = false;\\n    const node = this.startNode();\\n    this.next();\\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\\n    return this.finishNode(node, isTuple ? \\\"TupleExpression\\\" : \\\"ArrayExpression\\\");\\n  }\\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\\n    this.scope.enter(2 | 4);\\n    let flags = functionFlags(isAsync, false);\\n    if (!this.match(5) && this.prodParam.hasIn) {\\n      flags |= 8;\\n    }\\n    this.prodParam.enter(flags);\\n    this.initFunction(node, isAsync);\\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\\n    if (params) {\\n      this.state.maybeInArrowParameters = true;\\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\\n    }\\n    this.state.maybeInArrowParameters = false;\\n    this.parseFunctionBody(node, true);\\n    this.prodParam.exit();\\n    this.scope.exit();\\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\\n    return this.finishNode(node, \\\"ArrowFunctionExpression\\\");\\n  }\\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\\n    this.toAssignableList(params, trailingCommaLoc, false);\\n    node.params = params;\\n  }\\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\\n    this.parseFunctionBody(node, false, isMethod);\\n    return this.finishNode(node, type);\\n  }\\n  parseFunctionBody(node, allowExpression, isMethod = false) {\\n    const isExpression = allowExpression && !this.match(5);\\n    this.expressionScope.enter(newExpressionScope());\\n    if (isExpression) {\\n      node.body = this.parseMaybeAssign();\\n      this.checkParams(node, false, allowExpression, false);\\n    } else {\\n      const oldStrict = this.state.strict;\\n      const oldLabels = this.state.labels;\\n      this.state.labels = [];\\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\\n        const nonSimple = !this.isSimpleParamList(node.params);\\n        if (hasStrictModeDirective && nonSimple) {\\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \\\"method\\\" || node.kind === \\\"constructor\\\") && !!node.key ? node.key.loc.end : node);\\n        }\\n        const strictModeChanged = !oldStrict && this.state.strict;\\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\\n        if (this.state.strict && node.id) {\\n          this.checkIdentifier(node.id, 65, strictModeChanged);\\n        }\\n      });\\n      this.prodParam.exit();\\n      this.state.labels = oldLabels;\\n    }\\n    this.expressionScope.exit();\\n  }\\n  isSimpleParameter(node) {\\n    return node.type === \\\"Identifier\\\";\\n  }\\n  isSimpleParamList(params) {\\n    for (let i = 0, len = params.length; i < len; i++) {\\n      if (!this.isSimpleParameter(params[i])) return false;\\n    }\\n    return true;\\n  }\\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\\n    const checkClashes = !allowDuplicates && new Set();\\n    const formalParameters = {\\n      type: \\\"FormalParameters\\\"\\n    };\\n    for (const param of node.params) {\\n      this.checkLVal(param, {\\n        in: formalParameters,\\n        binding: 5,\\n        checkClashes,\\n        strictModeChanged\\n      });\\n    }\\n  }\\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\\n    const elts = [];\\n    let first = true;\\n    while (!this.eat(close)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        this.expect(12);\\n        if (this.match(close)) {\\n          if (nodeForExtra) {\\n            this.addTrailingCommaExtraToNode(nodeForExtra);\\n          }\\n          this.next();\\n          break;\\n        }\\n      }\\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\\n    }\\n    return elts;\\n  }\\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\\n    let elt;\\n    if (this.match(12)) {\\n      if (!allowEmpty) {\\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\\n          unexpected: \\\",\\\"\\n        });\\n      }\\n      elt = null;\\n    } else if (this.match(21)) {\\n      const spreadNodeStartLoc = this.state.startLoc;\\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\\n    } else if (this.match(17)) {\\n      this.expectPlugin(\\\"partialApplication\\\");\\n      if (!allowPlaceholder) {\\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\\n      }\\n      const node = this.startNode();\\n      this.next();\\n      elt = this.finishNode(node, \\\"ArgumentPlaceholder\\\");\\n    } else {\\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\\n    }\\n    return elt;\\n  }\\n  parseIdentifier(liberal) {\\n    const node = this.startNode();\\n    const name = this.parseIdentifierName(liberal);\\n    return this.createIdentifier(node, name);\\n  }\\n  createIdentifier(node, name) {\\n    node.name = name;\\n    node.loc.identifierName = name;\\n    return this.finishNode(node, \\\"Identifier\\\");\\n  }\\n  parseIdentifierName(liberal) {\\n    let name;\\n    const {\\n      startLoc,\\n      type\\n    } = this.state;\\n    if (tokenIsKeywordOrIdentifier(type)) {\\n      name = this.state.value;\\n    } else {\\n      this.unexpected();\\n    }\\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\\n    if (liberal) {\\n      if (tokenIsKeyword) {\\n        this.replaceToken(132);\\n      }\\n    } else {\\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\\n    }\\n    this.next();\\n    return name;\\n  }\\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\\n    if (word.length > 10) {\\n      return;\\n    }\\n    if (!canBeReservedWord(word)) {\\n      return;\\n    }\\n    if (checkKeywords && isKeyword(word)) {\\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\\n        keyword: word\\n      });\\n      return;\\n    }\\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\\n    if (reservedTest(word, this.inModule)) {\\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\\n        reservedWord: word\\n      });\\n      return;\\n    } else if (word === \\\"yield\\\") {\\n      if (this.prodParam.hasYield) {\\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\\n        return;\\n      }\\n    } else if (word === \\\"await\\\") {\\n      if (this.prodParam.hasAwait) {\\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\\n        return;\\n      }\\n      if (this.scope.inStaticBlock) {\\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\\n        return;\\n      }\\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\\n    } else if (word === \\\"arguments\\\") {\\n      if (this.scope.inClassAndNotInNonArrowFunction) {\\n        this.raise(Errors.ArgumentsInClass, startLoc);\\n        return;\\n      }\\n    }\\n  }\\n  isAwaitAllowed() {\\n    if (this.prodParam.hasAwait) return true;\\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\\n      return true;\\n    }\\n    return false;\\n  }\\n  parseAwait(startLoc) {\\n    const node = this.startNodeAt(startLoc);\\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\\n    if (this.eat(55)) {\\n      this.raise(Errors.ObsoleteAwaitStar, node);\\n    }\\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\\n      if (this.isAmbiguousAwait()) {\\n        this.ambiguousScriptDifferentAst = true;\\n      } else {\\n        this.sawUnambiguousESM = true;\\n      }\\n    }\\n    if (!this.state.soloAwait) {\\n      node.argument = this.parseMaybeUnary(null, true);\\n    }\\n    return this.finishNode(node, \\\"AwaitExpression\\\");\\n  }\\n  isAmbiguousAwait() {\\n    if (this.hasPrecedingLineBreak()) return true;\\n    const {\\n      type\\n    } = this.state;\\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin(\\\"v8intrinsic\\\") && type === 54;\\n  }\\n  parseYield() {\\n    const node = this.startNode();\\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\\n    this.next();\\n    let delegating = false;\\n    let argument = null;\\n    if (!this.hasPrecedingLineBreak()) {\\n      delegating = this.eat(55);\\n      switch (this.state.type) {\\n        case 13:\\n        case 139:\\n        case 8:\\n        case 11:\\n        case 3:\\n        case 9:\\n        case 14:\\n        case 12:\\n          if (!delegating) break;\\n        default:\\n          argument = this.parseMaybeAssign();\\n      }\\n    }\\n    node.delegate = delegating;\\n    node.argument = argument;\\n    return this.finishNode(node, \\\"YieldExpression\\\");\\n  }\\n  parseImportCall(node) {\\n    this.next();\\n    node.source = this.parseMaybeAssignAllowIn();\\n    if (this.hasPlugin(\\\"importAttributes\\\") || this.hasPlugin(\\\"importAssertions\\\")) {\\n      node.options = null;\\n    }\\n    if (this.eat(12)) {\\n      this.expectImportAttributesPlugin();\\n      if (!this.match(11)) {\\n        node.options = this.parseMaybeAssignAllowIn();\\n        this.eat(12);\\n      }\\n    }\\n    this.expect(11);\\n    return this.finishNode(node, \\\"ImportExpression\\\");\\n  }\\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\\n    if (this.hasPlugin([\\\"pipelineOperator\\\", {\\n      proposal: \\\"smart\\\"\\n    }])) {\\n      if (left.type === \\\"SequenceExpression\\\") {\\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\\n      }\\n    }\\n  }\\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\\n    if (this.isSimpleReference(childExpr)) {\\n      const bodyNode = this.startNodeAt(startLoc);\\n      bodyNode.callee = childExpr;\\n      return this.finishNode(bodyNode, \\\"PipelineBareFunction\\\");\\n    } else {\\n      const bodyNode = this.startNodeAt(startLoc);\\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\\n      bodyNode.expression = childExpr;\\n      return this.finishNode(bodyNode, \\\"PipelineTopicExpression\\\");\\n    }\\n  }\\n  isSimpleReference(expression) {\\n    switch (expression.type) {\\n      case \\\"MemberExpression\\\":\\n        return !expression.computed && this.isSimpleReference(expression.object);\\n      case \\\"Identifier\\\":\\n        return true;\\n      default:\\n        return false;\\n    }\\n  }\\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\\n    if (this.match(19)) {\\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\\n    }\\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\\n      this.raise(Errors.PipelineTopicUnused, startLoc);\\n    }\\n  }\\n  withTopicBindingContext(callback) {\\n    const outerContextTopicState = this.state.topicContext;\\n    this.state.topicContext = {\\n      maxNumOfResolvableTopics: 1,\\n      maxTopicIndex: null\\n    };\\n    try {\\n      return callback();\\n    } finally {\\n      this.state.topicContext = outerContextTopicState;\\n    }\\n  }\\n  withSmartMixTopicForbiddingContext(callback) {\\n    if (this.hasPlugin([\\\"pipelineOperator\\\", {\\n      proposal: \\\"smart\\\"\\n    }])) {\\n      const outerContextTopicState = this.state.topicContext;\\n      this.state.topicContext = {\\n        maxNumOfResolvableTopics: 0,\\n        maxTopicIndex: null\\n      };\\n      try {\\n        return callback();\\n      } finally {\\n        this.state.topicContext = outerContextTopicState;\\n      }\\n    } else {\\n      return callback();\\n    }\\n  }\\n  withSoloAwaitPermittingContext(callback) {\\n    const outerContextSoloAwaitState = this.state.soloAwait;\\n    this.state.soloAwait = true;\\n    try {\\n      return callback();\\n    } finally {\\n      this.state.soloAwait = outerContextSoloAwaitState;\\n    }\\n  }\\n  allowInAnd(callback) {\\n    const flags = this.prodParam.currentFlags();\\n    const prodParamToSet = 8 & ~flags;\\n    if (prodParamToSet) {\\n      this.prodParam.enter(flags | 8);\\n      try {\\n        return callback();\\n      } finally {\\n        this.prodParam.exit();\\n      }\\n    }\\n    return callback();\\n  }\\n  disallowInAnd(callback) {\\n    const flags = this.prodParam.currentFlags();\\n    const prodParamToClear = 8 & flags;\\n    if (prodParamToClear) {\\n      this.prodParam.enter(flags & ~8);\\n      try {\\n        return callback();\\n      } finally {\\n        this.prodParam.exit();\\n      }\\n    }\\n    return callback();\\n  }\\n  registerTopicReference() {\\n    this.state.topicContext.maxTopicIndex = 0;\\n  }\\n  topicReferenceIsAllowedInCurrentContext() {\\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\\n  }\\n  topicReferenceWasUsedInCurrentContext() {\\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\\n  }\\n  parseFSharpPipelineBody(prec) {\\n    const startLoc = this.state.startLoc;\\n    this.state.potentialArrowAt = this.state.start;\\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\\n    this.state.inFSharpPipelineDirectBody = true;\\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\\n    return ret;\\n  }\\n  parseModuleExpression() {\\n    this.expectPlugin(\\\"moduleBlocks\\\");\\n    const node = this.startNode();\\n    this.next();\\n    if (!this.match(5)) {\\n      this.unexpected(null, 5);\\n    }\\n    const program = this.startNodeAt(this.state.endLoc);\\n    this.next();\\n    const revertScopes = this.initializeScopes(true);\\n    this.enterInitialScopes();\\n    try {\\n      node.body = this.parseProgram(program, 8, \\\"module\\\");\\n    } finally {\\n      revertScopes();\\n    }\\n    return this.finishNode(node, \\\"ModuleExpression\\\");\\n  }\\n  parsePropertyNamePrefixOperator(prop) {}\\n}\\nconst loopLabel = {\\n    kind: 1\\n  },\\n  switchLabel = {\\n    kind: 2\\n  };\\nconst loneSurrogate = /[\\\\uD800-\\\\uDFFF]/u;\\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\\nfunction babel7CompatTokens(tokens, input) {\\n  for (let i = 0; i < tokens.length; i++) {\\n    const token = tokens[i];\\n    const {\\n      type\\n    } = token;\\n    if (typeof type === \\\"number\\\") {\\n      {\\n        if (type === 138) {\\n          const {\\n            loc,\\n            start,\\n            value,\\n            end\\n          } = token;\\n          const hashEndPos = start + 1;\\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\\n          tokens.splice(i, 1, new Token({\\n            type: getExportedToken(27),\\n            value: \\\"#\\\",\\n            start: start,\\n            end: hashEndPos,\\n            startLoc: loc.start,\\n            endLoc: hashEndLoc\\n          }), new Token({\\n            type: getExportedToken(132),\\n            value: value,\\n            start: hashEndPos,\\n            end: end,\\n            startLoc: hashEndLoc,\\n            endLoc: loc.end\\n          }));\\n          i++;\\n          continue;\\n        }\\n        if (tokenIsTemplate(type)) {\\n          const {\\n            loc,\\n            start,\\n            value,\\n            end\\n          } = token;\\n          const backquoteEnd = start + 1;\\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\\n          let startToken;\\n          if (input.charCodeAt(start) === 96) {\\n            startToken = new Token({\\n              type: getExportedToken(22),\\n              value: \\\"`\\\",\\n              start: start,\\n              end: backquoteEnd,\\n              startLoc: loc.start,\\n              endLoc: backquoteEndLoc\\n            });\\n          } else {\\n            startToken = new Token({\\n              type: getExportedToken(8),\\n              value: \\\"}\\\",\\n              start: start,\\n              end: backquoteEnd,\\n              startLoc: loc.start,\\n              endLoc: backquoteEndLoc\\n            });\\n          }\\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\\n          if (type === 24) {\\n            templateElementEnd = end - 1;\\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\\n            templateValue = value === null ? null : value.slice(1, -1);\\n            endToken = new Token({\\n              type: getExportedToken(22),\\n              value: \\\"`\\\",\\n              start: templateElementEnd,\\n              end: end,\\n              startLoc: templateElementEndLoc,\\n              endLoc: loc.end\\n            });\\n          } else {\\n            templateElementEnd = end - 2;\\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\\n            templateValue = value === null ? null : value.slice(1, -2);\\n            endToken = new Token({\\n              type: getExportedToken(23),\\n              value: \\\"${\\\",\\n              start: templateElementEnd,\\n              end: end,\\n              startLoc: templateElementEndLoc,\\n              endLoc: loc.end\\n            });\\n          }\\n          tokens.splice(i, 1, startToken, new Token({\\n            type: getExportedToken(20),\\n            value: templateValue,\\n            start: backquoteEnd,\\n            end: templateElementEnd,\\n            startLoc: backquoteEndLoc,\\n            endLoc: templateElementEndLoc\\n          }), endToken);\\n          i += 2;\\n          continue;\\n        }\\n      }\\n      token.type = getExportedToken(type);\\n    }\\n  }\\n  return tokens;\\n}\\nclass StatementParser extends ExpressionParser {\\n  parseTopLevel(file, program) {\\n    file.program = this.parseProgram(program);\\n    file.comments = this.comments;\\n    if (this.options.tokens) {\\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\\n    }\\n    return this.finishNode(file, \\\"File\\\");\\n  }\\n  parseProgram(program, end = 139, sourceType = this.options.sourceType) {\\n    program.sourceType = sourceType;\\n    program.interpreter = this.parseInterpreterDirective();\\n    this.parseBlockBody(program, true, true, end);\\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\\n        this.raise(Errors.ModuleExportUndefined, at, {\\n          localName\\n        });\\n      }\\n    }\\n    let finishedProgram;\\n    if (end === 139) {\\n      finishedProgram = this.finishNode(program, \\\"Program\\\");\\n    } else {\\n      finishedProgram = this.finishNodeAt(program, \\\"Program\\\", createPositionWithColumnOffset(this.state.startLoc, -1));\\n    }\\n    return finishedProgram;\\n  }\\n  stmtToDirective(stmt) {\\n    const directive = stmt;\\n    directive.type = \\\"Directive\\\";\\n    directive.value = directive.expression;\\n    delete directive.expression;\\n    const directiveLiteral = directive.value;\\n    const expressionValue = directiveLiteral.value;\\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\\n    const val = directiveLiteral.value = raw.slice(1, -1);\\n    this.addExtra(directiveLiteral, \\\"raw\\\", raw);\\n    this.addExtra(directiveLiteral, \\\"rawValue\\\", val);\\n    this.addExtra(directiveLiteral, \\\"expressionValue\\\", expressionValue);\\n    directiveLiteral.type = \\\"DirectiveLiteral\\\";\\n    return directive;\\n  }\\n  parseInterpreterDirective() {\\n    if (!this.match(28)) {\\n      return null;\\n    }\\n    const node = this.startNode();\\n    node.value = this.state.value;\\n    this.next();\\n    return this.finishNode(node, \\\"InterpreterDirective\\\");\\n  }\\n  isLet() {\\n    if (!this.isContextual(100)) {\\n      return false;\\n    }\\n    return this.hasFollowingBindingAtom();\\n  }\\n  chStartsBindingIdentifier(ch, pos) {\\n    if (isIdentifierStart(ch)) {\\n      keywordRelationalOperator.lastIndex = pos;\\n      if (keywordRelationalOperator.test(this.input)) {\\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    } else if (ch === 92) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n  chStartsBindingPattern(ch) {\\n    return ch === 91 || ch === 123;\\n  }\\n  hasFollowingBindingAtom() {\\n    const next = this.nextTokenStart();\\n    const nextCh = this.codePointAtPos(next);\\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\\n  }\\n  hasInLineFollowingBindingIdentifier() {\\n    const next = this.nextTokenInLineStart();\\n    const nextCh = this.codePointAtPos(next);\\n    return this.chStartsBindingIdentifier(nextCh, next);\\n  }\\n  startsUsingForOf() {\\n    const {\\n      type,\\n      containsEsc\\n    } = this.lookahead();\\n    if (type === 102 && !containsEsc) {\\n      return false;\\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\\n      this.expectPlugin(\\\"explicitResourceManagement\\\");\\n      return true;\\n    }\\n  }\\n  startsAwaitUsing() {\\n    let next = this.nextTokenInLineStart();\\n    if (this.isUnparsedContextual(next, \\\"using\\\")) {\\n      next = this.nextTokenInLineStartSince(next + 5);\\n      const nextCh = this.codePointAtPos(next);\\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\\n        this.expectPlugin(\\\"explicitResourceManagement\\\");\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  parseModuleItem() {\\n    return this.parseStatementLike(1 | 2 | 4 | 8);\\n  }\\n  parseStatementListItem() {\\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\\n  }\\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\\n    let flags = 0;\\n    if (this.options.annexB && !this.state.strict) {\\n      flags |= 4;\\n      if (allowLabeledFunction) {\\n        flags |= 8;\\n      }\\n    }\\n    return this.parseStatementLike(flags);\\n  }\\n  parseStatement() {\\n    return this.parseStatementLike(0);\\n  }\\n  parseStatementLike(flags) {\\n    let decorators = null;\\n    if (this.match(26)) {\\n      decorators = this.parseDecorators(true);\\n    }\\n    return this.parseStatementContent(flags, decorators);\\n  }\\n  parseStatementContent(flags, decorators) {\\n    const starttype = this.state.type;\\n    const node = this.startNode();\\n    const allowDeclaration = !!(flags & 2);\\n    const allowFunctionDeclaration = !!(flags & 4);\\n    const topLevel = flags & 1;\\n    switch (starttype) {\\n      case 60:\\n        return this.parseBreakContinueStatement(node, true);\\n      case 63:\\n        return this.parseBreakContinueStatement(node, false);\\n      case 64:\\n        return this.parseDebuggerStatement(node);\\n      case 90:\\n        return this.parseDoWhileStatement(node);\\n      case 91:\\n        return this.parseForStatement(node);\\n      case 68:\\n        if (this.lookaheadCharCode() === 46) break;\\n        if (!allowFunctionDeclaration) {\\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\\n        }\\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\\n      case 80:\\n        if (!allowDeclaration) this.unexpected();\\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\\n      case 69:\\n        return this.parseIfStatement(node);\\n      case 70:\\n        return this.parseReturnStatement(node);\\n      case 71:\\n        return this.parseSwitchStatement(node);\\n      case 72:\\n        return this.parseThrowStatement(node);\\n      case 73:\\n        return this.parseTryStatement(node);\\n      case 96:\\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\\n          if (!this.isAwaitAllowed()) {\\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\\n          } else if (!allowDeclaration) {\\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\\n          }\\n          this.next();\\n          return this.parseVarStatement(node, \\\"await using\\\");\\n        }\\n        break;\\n      case 107:\\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {\\n          break;\\n        }\\n        this.expectPlugin(\\\"explicitResourceManagement\\\");\\n        if (!this.scope.inModule && this.scope.inTopLevel) {\\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\\n        } else if (!allowDeclaration) {\\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\\n        }\\n        return this.parseVarStatement(node, \\\"using\\\");\\n      case 100:\\n        {\\n          if (this.state.containsEsc) {\\n            break;\\n          }\\n          const next = this.nextTokenStart();\\n          const nextCh = this.codePointAtPos(next);\\n          if (nextCh !== 91) {\\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\\n              break;\\n            }\\n          }\\n        }\\n      case 75:\\n        {\\n          if (!allowDeclaration) {\\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\\n          }\\n        }\\n      case 74:\\n        {\\n          const kind = this.state.value;\\n          return this.parseVarStatement(node, kind);\\n        }\\n      case 92:\\n        return this.parseWhileStatement(node);\\n      case 76:\\n        return this.parseWithStatement(node);\\n      case 5:\\n        return this.parseBlock();\\n      case 13:\\n        return this.parseEmptyStatement(node);\\n      case 83:\\n        {\\n          const nextTokenCharCode = this.lookaheadCharCode();\\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\\n            break;\\n          }\\n        }\\n      case 82:\\n        {\\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\\n          }\\n          this.next();\\n          let result;\\n          if (starttype === 83) {\\n            result = this.parseImport(node);\\n            if (result.type === \\\"ImportDeclaration\\\" && (!result.importKind || result.importKind === \\\"value\\\")) {\\n              this.sawUnambiguousESM = true;\\n            }\\n          } else {\\n            result = this.parseExport(node, decorators);\\n            if (result.type === \\\"ExportNamedDeclaration\\\" && (!result.exportKind || result.exportKind === \\\"value\\\") || result.type === \\\"ExportAllDeclaration\\\" && (!result.exportKind || result.exportKind === \\\"value\\\") || result.type === \\\"ExportDefaultDeclaration\\\") {\\n              this.sawUnambiguousESM = true;\\n            }\\n          }\\n          this.assertModuleNodeAllowed(result);\\n          return result;\\n        }\\n      default:\\n        {\\n          if (this.isAsyncFunction()) {\\n            if (!allowDeclaration) {\\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\\n            }\\n            this.next();\\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\\n          }\\n        }\\n    }\\n    const maybeName = this.state.value;\\n    const expr = this.parseExpression();\\n    if (tokenIsIdentifier(starttype) && expr.type === \\\"Identifier\\\" && this.eat(14)) {\\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\\n    } else {\\n      return this.parseExpressionStatement(node, expr, decorators);\\n    }\\n  }\\n  assertModuleNodeAllowed(node) {\\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\\n      this.raise(Errors.ImportOutsideModule, node);\\n    }\\n  }\\n  decoratorsEnabledBeforeExport() {\\n    if (this.hasPlugin(\\\"decorators-legacy\\\")) return true;\\n    return this.hasPlugin(\\\"decorators\\\") && this.getPluginOption(\\\"decorators\\\", \\\"decoratorsBeforeExport\\\") !== false;\\n  }\\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\\n    if (maybeDecorators) {\\n      if (classNode.decorators && classNode.decorators.length > 0) {\\n        if (typeof this.getPluginOption(\\\"decorators\\\", \\\"decoratorsBeforeExport\\\") !== \\\"boolean\\\") {\\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\\n        }\\n        classNode.decorators.unshift(...maybeDecorators);\\n      } else {\\n        classNode.decorators = maybeDecorators;\\n      }\\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\\n    }\\n    return classNode;\\n  }\\n  canHaveLeadingDecorator() {\\n    return this.match(80);\\n  }\\n  parseDecorators(allowExport) {\\n    const decorators = [];\\n    do {\\n      decorators.push(this.parseDecorator());\\n    } while (this.match(26));\\n    if (this.match(82)) {\\n      if (!allowExport) {\\n        this.unexpected();\\n      }\\n      if (!this.decoratorsEnabledBeforeExport()) {\\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\\n      }\\n    } else if (!this.canHaveLeadingDecorator()) {\\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\\n    }\\n    return decorators;\\n  }\\n  parseDecorator() {\\n    this.expectOnePlugin([\\\"decorators\\\", \\\"decorators-legacy\\\"]);\\n    const node = this.startNode();\\n    this.next();\\n    if (this.hasPlugin(\\\"decorators\\\")) {\\n      const startLoc = this.state.startLoc;\\n      let expr;\\n      if (this.match(10)) {\\n        const startLoc = this.state.startLoc;\\n        this.next();\\n        expr = this.parseExpression();\\n        this.expect(11);\\n        expr = this.wrapParenthesis(startLoc, expr);\\n        const paramsStartLoc = this.state.startLoc;\\n        node.expression = this.parseMaybeDecoratorArguments(expr);\\n        if (this.getPluginOption(\\\"decorators\\\", \\\"allowCallParenthesized\\\") === false && node.expression !== expr) {\\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\\n        }\\n      } else {\\n        expr = this.parseIdentifier(false);\\n        while (this.eat(16)) {\\n          const node = this.startNodeAt(startLoc);\\n          node.object = expr;\\n          if (this.match(138)) {\\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\\n            node.property = this.parsePrivateName();\\n          } else {\\n            node.property = this.parseIdentifier(true);\\n          }\\n          node.computed = false;\\n          expr = this.finishNode(node, \\\"MemberExpression\\\");\\n        }\\n        node.expression = this.parseMaybeDecoratorArguments(expr);\\n      }\\n    } else {\\n      node.expression = this.parseExprSubscripts();\\n    }\\n    return this.finishNode(node, \\\"Decorator\\\");\\n  }\\n  parseMaybeDecoratorArguments(expr) {\\n    if (this.eat(10)) {\\n      const node = this.startNodeAtNode(expr);\\n      node.callee = expr;\\n      node.arguments = this.parseCallExpressionArguments(11, false);\\n      this.toReferencedList(node.arguments);\\n      return this.finishNode(node, \\\"CallExpression\\\");\\n    }\\n    return expr;\\n  }\\n  parseBreakContinueStatement(node, isBreak) {\\n    this.next();\\n    if (this.isLineTerminator()) {\\n      node.label = null;\\n    } else {\\n      node.label = this.parseIdentifier();\\n      this.semicolon();\\n    }\\n    this.verifyBreakContinue(node, isBreak);\\n    return this.finishNode(node, isBreak ? \\\"BreakStatement\\\" : \\\"ContinueStatement\\\");\\n  }\\n  verifyBreakContinue(node, isBreak) {\\n    let i;\\n    for (i = 0; i < this.state.labels.length; ++i) {\\n      const lab = this.state.labels[i];\\n      if (node.label == null || lab.name === node.label.name) {\\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\\n          break;\\n        }\\n        if (node.label && isBreak) break;\\n      }\\n    }\\n    if (i === this.state.labels.length) {\\n      const type = isBreak ? \\\"BreakStatement\\\" : \\\"ContinueStatement\\\";\\n      this.raise(Errors.IllegalBreakContinue, node, {\\n        type\\n      });\\n    }\\n  }\\n  parseDebuggerStatement(node) {\\n    this.next();\\n    this.semicolon();\\n    return this.finishNode(node, \\\"DebuggerStatement\\\");\\n  }\\n  parseHeaderExpression() {\\n    this.expect(10);\\n    const val = this.parseExpression();\\n    this.expect(11);\\n    return val;\\n  }\\n  parseDoWhileStatement(node) {\\n    this.next();\\n    this.state.labels.push(loopLabel);\\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\\n    this.state.labels.pop();\\n    this.expect(92);\\n    node.test = this.parseHeaderExpression();\\n    this.eat(13);\\n    return this.finishNode(node, \\\"DoWhileStatement\\\");\\n  }\\n  parseForStatement(node) {\\n    this.next();\\n    this.state.labels.push(loopLabel);\\n    let awaitAt = null;\\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\\n      awaitAt = this.state.lastTokStartLoc;\\n    }\\n    this.scope.enter(0);\\n    this.expect(10);\\n    if (this.match(13)) {\\n      if (awaitAt !== null) {\\n        this.unexpected(awaitAt);\\n      }\\n      return this.parseFor(node, null);\\n    }\\n    const startsWithLet = this.isContextual(100);\\n    {\\n      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();\\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();\\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\\n        const initNode = this.startNode();\\n        let kind;\\n        if (startsWithAwaitUsing) {\\n          kind = \\\"await using\\\";\\n          if (!this.isAwaitAllowed()) {\\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\\n          }\\n          this.next();\\n        } else {\\n          kind = this.state.value;\\n        }\\n        this.next();\\n        this.parseVar(initNode, true, kind);\\n        const init = this.finishNode(initNode, \\\"VariableDeclaration\\\");\\n        const isForIn = this.match(58);\\n        if (isForIn && starsWithUsingDeclaration) {\\n          this.raise(Errors.ForInUsing, init);\\n        }\\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\\n          return this.parseForIn(node, init, awaitAt);\\n        }\\n        if (awaitAt !== null) {\\n          this.unexpected(awaitAt);\\n        }\\n        return this.parseFor(node, init);\\n      }\\n    }\\n    const startsWithAsync = this.isContextual(95);\\n    const refExpressionErrors = new ExpressionErrors();\\n    const init = this.parseExpression(true, refExpressionErrors);\\n    const isForOf = this.isContextual(102);\\n    if (isForOf) {\\n      if (startsWithLet) {\\n        this.raise(Errors.ForOfLet, init);\\n      }\\n      if (awaitAt === null && startsWithAsync && init.type === \\\"Identifier\\\") {\\n        this.raise(Errors.ForOfAsync, init);\\n      }\\n    }\\n    if (isForOf || this.match(58)) {\\n      this.checkDestructuringPrivate(refExpressionErrors);\\n      this.toAssignable(init, true);\\n      const type = isForOf ? \\\"ForOfStatement\\\" : \\\"ForInStatement\\\";\\n      this.checkLVal(init, {\\n        in: {\\n          type\\n        }\\n      });\\n      return this.parseForIn(node, init, awaitAt);\\n    } else {\\n      this.checkExpressionErrors(refExpressionErrors, true);\\n    }\\n    if (awaitAt !== null) {\\n      this.unexpected(awaitAt);\\n    }\\n    return this.parseFor(node, init);\\n  }\\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\\n    this.next();\\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\\n  }\\n  parseIfStatement(node) {\\n    this.next();\\n    node.test = this.parseHeaderExpression();\\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\\n    return this.finishNode(node, \\\"IfStatement\\\");\\n  }\\n  parseReturnStatement(node) {\\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\\n    }\\n    this.next();\\n    if (this.isLineTerminator()) {\\n      node.argument = null;\\n    } else {\\n      node.argument = this.parseExpression();\\n      this.semicolon();\\n    }\\n    return this.finishNode(node, \\\"ReturnStatement\\\");\\n  }\\n  parseSwitchStatement(node) {\\n    this.next();\\n    node.discriminant = this.parseHeaderExpression();\\n    const cases = node.cases = [];\\n    this.expect(5);\\n    this.state.labels.push(switchLabel);\\n    this.scope.enter(0);\\n    let cur;\\n    for (let sawDefault; !this.match(8);) {\\n      if (this.match(61) || this.match(65)) {\\n        const isCase = this.match(61);\\n        if (cur) this.finishNode(cur, \\\"SwitchCase\\\");\\n        cases.push(cur = this.startNode());\\n        cur.consequent = [];\\n        this.next();\\n        if (isCase) {\\n          cur.test = this.parseExpression();\\n        } else {\\n          if (sawDefault) {\\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\\n          }\\n          sawDefault = true;\\n          cur.test = null;\\n        }\\n        this.expect(14);\\n      } else {\\n        if (cur) {\\n          cur.consequent.push(this.parseStatementListItem());\\n        } else {\\n          this.unexpected();\\n        }\\n      }\\n    }\\n    this.scope.exit();\\n    if (cur) this.finishNode(cur, \\\"SwitchCase\\\");\\n    this.next();\\n    this.state.labels.pop();\\n    return this.finishNode(node, \\\"SwitchStatement\\\");\\n  }\\n  parseThrowStatement(node) {\\n    this.next();\\n    if (this.hasPrecedingLineBreak()) {\\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\\n    }\\n    node.argument = this.parseExpression();\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ThrowStatement\\\");\\n  }\\n  parseCatchClauseParam() {\\n    const param = this.parseBindingAtom();\\n    this.scope.enter(this.options.annexB && param.type === \\\"Identifier\\\" ? 8 : 0);\\n    this.checkLVal(param, {\\n      in: {\\n        type: \\\"CatchClause\\\"\\n      },\\n      binding: 9\\n    });\\n    return param;\\n  }\\n  parseTryStatement(node) {\\n    this.next();\\n    node.block = this.parseBlock();\\n    node.handler = null;\\n    if (this.match(62)) {\\n      const clause = this.startNode();\\n      this.next();\\n      if (this.match(10)) {\\n        this.expect(10);\\n        clause.param = this.parseCatchClauseParam();\\n        this.expect(11);\\n      } else {\\n        clause.param = null;\\n        this.scope.enter(0);\\n      }\\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\\n      this.scope.exit();\\n      node.handler = this.finishNode(clause, \\\"CatchClause\\\");\\n    }\\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\\n    if (!node.handler && !node.finalizer) {\\n      this.raise(Errors.NoCatchOrFinally, node);\\n    }\\n    return this.finishNode(node, \\\"TryStatement\\\");\\n  }\\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\\n    this.next();\\n    this.parseVar(node, false, kind, allowMissingInitializer);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"VariableDeclaration\\\");\\n  }\\n  parseWhileStatement(node) {\\n    this.next();\\n    node.test = this.parseHeaderExpression();\\n    this.state.labels.push(loopLabel);\\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\\n    this.state.labels.pop();\\n    return this.finishNode(node, \\\"WhileStatement\\\");\\n  }\\n  parseWithStatement(node) {\\n    if (this.state.strict) {\\n      this.raise(Errors.StrictWith, this.state.startLoc);\\n    }\\n    this.next();\\n    node.object = this.parseHeaderExpression();\\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\\n    return this.finishNode(node, \\\"WithStatement\\\");\\n  }\\n  parseEmptyStatement(node) {\\n    this.next();\\n    return this.finishNode(node, \\\"EmptyStatement\\\");\\n  }\\n  parseLabeledStatement(node, maybeName, expr, flags) {\\n    for (const label of this.state.labels) {\\n      if (label.name === maybeName) {\\n        this.raise(Errors.LabelRedeclaration, expr, {\\n          labelName: maybeName\\n        });\\n      }\\n    }\\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\\n      const label = this.state.labels[i];\\n      if (label.statementStart === node.start) {\\n        label.statementStart = this.state.start;\\n        label.kind = kind;\\n      } else {\\n        break;\\n      }\\n    }\\n    this.state.labels.push({\\n      name: maybeName,\\n      kind: kind,\\n      statementStart: this.state.start\\n    });\\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\\n    this.state.labels.pop();\\n    node.label = expr;\\n    return this.finishNode(node, \\\"LabeledStatement\\\");\\n  }\\n  parseExpressionStatement(node, expr, decorators) {\\n    node.expression = expr;\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ExpressionStatement\\\");\\n  }\\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\\n    const node = this.startNode();\\n    if (allowDirectives) {\\n      this.state.strictErrors.clear();\\n    }\\n    this.expect(5);\\n    if (createNewLexicalScope) {\\n      this.scope.enter(0);\\n    }\\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\\n    if (createNewLexicalScope) {\\n      this.scope.exit();\\n    }\\n    return this.finishNode(node, \\\"BlockStatement\\\");\\n  }\\n  isValidDirective(stmt) {\\n    return stmt.type === \\\"ExpressionStatement\\\" && stmt.expression.type === \\\"StringLiteral\\\" && !stmt.expression.extra.parenthesized;\\n  }\\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\\n    const body = node.body = [];\\n    const directives = node.directives = [];\\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\\n  }\\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\\n    const oldStrict = this.state.strict;\\n    let hasStrictModeDirective = false;\\n    let parsedNonDirective = false;\\n    while (!this.match(end)) {\\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\\n      if (directives && !parsedNonDirective) {\\n        if (this.isValidDirective(stmt)) {\\n          const directive = this.stmtToDirective(stmt);\\n          directives.push(directive);\\n          if (!hasStrictModeDirective && directive.value.value === \\\"use strict\\\") {\\n            hasStrictModeDirective = true;\\n            this.setStrict(true);\\n          }\\n          continue;\\n        }\\n        parsedNonDirective = true;\\n        this.state.strictErrors.clear();\\n      }\\n      body.push(stmt);\\n    }\\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\\n    if (!oldStrict) {\\n      this.setStrict(false);\\n    }\\n    this.next();\\n  }\\n  parseFor(node, init) {\\n    node.init = init;\\n    this.semicolon(false);\\n    node.test = this.match(13) ? null : this.parseExpression();\\n    this.semicolon(false);\\n    node.update = this.match(11) ? null : this.parseExpression();\\n    this.expect(11);\\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\\n    this.scope.exit();\\n    this.state.labels.pop();\\n    return this.finishNode(node, \\\"ForStatement\\\");\\n  }\\n  parseForIn(node, init, awaitAt) {\\n    const isForIn = this.match(58);\\n    this.next();\\n    if (isForIn) {\\n      if (awaitAt !== null) this.unexpected(awaitAt);\\n    } else {\\n      node.await = awaitAt !== null;\\n    }\\n    if (init.type === \\\"VariableDeclaration\\\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \\\"var\\\" || init.declarations[0].id.type !== \\\"Identifier\\\")) {\\n      this.raise(Errors.ForInOfLoopInitializer, init, {\\n        type: isForIn ? \\\"ForInStatement\\\" : \\\"ForOfStatement\\\"\\n      });\\n    }\\n    if (init.type === \\\"AssignmentPattern\\\") {\\n      this.raise(Errors.InvalidLhs, init, {\\n        ancestor: {\\n          type: \\\"ForStatement\\\"\\n        }\\n      });\\n    }\\n    node.left = init;\\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\\n    this.expect(11);\\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\\n    this.scope.exit();\\n    this.state.labels.pop();\\n    return this.finishNode(node, isForIn ? \\\"ForInStatement\\\" : \\\"ForOfStatement\\\");\\n  }\\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\\n    const declarations = node.declarations = [];\\n    node.kind = kind;\\n    for (;;) {\\n      const decl = this.startNode();\\n      this.parseVarId(decl, kind);\\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\\n      if (decl.init === null && !allowMissingInitializer) {\\n        if (decl.id.type !== \\\"Identifier\\\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\\n            kind: \\\"destructuring\\\"\\n          });\\n        } else if (kind === \\\"const\\\" && !(this.match(58) || this.isContextual(102))) {\\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\\n            kind: \\\"const\\\"\\n          });\\n        }\\n      }\\n      declarations.push(this.finishNode(decl, \\\"VariableDeclarator\\\"));\\n      if (!this.eat(12)) break;\\n    }\\n    return node;\\n  }\\n  parseVarId(decl, kind) {\\n    const id = this.parseBindingAtom();\\n    this.checkLVal(id, {\\n      in: {\\n        type: \\\"VariableDeclarator\\\"\\n      },\\n      binding: kind === \\\"var\\\" ? 5 : 8201\\n    });\\n    decl.id = id;\\n  }\\n  parseAsyncFunctionExpression(node) {\\n    return this.parseFunction(node, 8);\\n  }\\n  parseFunction(node, flags = 0) {\\n    const hangingDeclaration = flags & 2;\\n    const isDeclaration = !!(flags & 1);\\n    const requireId = isDeclaration && !(flags & 4);\\n    const isAsync = !!(flags & 8);\\n    this.initFunction(node, isAsync);\\n    if (this.match(55)) {\\n      if (hangingDeclaration) {\\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\\n      }\\n      this.next();\\n      node.generator = true;\\n    }\\n    if (isDeclaration) {\\n      node.id = this.parseFunctionId(requireId);\\n    }\\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\\n    this.state.maybeInArrowParameters = false;\\n    this.scope.enter(2);\\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\\n    if (!isDeclaration) {\\n      node.id = this.parseFunctionId();\\n    }\\n    this.parseFunctionParams(node, false);\\n    this.withSmartMixTopicForbiddingContext(() => {\\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \\\"FunctionDeclaration\\\" : \\\"FunctionExpression\\\");\\n    });\\n    this.prodParam.exit();\\n    this.scope.exit();\\n    if (isDeclaration && !hangingDeclaration) {\\n      this.registerFunctionStatementId(node);\\n    }\\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\\n    return node;\\n  }\\n  parseFunctionId(requireId) {\\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\\n  }\\n  parseFunctionParams(node, isConstructor) {\\n    this.expect(10);\\n    this.expressionScope.enter(newParameterDeclarationScope());\\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\\n    this.expressionScope.exit();\\n  }\\n  registerFunctionStatementId(node) {\\n    if (!node.id) return;\\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\\n  }\\n  parseClass(node, isStatement, optionalId) {\\n    this.next();\\n    const oldStrict = this.state.strict;\\n    this.state.strict = true;\\n    this.parseClassId(node, isStatement, optionalId);\\n    this.parseClassSuper(node);\\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\\n    return this.finishNode(node, isStatement ? \\\"ClassDeclaration\\\" : \\\"ClassExpression\\\");\\n  }\\n  isClassProperty() {\\n    return this.match(29) || this.match(13) || this.match(8);\\n  }\\n  isClassMethod() {\\n    return this.match(10);\\n  }\\n  isNonstaticConstructor(method) {\\n    return !method.computed && !method.static && (method.key.name === \\\"constructor\\\" || method.key.value === \\\"constructor\\\");\\n  }\\n  parseClassBody(hadSuperClass, oldStrict) {\\n    this.classScope.enter();\\n    const state = {\\n      hadConstructor: false,\\n      hadSuperClass\\n    };\\n    let decorators = [];\\n    const classBody = this.startNode();\\n    classBody.body = [];\\n    this.expect(5);\\n    this.withSmartMixTopicForbiddingContext(() => {\\n      while (!this.match(8)) {\\n        if (this.eat(13)) {\\n          if (decorators.length > 0) {\\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\\n          }\\n          continue;\\n        }\\n        if (this.match(26)) {\\n          decorators.push(this.parseDecorator());\\n          continue;\\n        }\\n        const member = this.startNode();\\n        if (decorators.length) {\\n          member.decorators = decorators;\\n          this.resetStartLocationFromNode(member, decorators[0]);\\n          decorators = [];\\n        }\\n        this.parseClassMember(classBody, member, state);\\n        if (member.kind === \\\"constructor\\\" && member.decorators && member.decorators.length > 0) {\\n          this.raise(Errors.DecoratorConstructor, member);\\n        }\\n      }\\n    });\\n    this.state.strict = oldStrict;\\n    this.next();\\n    if (decorators.length) {\\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\\n    }\\n    this.classScope.exit();\\n    return this.finishNode(classBody, \\\"ClassBody\\\");\\n  }\\n  parseClassMemberFromModifier(classBody, member) {\\n    const key = this.parseIdentifier(true);\\n    if (this.isClassMethod()) {\\n      const method = member;\\n      method.kind = \\\"method\\\";\\n      method.computed = false;\\n      method.key = key;\\n      method.static = false;\\n      this.pushClassMethod(classBody, method, false, false, false, false);\\n      return true;\\n    } else if (this.isClassProperty()) {\\n      const prop = member;\\n      prop.computed = false;\\n      prop.key = key;\\n      prop.static = false;\\n      classBody.body.push(this.parseClassProperty(prop));\\n      return true;\\n    }\\n    this.resetPreviousNodeTrailingComments(key);\\n    return false;\\n  }\\n  parseClassMember(classBody, member, state) {\\n    const isStatic = this.isContextual(106);\\n    if (isStatic) {\\n      if (this.parseClassMemberFromModifier(classBody, member)) {\\n        return;\\n      }\\n      if (this.eat(5)) {\\n        this.parseClassStaticBlock(classBody, member);\\n        return;\\n      }\\n    }\\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\\n  }\\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\\n    const publicMethod = member;\\n    const privateMethod = member;\\n    const publicProp = member;\\n    const privateProp = member;\\n    const accessorProp = member;\\n    const method = publicMethod;\\n    const publicMember = publicMethod;\\n    member.static = isStatic;\\n    this.parsePropertyNamePrefixOperator(member);\\n    if (this.eat(55)) {\\n      method.kind = \\\"method\\\";\\n      const isPrivateName = this.match(138);\\n      this.parseClassElementName(method);\\n      if (isPrivateName) {\\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\\n        return;\\n      }\\n      if (this.isNonstaticConstructor(publicMethod)) {\\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\\n      }\\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\\n      return;\\n    }\\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\\n    const isPrivate = this.match(138);\\n    const key = this.parseClassElementName(member);\\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\\n    this.parsePostMemberNameModifiers(publicMember);\\n    if (this.isClassMethod()) {\\n      method.kind = \\\"method\\\";\\n      if (isPrivate) {\\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\\n        return;\\n      }\\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\\n      let allowsDirectSuper = false;\\n      if (isConstructor) {\\n        publicMethod.kind = \\\"constructor\\\";\\n        if (state.hadConstructor && !this.hasPlugin(\\\"typescript\\\")) {\\n          this.raise(Errors.DuplicateConstructor, key);\\n        }\\n        if (isConstructor && this.hasPlugin(\\\"typescript\\\") && member.override) {\\n          this.raise(Errors.OverrideOnConstructor, key);\\n        }\\n        state.hadConstructor = true;\\n        allowsDirectSuper = state.hadSuperClass;\\n      }\\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\\n    } else if (this.isClassProperty()) {\\n      if (isPrivate) {\\n        this.pushClassPrivateProperty(classBody, privateProp);\\n      } else {\\n        this.pushClassProperty(classBody, publicProp);\\n      }\\n    } else if (isContextual && key.name === \\\"async\\\" && !this.isLineTerminator()) {\\n      this.resetPreviousNodeTrailingComments(key);\\n      const isGenerator = this.eat(55);\\n      if (publicMember.optional) {\\n        this.unexpected(maybeQuestionTokenStartLoc);\\n      }\\n      method.kind = \\\"method\\\";\\n      const isPrivate = this.match(138);\\n      this.parseClassElementName(method);\\n      this.parsePostMemberNameModifiers(publicMember);\\n      if (isPrivate) {\\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\\n      } else {\\n        if (this.isNonstaticConstructor(publicMethod)) {\\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\\n        }\\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\\n      }\\n    } else if (isContextual && (key.name === \\\"get\\\" || key.name === \\\"set\\\") && !(this.match(55) && this.isLineTerminator())) {\\n      this.resetPreviousNodeTrailingComments(key);\\n      method.kind = key.name;\\n      const isPrivate = this.match(138);\\n      this.parseClassElementName(publicMethod);\\n      if (isPrivate) {\\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\\n      } else {\\n        if (this.isNonstaticConstructor(publicMethod)) {\\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\\n        }\\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\\n      }\\n      this.checkGetterSetterParams(publicMethod);\\n    } else if (isContextual && key.name === \\\"accessor\\\" && !this.isLineTerminator()) {\\n      this.expectPlugin(\\\"decoratorAutoAccessors\\\");\\n      this.resetPreviousNodeTrailingComments(key);\\n      const isPrivate = this.match(138);\\n      this.parseClassElementName(publicProp);\\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\\n    } else if (this.isLineTerminator()) {\\n      if (isPrivate) {\\n        this.pushClassPrivateProperty(classBody, privateProp);\\n      } else {\\n        this.pushClassProperty(classBody, publicProp);\\n      }\\n    } else {\\n      this.unexpected();\\n    }\\n  }\\n  parseClassElementName(member) {\\n    const {\\n      type,\\n      value\\n    } = this.state;\\n    if ((type === 132 || type === 133) && member.static && value === \\\"prototype\\\") {\\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\\n    }\\n    if (type === 138) {\\n      if (value === \\\"constructor\\\") {\\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\\n      }\\n      const key = this.parsePrivateName();\\n      member.key = key;\\n      return key;\\n    }\\n    return this.parsePropertyName(member);\\n  }\\n  parseClassStaticBlock(classBody, member) {\\n    var _member$decorators;\\n    this.scope.enter(64 | 128 | 16);\\n    const oldLabels = this.state.labels;\\n    this.state.labels = [];\\n    this.prodParam.enter(0);\\n    const body = member.body = [];\\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\\n    this.prodParam.exit();\\n    this.scope.exit();\\n    this.state.labels = oldLabels;\\n    classBody.body.push(this.finishNode(member, \\\"StaticBlock\\\"));\\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\\n      this.raise(Errors.DecoratorStaticBlock, member);\\n    }\\n  }\\n  pushClassProperty(classBody, prop) {\\n    if (!prop.computed && (prop.key.name === \\\"constructor\\\" || prop.key.value === \\\"constructor\\\")) {\\n      this.raise(Errors.ConstructorClassField, prop.key);\\n    }\\n    classBody.body.push(this.parseClassProperty(prop));\\n  }\\n  pushClassPrivateProperty(classBody, prop) {\\n    const node = this.parseClassPrivateProperty(prop);\\n    classBody.body.push(node);\\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\\n  }\\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\\n    if (!isPrivate && !prop.computed) {\\n      const key = prop.key;\\n      if (key.name === \\\"constructor\\\" || key.value === \\\"constructor\\\") {\\n        this.raise(Errors.ConstructorClassField, key);\\n      }\\n    }\\n    const node = this.parseClassAccessorProperty(prop);\\n    classBody.body.push(node);\\n    if (isPrivate) {\\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\\n    }\\n  }\\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \\\"ClassMethod\\\", true));\\n  }\\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \\\"ClassPrivateMethod\\\", true);\\n    classBody.body.push(node);\\n    const kind = node.kind === \\\"get\\\" ? node.static ? 6 : 2 : node.kind === \\\"set\\\" ? node.static ? 5 : 1 : 0;\\n    this.declareClassPrivateMethodInScope(node, kind);\\n  }\\n  declareClassPrivateMethodInScope(node, kind) {\\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\\n  }\\n  parsePostMemberNameModifiers(methodOrProp) {}\\n  parseClassPrivateProperty(node) {\\n    this.parseInitializer(node);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ClassPrivateProperty\\\");\\n  }\\n  parseClassProperty(node) {\\n    this.parseInitializer(node);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ClassProperty\\\");\\n  }\\n  parseClassAccessorProperty(node) {\\n    this.parseInitializer(node);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ClassAccessorProperty\\\");\\n  }\\n  parseInitializer(node) {\\n    this.scope.enter(64 | 16);\\n    this.expressionScope.enter(newExpressionScope());\\n    this.prodParam.enter(0);\\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\\n    this.expressionScope.exit();\\n    this.prodParam.exit();\\n    this.scope.exit();\\n  }\\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\\n    if (tokenIsIdentifier(this.state.type)) {\\n      node.id = this.parseIdentifier();\\n      if (isStatement) {\\n        this.declareNameFromIdentifier(node.id, bindingType);\\n      }\\n    } else {\\n      if (optionalId || !isStatement) {\\n        node.id = null;\\n      } else {\\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\\n      }\\n    }\\n  }\\n  parseClassSuper(node) {\\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\\n  }\\n  parseExport(node, decorators) {\\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\\n    const parseAfterDefault = !hasDefault || this.eat(12);\\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\\n    const isFromRequired = hasDefault || hasStar;\\n    if (hasStar && !hasNamespace) {\\n      if (hasDefault) this.unexpected();\\n      if (decorators) {\\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\\n      }\\n      this.parseExportFrom(node, true);\\n      return this.finishNode(node, \\\"ExportAllDeclaration\\\");\\n    }\\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\\n      this.unexpected(null, 5);\\n    }\\n    if (hasNamespace && parseAfterNamespace) {\\n      this.unexpected(null, 98);\\n    }\\n    let hasDeclaration;\\n    if (isFromRequired || hasSpecifiers) {\\n      hasDeclaration = false;\\n      if (decorators) {\\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\\n      }\\n      this.parseExportFrom(node, isFromRequired);\\n    } else {\\n      hasDeclaration = this.maybeParseExportDeclaration(node);\\n    }\\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\\n      var _node2$declaration;\\n      const node2 = node;\\n      this.checkExport(node2, true, false, !!node2.source);\\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \\\"ClassDeclaration\\\") {\\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\\n      } else if (decorators) {\\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\\n      }\\n      return this.finishNode(node2, \\\"ExportNamedDeclaration\\\");\\n    }\\n    if (this.eat(65)) {\\n      const node2 = node;\\n      const decl = this.parseExportDefaultExpression();\\n      node2.declaration = decl;\\n      if (decl.type === \\\"ClassDeclaration\\\") {\\n        this.maybeTakeDecorators(decorators, decl, node2);\\n      } else if (decorators) {\\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\\n      }\\n      this.checkExport(node2, true, true);\\n      return this.finishNode(node2, \\\"ExportDefaultDeclaration\\\");\\n    }\\n    this.unexpected(null, 5);\\n  }\\n  eatExportStar(node) {\\n    return this.eat(55);\\n  }\\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\\n      this.expectPlugin(\\\"exportDefaultFrom\\\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\\n      const specifier = this.startNodeAtNode(id);\\n      specifier.exported = id;\\n      node.specifiers = [this.finishNode(specifier, \\\"ExportDefaultSpecifier\\\")];\\n      return true;\\n    }\\n    return false;\\n  }\\n  maybeParseExportNamespaceSpecifier(node) {\\n    if (this.isContextual(93)) {\\n      if (!node.specifiers) node.specifiers = [];\\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\\n      this.next();\\n      specifier.exported = this.parseModuleExportName();\\n      node.specifiers.push(this.finishNode(specifier, \\\"ExportNamespaceSpecifier\\\"));\\n      return true;\\n    }\\n    return false;\\n  }\\n  maybeParseExportNamedSpecifiers(node) {\\n    if (this.match(5)) {\\n      if (!node.specifiers) node.specifiers = [];\\n      const isTypeExport = node.exportKind === \\\"type\\\";\\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\\n      node.source = null;\\n      node.declaration = null;\\n      if (this.hasPlugin(\\\"importAssertions\\\")) {\\n        node.assertions = [];\\n      }\\n      return true;\\n    }\\n    return false;\\n  }\\n  maybeParseExportDeclaration(node) {\\n    if (this.shouldParseExportDeclaration()) {\\n      node.specifiers = [];\\n      node.source = null;\\n      if (this.hasPlugin(\\\"importAssertions\\\")) {\\n        node.assertions = [];\\n      }\\n      node.declaration = this.parseExportDeclaration(node);\\n      return true;\\n    }\\n    return false;\\n  }\\n  isAsyncFunction() {\\n    if (!this.isContextual(95)) return false;\\n    const next = this.nextTokenInLineStart();\\n    return this.isUnparsedContextual(next, \\\"function\\\");\\n  }\\n  parseExportDefaultExpression() {\\n    const expr = this.startNode();\\n    if (this.match(68)) {\\n      this.next();\\n      return this.parseFunction(expr, 1 | 4);\\n    } else if (this.isAsyncFunction()) {\\n      this.next();\\n      this.next();\\n      return this.parseFunction(expr, 1 | 4 | 8);\\n    }\\n    if (this.match(80)) {\\n      return this.parseClass(expr, true, true);\\n    }\\n    if (this.match(26)) {\\n      if (this.hasPlugin(\\\"decorators\\\") && this.getPluginOption(\\\"decorators\\\", \\\"decoratorsBeforeExport\\\") === true) {\\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\\n      }\\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\\n    }\\n    if (this.match(75) || this.match(74) || this.isLet()) {\\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\\n    }\\n    const res = this.parseMaybeAssignAllowIn();\\n    this.semicolon();\\n    return res;\\n  }\\n  parseExportDeclaration(node) {\\n    if (this.match(80)) {\\n      const node = this.parseClass(this.startNode(), true, false);\\n      return node;\\n    }\\n    return this.parseStatementListItem();\\n  }\\n  isExportDefaultSpecifier() {\\n    const {\\n      type\\n    } = this.state;\\n    if (tokenIsIdentifier(type)) {\\n      if (type === 95 && !this.state.containsEsc || type === 100) {\\n        return false;\\n      }\\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\\n        const {\\n          type: nextType\\n        } = this.lookahead();\\n        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {\\n          this.expectOnePlugin([\\\"flow\\\", \\\"typescript\\\"]);\\n          return false;\\n        }\\n      }\\n    } else if (!this.match(65)) {\\n      return false;\\n    }\\n    const next = this.nextTokenStart();\\n    const hasFrom = this.isUnparsedContextual(next, \\\"from\\\");\\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\\n      return true;\\n    }\\n    if (this.match(65) && hasFrom) {\\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\\n    }\\n    return false;\\n  }\\n  parseExportFrom(node, expect) {\\n    if (this.eatContextual(98)) {\\n      node.source = this.parseImportSource();\\n      this.checkExport(node);\\n      this.maybeParseImportAttributes(node);\\n      this.checkJSONModuleImport(node);\\n    } else if (expect) {\\n      this.unexpected();\\n    }\\n    this.semicolon();\\n  }\\n  shouldParseExportDeclaration() {\\n    const {\\n      type\\n    } = this.state;\\n    if (type === 26) {\\n      this.expectOnePlugin([\\\"decorators\\\", \\\"decorators-legacy\\\"]);\\n      if (this.hasPlugin(\\\"decorators\\\")) {\\n        if (this.getPluginOption(\\\"decorators\\\", \\\"decoratorsBeforeExport\\\") === true) {\\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\\n        }\\n        return true;\\n      }\\n    }\\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\\n  }\\n  checkExport(node, checkNames, isDefault, isFrom) {\\n    if (checkNames) {\\n      var _node$specifiers;\\n      if (isDefault) {\\n        this.checkDuplicateExports(node, \\\"default\\\");\\n        if (this.hasPlugin(\\\"exportDefaultFrom\\\")) {\\n          var _declaration$extra;\\n          const declaration = node.declaration;\\n          if (declaration.type === \\\"Identifier\\\" && declaration.name === \\\"from\\\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\\n          }\\n        }\\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\\n        for (const specifier of node.specifiers) {\\n          const {\\n            exported\\n          } = specifier;\\n          const exportName = exported.type === \\\"Identifier\\\" ? exported.name : exported.value;\\n          this.checkDuplicateExports(specifier, exportName);\\n          if (!isFrom && specifier.local) {\\n            const {\\n              local\\n            } = specifier;\\n            if (local.type !== \\\"Identifier\\\") {\\n              this.raise(Errors.ExportBindingIsString, specifier, {\\n                localName: local.value,\\n                exportName\\n              });\\n            } else {\\n              this.checkReservedWord(local.name, local.loc.start, true, false);\\n              this.scope.checkLocalExport(local);\\n            }\\n          }\\n        }\\n      } else if (node.declaration) {\\n        if (node.declaration.type === \\\"FunctionDeclaration\\\" || node.declaration.type === \\\"ClassDeclaration\\\") {\\n          const id = node.declaration.id;\\n          if (!id) throw new Error(\\\"Assertion failure\\\");\\n          this.checkDuplicateExports(node, id.name);\\n        } else if (node.declaration.type === \\\"VariableDeclaration\\\") {\\n          for (const declaration of node.declaration.declarations) {\\n            this.checkDeclaration(declaration.id);\\n          }\\n        }\\n      }\\n    }\\n  }\\n  checkDeclaration(node) {\\n    if (node.type === \\\"Identifier\\\") {\\n      this.checkDuplicateExports(node, node.name);\\n    } else if (node.type === \\\"ObjectPattern\\\") {\\n      for (const prop of node.properties) {\\n        this.checkDeclaration(prop);\\n      }\\n    } else if (node.type === \\\"ArrayPattern\\\") {\\n      for (const elem of node.elements) {\\n        if (elem) {\\n          this.checkDeclaration(elem);\\n        }\\n      }\\n    } else if (node.type === \\\"ObjectProperty\\\") {\\n      this.checkDeclaration(node.value);\\n    } else if (node.type === \\\"RestElement\\\") {\\n      this.checkDeclaration(node.argument);\\n    } else if (node.type === \\\"AssignmentPattern\\\") {\\n      this.checkDeclaration(node.left);\\n    }\\n  }\\n  checkDuplicateExports(node, exportName) {\\n    if (this.exportedIdentifiers.has(exportName)) {\\n      if (exportName === \\\"default\\\") {\\n        this.raise(Errors.DuplicateDefaultExport, node);\\n      } else {\\n        this.raise(Errors.DuplicateExport, node, {\\n          exportName\\n        });\\n      }\\n    }\\n    this.exportedIdentifiers.add(exportName);\\n  }\\n  parseExportSpecifiers(isInTypeExport) {\\n    const nodes = [];\\n    let first = true;\\n    this.expect(5);\\n    while (!this.eat(8)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        this.expect(12);\\n        if (this.eat(8)) break;\\n      }\\n      const isMaybeTypeOnly = this.isContextual(130);\\n      const isString = this.match(133);\\n      const node = this.startNode();\\n      node.local = this.parseModuleExportName();\\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\\n    }\\n    return nodes;\\n  }\\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\\n    if (this.eatContextual(93)) {\\n      node.exported = this.parseModuleExportName();\\n    } else if (isString) {\\n      node.exported = cloneStringLiteral(node.local);\\n    } else if (!node.exported) {\\n      node.exported = cloneIdentifier(node.local);\\n    }\\n    return this.finishNode(node, \\\"ExportSpecifier\\\");\\n  }\\n  parseModuleExportName() {\\n    if (this.match(133)) {\\n      const result = this.parseStringLiteral(this.state.value);\\n      const surrogate = result.value.match(loneSurrogate);\\n      if (surrogate) {\\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\\n          surrogateCharCode: surrogate[0].charCodeAt(0)\\n        });\\n      }\\n      return result;\\n    }\\n    return this.parseIdentifier(true);\\n  }\\n  isJSONModuleImport(node) {\\n    if (node.assertions != null) {\\n      return node.assertions.some(({\\n        key,\\n        value\\n      }) => {\\n        return value.value === \\\"json\\\" && (key.type === \\\"Identifier\\\" ? key.name === \\\"type\\\" : key.value === \\\"type\\\");\\n      });\\n    }\\n    return false;\\n  }\\n  checkImportReflection(node) {\\n    const {\\n      specifiers\\n    } = node;\\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\\n    if (node.phase === \\\"source\\\") {\\n      if (singleBindingType !== \\\"ImportDefaultSpecifier\\\") {\\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\\n      }\\n    } else if (node.phase === \\\"defer\\\") {\\n      if (singleBindingType !== \\\"ImportNamespaceSpecifier\\\") {\\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\\n      }\\n    } else if (node.module) {\\n      var _node$assertions;\\n      if (singleBindingType !== \\\"ImportDefaultSpecifier\\\") {\\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\\n      }\\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\\n      }\\n    }\\n  }\\n  checkJSONModuleImport(node) {\\n    if (this.isJSONModuleImport(node) && node.type !== \\\"ExportAllDeclaration\\\") {\\n      const {\\n        specifiers\\n      } = node;\\n      if (specifiers != null) {\\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\\n          let imported;\\n          if (specifier.type === \\\"ExportSpecifier\\\") {\\n            imported = specifier.local;\\n          } else if (specifier.type === \\\"ImportSpecifier\\\") {\\n            imported = specifier.imported;\\n          }\\n          if (imported !== undefined) {\\n            return imported.type === \\\"Identifier\\\" ? imported.name !== \\\"default\\\" : imported.value !== \\\"default\\\";\\n          }\\n        });\\n        if (nonDefaultNamedSpecifier !== undefined) {\\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\\n        }\\n      }\\n    }\\n  }\\n  isPotentialImportPhase(isExport) {\\n    if (isExport) return false;\\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\\n  }\\n  applyImportPhase(node, isExport, phase, loc) {\\n    if (isExport) {\\n      return;\\n    }\\n    if (phase === \\\"module\\\") {\\n      this.expectPlugin(\\\"importReflection\\\", loc);\\n      node.module = true;\\n    } else if (this.hasPlugin(\\\"importReflection\\\")) {\\n      node.module = false;\\n    }\\n    if (phase === \\\"source\\\") {\\n      this.expectPlugin(\\\"sourcePhaseImports\\\", loc);\\n      node.phase = \\\"source\\\";\\n    } else if (phase === \\\"defer\\\") {\\n      this.expectPlugin(\\\"deferredImportEvaluation\\\", loc);\\n      node.phase = \\\"defer\\\";\\n    } else if (this.hasPlugin(\\\"sourcePhaseImports\\\")) {\\n      node.phase = null;\\n    }\\n  }\\n  parseMaybeImportPhase(node, isExport) {\\n    if (!this.isPotentialImportPhase(isExport)) {\\n      this.applyImportPhase(node, isExport, null);\\n      return null;\\n    }\\n    const phaseIdentifier = this.parseIdentifier(true);\\n    const {\\n      type\\n    } = this.state;\\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\\n    if (isImportPhase) {\\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\\n      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);\\n      return null;\\n    } else {\\n      this.applyImportPhase(node, isExport, null);\\n      return phaseIdentifier;\\n    }\\n  }\\n  isPrecedingIdImportPhase(phase) {\\n    const {\\n      type\\n    } = this.state;\\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\\n  }\\n  parseImport(node) {\\n    if (this.match(133)) {\\n      return this.parseImportSourceAndAttributes(node);\\n    }\\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\\n  }\\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\\n    node.specifiers = [];\\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\\n    const parseNext = !hasDefault || this.eat(12);\\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\\n    this.expectContextual(98);\\n    return this.parseImportSourceAndAttributes(node);\\n  }\\n  parseImportSourceAndAttributes(node) {\\n    var _node$specifiers2;\\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\\n    node.source = this.parseImportSource();\\n    this.maybeParseImportAttributes(node);\\n    this.checkImportReflection(node);\\n    this.checkJSONModuleImport(node);\\n    this.semicolon();\\n    return this.finishNode(node, \\\"ImportDeclaration\\\");\\n  }\\n  parseImportSource() {\\n    if (!this.match(133)) this.unexpected();\\n    return this.parseExprAtom();\\n  }\\n  parseImportSpecifierLocal(node, specifier, type) {\\n    specifier.local = this.parseIdentifier();\\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\\n  }\\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\\n    this.checkLVal(specifier.local, {\\n      in: {\\n        type\\n      },\\n      binding: bindingType\\n    });\\n    return this.finishNode(specifier, type);\\n  }\\n  parseImportAttributes() {\\n    this.expect(5);\\n    const attrs = [];\\n    const attrNames = new Set();\\n    do {\\n      if (this.match(8)) {\\n        break;\\n      }\\n      const node = this.startNode();\\n      const keyName = this.state.value;\\n      if (attrNames.has(keyName)) {\\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\\n          key: keyName\\n        });\\n      }\\n      attrNames.add(keyName);\\n      if (this.match(133)) {\\n        node.key = this.parseStringLiteral(keyName);\\n      } else {\\n        node.key = this.parseIdentifier(true);\\n      }\\n      this.expect(14);\\n      if (!this.match(133)) {\\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\\n      }\\n      node.value = this.parseStringLiteral(this.state.value);\\n      attrs.push(this.finishNode(node, \\\"ImportAttribute\\\"));\\n    } while (this.eat(12));\\n    this.expect(8);\\n    return attrs;\\n  }\\n  parseModuleAttributes() {\\n    const attrs = [];\\n    const attributes = new Set();\\n    do {\\n      const node = this.startNode();\\n      node.key = this.parseIdentifier(true);\\n      if (node.key.name !== \\\"type\\\") {\\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\\n      }\\n      if (attributes.has(node.key.name)) {\\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\\n          key: node.key.name\\n        });\\n      }\\n      attributes.add(node.key.name);\\n      this.expect(14);\\n      if (!this.match(133)) {\\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\\n      }\\n      node.value = this.parseStringLiteral(this.state.value);\\n      attrs.push(this.finishNode(node, \\\"ImportAttribute\\\"));\\n    } while (this.eat(12));\\n    return attrs;\\n  }\\n  maybeParseImportAttributes(node) {\\n    let attributes;\\n    let useWith = false;\\n    if (this.match(76)) {\\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\\n        return;\\n      }\\n      this.next();\\n      {\\n        if (this.hasPlugin(\\\"moduleAttributes\\\")) {\\n          attributes = this.parseModuleAttributes();\\n        } else {\\n          this.expectImportAttributesPlugin();\\n          attributes = this.parseImportAttributes();\\n        }\\n      }\\n      useWith = true;\\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\\n      if (this.hasPlugin(\\\"importAttributes\\\")) {\\n        if (this.getPluginOption(\\\"importAttributes\\\", \\\"deprecatedAssertSyntax\\\") !== true) {\\n          this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\\n        }\\n        this.addExtra(node, \\\"deprecatedAssertSyntax\\\", true);\\n      } else {\\n        this.expectOnePlugin([\\\"importAttributes\\\", \\\"importAssertions\\\"]);\\n      }\\n      this.next();\\n      attributes = this.parseImportAttributes();\\n    } else if (this.hasPlugin(\\\"importAttributes\\\") || this.hasPlugin(\\\"importAssertions\\\")) {\\n      attributes = [];\\n    } else {\\n      if (this.hasPlugin(\\\"moduleAttributes\\\")) {\\n        attributes = [];\\n      } else return;\\n    }\\n    if (!useWith && this.hasPlugin(\\\"importAssertions\\\")) {\\n      node.assertions = attributes;\\n    } else {\\n      node.attributes = attributes;\\n    }\\n  }\\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\\n    if (maybeDefaultIdentifier) {\\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\\n      specifier.local = maybeDefaultIdentifier;\\n      node.specifiers.push(this.finishImportSpecifier(specifier, \\\"ImportDefaultSpecifier\\\"));\\n      return true;\\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\\n      this.parseImportSpecifierLocal(node, this.startNode(), \\\"ImportDefaultSpecifier\\\");\\n      return true;\\n    }\\n    return false;\\n  }\\n  maybeParseStarImportSpecifier(node) {\\n    if (this.match(55)) {\\n      const specifier = this.startNode();\\n      this.next();\\n      this.expectContextual(93);\\n      this.parseImportSpecifierLocal(node, specifier, \\\"ImportNamespaceSpecifier\\\");\\n      return true;\\n    }\\n    return false;\\n  }\\n  parseNamedImportSpecifiers(node) {\\n    let first = true;\\n    this.expect(5);\\n    while (!this.eat(8)) {\\n      if (first) {\\n        first = false;\\n      } else {\\n        if (this.eat(14)) {\\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\\n        }\\n        this.expect(12);\\n        if (this.eat(8)) break;\\n      }\\n      const specifier = this.startNode();\\n      const importedIsString = this.match(133);\\n      const isMaybeTypeOnly = this.isContextual(130);\\n      specifier.imported = this.parseModuleExportName();\\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \\\"type\\\" || node.importKind === \\\"typeof\\\", isMaybeTypeOnly, undefined);\\n      node.specifiers.push(importSpecifier);\\n    }\\n  }\\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\\n    if (this.eatContextual(93)) {\\n      specifier.local = this.parseIdentifier();\\n    } else {\\n      const {\\n        imported\\n      } = specifier;\\n      if (importedIsString) {\\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\\n          importName: imported.value\\n        });\\n      }\\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\\n      if (!specifier.local) {\\n        specifier.local = cloneIdentifier(imported);\\n      }\\n    }\\n    return this.finishImportSpecifier(specifier, \\\"ImportSpecifier\\\", bindingType);\\n  }\\n  isThisParam(param) {\\n    return param.type === \\\"Identifier\\\" && param.name === \\\"this\\\";\\n  }\\n}\\nclass Parser extends StatementParser {\\n  constructor(options, input) {\\n    options = getOptions(options);\\n    super(options, input);\\n    this.options = options;\\n    this.initializeScopes();\\n    this.plugins = pluginsMap(this.options.plugins);\\n    this.filename = options.sourceFilename;\\n  }\\n  getScopeHandler() {\\n    return ScopeHandler;\\n  }\\n  parse() {\\n    this.enterInitialScopes();\\n    const file = this.startNode();\\n    const program = this.startNode();\\n    this.nextToken();\\n    file.errors = null;\\n    this.parseTopLevel(file, program);\\n    file.errors = this.state.errors;\\n    file.comments.length = this.state.commentsLen;\\n    return file;\\n  }\\n}\\nfunction pluginsMap(plugins) {\\n  const pluginMap = new Map();\\n  for (const plugin of plugins) {\\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\\n  }\\n  return pluginMap;\\n}\\nfunction parse(input, options) {\\n  var _options;\\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \\\"unambiguous\\\") {\\n    options = Object.assign({}, options);\\n    try {\\n      options.sourceType = \\\"module\\\";\\n      const parser = getParser(options, input);\\n      const ast = parser.parse();\\n      if (parser.sawUnambiguousESM) {\\n        return ast;\\n      }\\n      if (parser.ambiguousScriptDifferentAst) {\\n        try {\\n          options.sourceType = \\\"script\\\";\\n          return getParser(options, input).parse();\\n        } catch (_unused) {}\\n      } else {\\n        ast.program.sourceType = \\\"script\\\";\\n      }\\n      return ast;\\n    } catch (moduleError) {\\n      try {\\n        options.sourceType = \\\"script\\\";\\n        return getParser(options, input).parse();\\n      } catch (_unused2) {}\\n      throw moduleError;\\n    }\\n  } else {\\n    return getParser(options, input).parse();\\n  }\\n}\\nfunction parseExpression(input, options) {\\n  const parser = getParser(options, input);\\n  if (parser.options.strictMode) {\\n    parser.state.strict = true;\\n  }\\n  return parser.getExpression();\\n}\\nfunction generateExportedTokenTypes(internalTokenTypes) {\\n  const tokenTypes = {};\\n  for (const typeName of Object.keys(internalTokenTypes)) {\\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\\n  }\\n  return tokenTypes;\\n}\\nconst tokTypes = generateExportedTokenTypes(tt);\\nfunction getParser(options, input) {\\n  let cls = Parser;\\n  if (options != null && options.plugins) {\\n    validatePlugins(options.plugins);\\n    cls = getParserClass(options.plugins);\\n  }\\n  return new cls(options, input);\\n}\\nconst parserClassCache = {};\\nfunction getParserClass(pluginsFromOptions) {\\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\\n  const key = pluginList.join(\\\"/\\\");\\n  let cls = parserClassCache[key];\\n  if (!cls) {\\n    cls = Parser;\\n    for (const plugin of pluginList) {\\n      cls = mixinPlugins[plugin](cls);\\n    }\\n    parserClassCache[key] = cls;\\n  }\\n  return cls;\\n}\\nexports.parse = parse;\\nexports.parseExpression = parseExpression;\\nexports.tokTypes = tokTypes;\\n//# sourceMappingURL=index.js.map\\n\"],\n  \"mappings\": \"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,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,KAAK,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,KAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,KAAK,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,MAAM,IAAI,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,MAAM,KAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,MAAM,GAAG,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,KAAK,MAAM,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,MAAM,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,MAAM,IAAI,GAAG,GAAG,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,MAAM,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,MAAM,OAAO,IAAI,MAAM,GAAG,KAAK,GAAG,MAAM,IAAI,MAAM,IAAI,KAAK,MAAM,KAAK,MAAM,MAAM,GAAG,IAAI;AAC1hE,MAAM,wBAAwB,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,KAAK,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,MAAM,GAAG,GAAG,IAAI,OAAO,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,MAAM,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,OAAO,GAAG,MAAM,IAAI,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,MAAM,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,GAAG,GAAG,GAAG,MAAM,GAAG,QAAQ,GAAG;AAC7hC,SAAS,cAAcC,OAAM,KAAK;AAChC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,SAAS,IAAI,QAAQ,IAAI,QAAQ,KAAK,GAAG;AACvD,WAAO,IAAI,CAAC;AACZ,QAAI,MAAMA;AAAM,aAAO;AACvB,WAAO,IAAI,IAAI,CAAC;AAChB,QAAI,OAAOA;AAAM,aAAO;AAAA,EAC1B;AACA,SAAO;AACT;AACA,SAAS,kBAAkBA,OAAM;AAC/B,MAAIA,QAAO;AAAI,WAAOA,UAAS;AAC/B,MAAIA,SAAQ;AAAI,WAAO;AACvB,MAAIA,QAAO;AAAI,WAAOA,UAAS;AAC/B,MAAIA,SAAQ;AAAK,WAAO;AACxB,MAAIA,SAAQ,OAAQ;AAClB,WAAOA,SAAQ,OAAQ,wBAAwB,KAAK,OAAO,aAAaA,KAAI,CAAC;AAAA,EAC/E;AACA,SAAO,cAAcA,OAAM,0BAA0B;AACvD;AACA,SAAS,iBAAiBA,OAAM;AAC9B,MAAIA,QAAO;AAAI,WAAOA,UAAS;AAC/B,MAAIA,QAAO;AAAI,WAAO;AACtB,MAAIA,QAAO;AAAI,WAAO;AACtB,MAAIA,SAAQ;AAAI,WAAO;AACvB,MAAIA,QAAO;AAAI,WAAOA,UAAS;AAC/B,MAAIA,SAAQ;AAAK,WAAO;AACxB,MAAIA,SAAQ,OAAQ;AAClB,WAAOA,SAAQ,OAAQ,mBAAmB,KAAK,OAAO,aAAaA,KAAI,CAAC;AAAA,EAC1E;AACA,SAAO,cAAcA,OAAM,0BAA0B,KAAK,cAAcA,OAAM,qBAAqB;AACrG;AACA,MAAM,gBAAgB;AAAA,EACpB,SAAS,CAAC,SAAS,QAAQ,SAAS,YAAY,YAAY,WAAW,MAAM,QAAQ,WAAW,OAAO,YAAY,MAAM,UAAU,UAAU,SAAS,OAAO,OAAO,SAAS,SAAS,QAAQ,OAAO,QAAQ,SAAS,SAAS,WAAW,UAAU,UAAU,QAAQ,QAAQ,SAAS,MAAM,cAAc,UAAU,QAAQ,QAAQ;AAAA,EACrU,QAAQ,CAAC,cAAc,aAAa,OAAO,WAAW,WAAW,aAAa,UAAU,UAAU,OAAO;AAAA,EACzG,YAAY,CAAC,QAAQ,WAAW;AAClC;AACA,MAAM,WAAW,IAAI,IAAI,cAAc,OAAO;AAC9C,MAAM,yBAAyB,IAAI,IAAI,cAAc,MAAM;AAC3D,MAAM,6BAA6B,IAAI,IAAI,cAAc,UAAU;AACnE,SAAS,eAAe,MAAM,UAAU;AACtC,SAAO,YAAY,SAAS,WAAW,SAAS;AAClD;AACA,SAAS,qBAAqB,MAAM,UAAU;AAC5C,SAAO,eAAe,MAAM,QAAQ,KAAK,uBAAuB,IAAI,IAAI;AAC1E;AACA,SAAS,6BAA6B,MAAM;AAC1C,SAAO,2BAA2B,IAAI,IAAI;AAC5C;AACA,SAAS,yBAAyB,MAAM,UAAU;AAChD,SAAO,qBAAqB,MAAM,QAAQ,KAAK,6BAA6B,IAAI;AAClF;AACA,SAAS,UAAU,MAAM;AACvB,SAAO,SAAS,IAAI,IAAI;AAC1B;AACA,SAAS,gBAAgB,SAAS,MAAM,OAAO;AAC7C,SAAO,YAAY,MAAM,SAAS,MAAM,kBAAkB,KAAK;AACjE;AACA,MAAM,sBAAsB,oBAAI,IAAI,CAAC,SAAS,QAAQ,SAAS,YAAY,YAAY,WAAW,MAAM,QAAQ,WAAW,OAAO,YAAY,MAAM,UAAU,UAAU,SAAS,OAAO,OAAO,SAAS,SAAS,QAAQ,OAAO,QAAQ,SAAS,SAAS,WAAW,UAAU,UAAU,QAAQ,QAAQ,SAAS,MAAM,cAAc,UAAU,QAAQ,UAAU,cAAc,aAAa,OAAO,WAAW,WAAW,aAAa,UAAU,UAAU,SAAS,QAAQ,aAAa,QAAQ,OAAO,CAAC;AACze,SAAS,kBAAkB,MAAM;AAC/B,SAAO,oBAAoB,IAAI,IAAI;AACrC;AACA,MAAM,MAAM;AAAA,EACV,YAAY,OAAO;AACjB,SAAK,QAAQ;AACb,SAAK,QAAQ,oBAAI,IAAI;AACrB,SAAK,mBAAmB;AACxB,SAAK,QAAQ;AAAA,EACf;AACF;AACA,MAAM,aAAa;AAAA,EACjB,YAAY,QAAQ,UAAU;AAC5B,SAAK,SAAS;AACd,SAAK,aAAa,CAAC;AACnB,SAAK,WAAW;AAChB,SAAK,mBAAmB,oBAAI,IAAI;AAChC,SAAK,SAAS;AACd,SAAK,WAAW;AAAA,EAClB;AAAA,EACA,IAAI,aAAa;AACf,YAAQ,KAAK,aAAa,EAAE,QAAQ,KAAK;AAAA,EAC3C;AAAA,EACA,IAAI,aAAa;AACf,YAAQ,KAAK,qBAAqB,IAAI,KAAK;AAAA,EAC7C;AAAA,EACA,IAAI,aAAa;AACf,YAAQ,KAAK,sBAAsB,IAAI,MAAM;AAAA,EAC/C;AAAA,EACA,IAAI,mBAAmB;AACrB,YAAQ,KAAK,sBAAsB,IAAI,MAAM;AAAA,EAC/C;AAAA,EACA,IAAI,UAAU;AACZ,YAAQ,KAAK,sBAAsB,IAAI,MAAM;AAAA,EAC/C;AAAA,EACA,IAAI,kCAAkC;AACpC,UAAM,QAAQ,KAAK,sBAAsB;AACzC,YAAQ,QAAQ,MAAM,MAAM,QAAQ,OAAO;AAAA,EAC7C;AAAA,EACA,IAAI,gBAAgB;AAClB,aAAS,IAAI,KAAK,WAAW,SAAS,KAAI,KAAK;AAC7C,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK,WAAW,CAAC;AACrB,UAAI,QAAQ,KAAK;AACf,eAAO;AAAA,MACT;AACA,UAAI,SAAS,MAAM,KAAK;AACtB,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EACA,IAAI,qBAAqB;AACvB,YAAQ,KAAK,sBAAsB,IAAI,KAAK;AAAA,EAC9C;AAAA,EACA,IAAI,sBAAsB;AACxB,WAAO,KAAK,2BAA2B,KAAK,aAAa,CAAC;AAAA,EAC5D;AAAA,EACA,YAAY,OAAO;AACjB,WAAO,IAAI,MAAM,KAAK;AAAA,EACxB;AAAA,EACA,MAAM,OAAO;AACX,SAAK,WAAW,KAAK,KAAK,YAAY,KAAK,CAAC;AAAA,EAC9C;AAAA,EACA,OAAO;AACL,UAAM,QAAQ,KAAK,WAAW,IAAI;AAClC,WAAO,MAAM;AAAA,EACf;AAAA,EACA,2BAA2B,OAAO;AAChC,WAAO,CAAC,EAAE,MAAM,SAAS,IAAI,QAAQ,CAAC,KAAK,OAAO,YAAY,MAAM,QAAQ;AAAA,EAC9E;AAAA,EACA,YAAY,MAAM,aAAa,KAAK;AAClC,QAAI,QAAQ,KAAK,aAAa;AAC9B,QAAI,cAAc,KAAK,cAAc,IAAI;AACvC,WAAK,0BAA0B,OAAO,MAAM,aAAa,GAAG;AAC5D,UAAI,OAAO,MAAM,MAAM,IAAI,IAAI,KAAK;AACpC,UAAI,cAAc,IAAI;AACpB,eAAO,OAAO;AAAA,MAChB,OAAO;AACL,YAAI,CAAC,MAAM,kBAAkB;AAC3B,gBAAM,mBAAmB;AAAA,QAC3B;AACA,eAAO,OAAO;AAAA,MAChB;AACA,YAAM,MAAM,IAAI,MAAM,IAAI;AAC1B,UAAI,cAAc,GAAG;AACnB,aAAK,mBAAmB,OAAO,IAAI;AAAA,MACrC;AAAA,IACF,WAAW,cAAc,GAAG;AAC1B,eAAS,IAAI,KAAK,WAAW,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACpD,gBAAQ,KAAK,WAAW,CAAC;AACzB,aAAK,0BAA0B,OAAO,MAAM,aAAa,GAAG;AAC5D,cAAM,MAAM,IAAI,OAAO,MAAM,MAAM,IAAI,IAAI,KAAK,KAAK,CAAC;AACtD,aAAK,mBAAmB,OAAO,IAAI;AACnC,YAAI,MAAM,QAAQ;AAAK;AAAA,MACzB;AAAA,IACF;AACA,QAAI,KAAK,OAAO,YAAY,MAAM,QAAQ,GAAG;AAC3C,WAAK,iBAAiB,OAAO,IAAI;AAAA,IACnC;AAAA,EACF;AAAA,EACA,mBAAmB,OAAO,MAAM;AAC9B,QAAI,KAAK,OAAO,YAAY,MAAM,QAAQ,GAAG;AAC3C,WAAK,iBAAiB,OAAO,IAAI;AAAA,IACnC;AAAA,EACF;AAAA,EACA,0BAA0B,OAAO,MAAM,aAAa,KAAK;AACvD,QAAI,KAAK,oBAAoB,OAAO,MAAM,WAAW,GAAG;AACtD,WAAK,OAAO,MAAM,OAAO,kBAAkB,KAAK;AAAA,QAC9C,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,oBAAoB,OAAO,MAAM,aAAa;AAC5C,QAAI,EAAE,cAAc;AAAI,aAAO;AAC/B,QAAI,cAAc,GAAG;AACnB,aAAO,MAAM,MAAM,IAAI,IAAI;AAAA,IAC7B;AACA,UAAM,OAAO,MAAM,MAAM,IAAI,IAAI;AACjC,QAAI,cAAc,IAAI;AACpB,cAAQ,OAAO,KAAK,KAAK,CAAC,KAAK,2BAA2B,KAAK,MAAM,OAAO,KAAK;AAAA,IACnF;AACA,YAAQ,OAAO,KAAK,KAAK,EAAE,MAAM,QAAQ,KAAK,MAAM,qBAAqB,SAAS,CAAC,KAAK,2BAA2B,KAAK,MAAM,OAAO,KAAK;AAAA,EAC5I;AAAA,EACA,iBAAiB,IAAI;AACnB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,UAAM,gBAAgB,KAAK,WAAW,CAAC;AACvC,QAAI,CAAC,cAAc,MAAM,IAAI,IAAI,GAAG;AAClC,WAAK,iBAAiB,IAAI,MAAM,GAAG,IAAI,KAAK;AAAA,IAC9C;AAAA,EACF;AAAA,EACA,eAAe;AACb,WAAO,KAAK,WAAW,KAAK,WAAW,SAAS,CAAC;AAAA,EACnD;AAAA,EACA,uBAAuB;AACrB,aAAS,IAAI,KAAK,WAAW,SAAS,KAAI,KAAK;AAC7C,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK,WAAW,CAAC;AACrB,UAAI,QAAQ,KAAK;AACf,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EACA,wBAAwB;AACtB,aAAS,IAAI,KAAK,WAAW,SAAS,KAAI,KAAK;AAC7C,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK,WAAW,CAAC;AACrB,UAAI,SAAS,MAAM,OAAO,EAAE,QAAQ,IAAI;AACtC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;AACA,MAAM,kBAAkB,MAAM;AAAA,EAC5B,eAAe,MAAM;AACnB,UAAM,GAAG,IAAI;AACb,SAAK,mBAAmB,oBAAI,IAAI;AAAA,EAClC;AACF;AACA,MAAM,yBAAyB,aAAa;AAAA,EAC1C,YAAY,OAAO;AACjB,WAAO,IAAI,UAAU,KAAK;AAAA,EAC5B;AAAA,EACA,YAAY,MAAM,aAAa,KAAK;AAClC,UAAM,QAAQ,KAAK,aAAa;AAChC,QAAI,cAAc,MAAM;AACtB,WAAK,0BAA0B,OAAO,MAAM,aAAa,GAAG;AAC5D,WAAK,mBAAmB,OAAO,IAAI;AACnC,YAAM,iBAAiB,IAAI,IAAI;AAC/B;AAAA,IACF;AACA,UAAM,YAAY,MAAM,aAAa,GAAG;AAAA,EAC1C;AAAA,EACA,oBAAoB,OAAO,MAAM,aAAa;AAC5C,QAAI,MAAM,oBAAoB,OAAO,MAAM,WAAW;AAAG,aAAO;AAChE,QAAI,cAAc,QAAQ,CAAC,MAAM,iBAAiB,IAAI,IAAI,GAAG;AAC3D,YAAM,OAAO,MAAM,MAAM,IAAI,IAAI;AACjC,cAAQ,OAAO,KAAK,MAAM,OAAO,KAAK;AAAA,IACxC;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB,IAAI;AACnB,QAAI,CAAC,KAAK,WAAW,CAAC,EAAE,iBAAiB,IAAI,GAAG,IAAI,GAAG;AACrD,YAAM,iBAAiB,EAAE;AAAA,IAC3B;AAAA,EACF;AACF;AACA,MAAM,WAAW;AAAA,EACf,cAAc;AACZ,SAAK,oBAAoB;AACzB,SAAK,8BAA8B;AAAA,EACrC;AAAA,EACA,UAAU,cAAc;AACtB,QAAI,OAAO,iBAAiB,UAAU;AACpC,aAAO,KAAK,QAAQ,IAAI,YAAY;AAAA,IACtC,OAAO;AACL,YAAM,CAAC,YAAY,aAAa,IAAI;AACpC,UAAI,CAAC,KAAK,UAAU,UAAU,GAAG;AAC/B,eAAO;AAAA,MACT;AACA,YAAM,gBAAgB,KAAK,QAAQ,IAAI,UAAU;AACjD,iBAAW,OAAO,OAAO,KAAK,aAAa,GAAG;AAC5C,aAAK,iBAAiB,OAAO,SAAS,cAAc,GAAG,OAAO,cAAc,GAAG,GAAG;AAChF,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,gBAAgB,QAAQ,MAAM;AAC5B,QAAI;AACJ,YAAQ,oBAAoB,KAAK,QAAQ,IAAI,MAAM,MAAM,OAAO,SAAS,kBAAkB,IAAI;AAAA,EACjG;AACF;AACA,SAAS,oBAAoB,MAAM,UAAU;AAC3C,MAAI,KAAK,qBAAqB,QAAW;AACvC,SAAK,mBAAmB;AAAA,EAC1B,OAAO;AACL,SAAK,iBAAiB,QAAQ,GAAG,QAAQ;AAAA,EAC3C;AACF;AACA,SAAS,mBAAmB,MAAM,UAAU;AAC1C,MAAI,KAAK,oBAAoB,QAAW;AACtC,SAAK,kBAAkB;AAAA,EACzB,OAAO;AACL,SAAK,gBAAgB,QAAQ,GAAG,QAAQ;AAAA,EAC1C;AACF;AACA,SAAS,iBAAiB,MAAM,UAAU;AACxC,MAAI,KAAK,kBAAkB,QAAW;AACpC,SAAK,gBAAgB;AAAA,EACvB,OAAO;AACL,SAAK,cAAc,QAAQ,GAAG,QAAQ;AAAA,EACxC;AACF;AACA,SAAS,oBAAoB,MAAM,UAAU,WAAW;AACtD,MAAI,cAAc;AAClB,MAAI,IAAI,SAAS;AACjB,SAAO,gBAAgB,QAAQ,IAAI,GAAG;AACpC,kBAAc,SAAS,EAAE,CAAC;AAAA,EAC5B;AACA,MAAI,gBAAgB,QAAQ,YAAY,QAAQ,UAAU,OAAO;AAC/D,qBAAiB,MAAM,UAAU,QAAQ;AAAA,EAC3C,OAAO;AACL,wBAAoB,aAAa,UAAU,QAAQ;AAAA,EACrD;AACF;AACA,MAAM,uBAAuB,WAAW;AAAA,EACtC,WAAW,SAAS;AAClB,QAAI,KAAK;AAAU,cAAQ,IAAI,WAAW,KAAK;AAC/C,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,KAAK,SAAS,UAAU;AAAa,WAAK,SAAS,SAAS;AAChE,SAAK,SAAS,KAAK,OAAO;AAC1B,SAAK,MAAM;AAAA,EACb;AAAA,EACA,eAAe,MAAM;AACnB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,qBAAqB,aAAa;AACxC,QAAI,uBAAuB;AAAG;AAC9B,QAAI,IAAI,qBAAqB;AAC7B,UAAM,gBAAgB,aAAa,CAAC;AACpC,QAAI,cAAc,UAAU,KAAK,KAAK;AACpC,oBAAc,cAAc;AAC5B;AAAA,IACF;AACA,UAAM;AAAA,MACJ,OAAO;AAAA,IACT,IAAI;AACJ,WAAO,KAAK,GAAG,KAAK;AAClB,YAAM,YAAY,aAAa,CAAC;AAChC,YAAM,aAAa,UAAU;AAC7B,UAAI,aAAa,WAAW;AAC1B,kBAAU,iBAAiB;AAC3B,aAAK,gBAAgB,SAAS;AAC9B,qBAAa,OAAO,GAAG,CAAC;AAAA,MAC1B,OAAO;AACL,YAAI,eAAe,WAAW;AAC5B,oBAAU,eAAe;AAAA,QAC3B;AACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,gBAAgB,WAAW;AACzB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,UAAU,gBAAgB,QAAQ,UAAU,iBAAiB,MAAM;AACrE,UAAI,UAAU,gBAAgB,MAAM;AAClC,4BAAoB,UAAU,aAAa,QAAQ;AAAA,MACrD;AACA,UAAI,UAAU,iBAAiB,MAAM;AACnC,2BAAmB,UAAU,cAAc,QAAQ;AAAA,MACrD;AAAA,IACF,OAAO;AACL,YAAM;AAAA,QACJ,gBAAgB;AAAA,QAChB,OAAO;AAAA,MACT,IAAI;AACJ,UAAI,KAAK,MAAM,WAAW,eAAe,CAAC,MAAM,IAAI;AAClD,gBAAQ,KAAK,MAAM;AAAA,UACjB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,gCAAoB,MAAM,KAAK,YAAY,SAAS;AACpD;AAAA,UACF,KAAK;AAAA,UACL,KAAK;AACH,gCAAoB,MAAM,KAAK,WAAW,SAAS;AACnD;AAAA,UACF,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,gCAAoB,MAAM,KAAK,QAAQ,SAAS;AAChD;AAAA,UACF,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,gCAAoB,MAAM,KAAK,UAAU,SAAS;AAClD;AAAA,UACF,KAAK;AAAA,UACL,KAAK;AACH,gCAAoB,MAAM,KAAK,YAAY,SAAS;AACpD;AAAA,UACF,SACE;AACE,6BAAiB,MAAM,QAAQ;AAAA,UACjC;AAAA,QACJ;AAAA,MACF,OAAO;AACL,yBAAiB,MAAM,QAAQ;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAAA,EACA,4BAA4B;AAC1B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,aAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,WAAK,gBAAgB,aAAa,CAAC,CAAC;AAAA,IACtC;AACA,SAAK,MAAM,eAAe,CAAC;AAAA,EAC7B;AAAA,EACA,kCAAkC,MAAM;AACtC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,WAAW;AAAG;AAClB,UAAM,YAAY,aAAa,SAAS,CAAC;AACzC,QAAI,UAAU,gBAAgB,MAAM;AAClC,gBAAU,cAAc;AAAA,IAC1B;AAAA,EACF;AAAA,EACA,uCAAuC,MAAM;AAC3C,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,WAAW;AAAG;AAClB,QAAI,aAAa,SAAS,CAAC,EAAE,iBAAiB,MAAM;AAClD,mBAAa,SAAS,CAAC,EAAE,eAAe;AAAA,IAC1C,WAAW,UAAU,KAAK,aAAa,SAAS,CAAC,EAAE,iBAAiB,MAAM;AACxE,mBAAa,SAAS,CAAC,EAAE,eAAe;AAAA,IAC1C;AAAA,EACF;AAAA,EACA,wBAAwB,MAAM,OAAO,KAAK;AACxC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,qBAAqB,aAAa;AACxC,QAAI,uBAAuB;AAAG;AAC9B,QAAI,IAAI,qBAAqB;AAC7B,WAAO,KAAK,GAAG,KAAK;AAClB,YAAM,YAAY,aAAa,CAAC;AAChC,YAAM,aAAa,UAAU;AAC7B,YAAM,eAAe,UAAU;AAC/B,UAAI,iBAAiB,KAAK;AACxB,kBAAU,cAAc;AAAA,MAC1B,WAAW,eAAe,OAAO;AAC/B,kBAAU,eAAe;AAAA,MAC3B,WAAW,aAAa,OAAO;AAC7B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AACA,MAAM,YAAY;AAClB,MAAM,aAAa,IAAI,OAAO,UAAU,QAAQ,GAAG;AACnD,SAAS,UAAUA,OAAM;AACvB,UAAQA,OAAM;AAAA,IACZ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AACA,MAAM,iBAAiB;AACvB,MAAM,uBAAuB;AAC7B,MAAM,4BAA4B,IAAI,OAAO,SAAS,qBAAqB,SAAS,UAAU,2CAA2C,QAAQ,GAAG;AACpJ,SAAS,aAAaA,OAAM;AAC1B,UAAQA,OAAM;AAAA,IACZ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AACA,MAAM,MAAM;AAAA,EACV,cAAc;AACZ,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,SAAS,CAAC;AACf,SAAK,mBAAmB;AACxB,SAAK,YAAY,CAAC;AAClB,SAAK,4BAA4B,CAAC;AAClC,SAAK,eAAe;AAAA,MAClB,0BAA0B;AAAA,MAC1B,eAAe;AAAA,IACjB;AACA,SAAK,SAAS,CAAC;AACf,SAAK,cAAc;AACnB,SAAK,eAAe,CAAC;AACrB,SAAK,MAAM;AACX,SAAK,OAAO;AACZ,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,gBAAgB;AACrB,SAAK,kBAAkB;AACvB,SAAK,UAAU,CAAC,MAAM,KAAK;AAC3B,SAAK,gCAAgC;AACrC,SAAK,eAAe,oBAAI,IAAI;AAC5B,SAAK,eAAe;AAAA,EACtB;AAAA,EACA,IAAI,SAAS;AACX,YAAQ,KAAK,QAAQ,KAAK;AAAA,EAC5B;AAAA,EACA,IAAI,OAAO,OAAO;AAChB,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,KAAK;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAAG;AACD,SAAK,SAAS,eAAe,QAAQ,QAAQ,eAAe,OAAO,OAAO,eAAe;AACzF,SAAK,UAAU;AACf,SAAK,YAAY,CAAC;AAClB,SAAK,WAAW,KAAK,SAAS,IAAI,SAAS,WAAW,aAAa,CAAC;AAAA,EACtE;AAAA,EACA,IAAI,yBAAyB;AAC3B,YAAQ,KAAK,QAAQ,KAAK;AAAA,EAC5B;AAAA,EACA,IAAI,uBAAuB,OAAO;AAChC,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,SAAS;AACX,YAAQ,KAAK,QAAQ,KAAK;AAAA,EAC5B;AAAA,EACA,IAAI,OAAO,OAAO;AAChB,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,qBAAqB;AACvB,YAAQ,KAAK,QAAQ,KAAK;AAAA,EAC5B;AAAA,EACA,IAAI,mBAAmB,OAAO;AAC5B,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,iBAAiB;AACnB,YAAQ,KAAK,QAAQ,MAAM;AAAA,EAC7B;AAAA,EACA,IAAI,eAAe,OAAO;AACxB,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,mBAAmB;AACrB,YAAQ,KAAK,QAAQ,MAAM;AAAA,EAC7B;AAAA,EACA,IAAI,iBAAiB,OAAO;AAC1B,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,kBAAkB;AACpB,YAAQ,KAAK,QAAQ,MAAM;AAAA,EAC7B;AAAA,EACA,IAAI,gBAAgB,OAAO;AACzB,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,oCAAoC;AACtC,YAAQ,KAAK,QAAQ,OAAO;AAAA,EAC9B;AAAA,EACA,IAAI,kCAAkC,OAAO;AAC3C,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,YAAY;AACd,YAAQ,KAAK,QAAQ,OAAO;AAAA,EAC9B;AAAA,EACA,IAAI,UAAU,OAAO;AACnB,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,6BAA6B;AAC/B,YAAQ,KAAK,QAAQ,OAAO;AAAA,EAC9B;AAAA,EACA,IAAI,2BAA2B,OAAO;AACpC,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,qBAAqB;AACvB,YAAQ,KAAK,QAAQ,QAAQ;AAAA,EAC/B;AAAA,EACA,IAAI,mBAAmB,OAAO;AAC5B,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,IAAI,cAAc;AAChB,YAAQ,KAAK,QAAQ,QAAQ;AAAA,EAC/B;AAAA,EACA,IAAI,YAAY,OAAO;AACrB,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EACA,cAAc;AACZ,WAAO,IAAI,SAAS,KAAK,SAAS,KAAK,MAAM,KAAK,WAAW,KAAK,GAAG;AAAA,EACvE;AAAA,EACA,QAAQ;AACN,UAAM,QAAQ,IAAI,MAAM;AACxB,UAAM,QAAQ,KAAK;AACnB,UAAM,UAAU,KAAK;AACrB,UAAM,YAAY,KAAK;AACvB,UAAM,WAAW,KAAK;AACtB,UAAM,SAAS,KAAK;AACpB,UAAM,SAAS,KAAK,OAAO,MAAM;AACjC,UAAM,mBAAmB,KAAK;AAC9B,UAAM,YAAY,KAAK,UAAU,MAAM;AACvC,UAAM,4BAA4B,KAAK,0BAA0B,MAAM;AACvE,UAAM,eAAe,KAAK;AAC1B,UAAM,SAAS,KAAK,OAAO,MAAM;AACjC,UAAM,cAAc,KAAK;AACzB,UAAM,eAAe,KAAK,aAAa,MAAM;AAC7C,UAAM,MAAM,KAAK;AACjB,UAAM,OAAO,KAAK;AAClB,UAAM,QAAQ,KAAK;AACnB,UAAM,QAAQ,KAAK;AACnB,UAAM,MAAM,KAAK;AACjB,UAAM,gBAAgB,KAAK;AAC3B,UAAM,kBAAkB,KAAK;AAC7B,UAAM,UAAU,KAAK,QAAQ,MAAM;AACnC,UAAM,gCAAgC,KAAK;AAC3C,UAAM,eAAe,KAAK;AAC1B,UAAM,eAAe,KAAK;AAC1B,WAAO;AAAA,EACT;AACF;AACA,IAAI,WAAW,SAAS,QAAQA,OAAM;AACpC,SAAOA,SAAQ,MAAMA,SAAQ;AAC/B;AACA,MAAM,oCAAoC;AAAA,EACxC,WAAW,oBAAI,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,GAAG,CAAC;AAAA,EACrD,KAAK,oBAAI,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,CAAC;AAChC;AACA,MAAM,mCAAmC;AAAA,EACvC,KAAK,QAAM,OAAO,MAAM,OAAO;AAAA,EAC/B,KAAK,QAAM,MAAM,MAAM,MAAM;AAAA,EAC7B,KAAK,QAAM,MAAM,MAAM,MAAM;AAAA,EAC7B,KAAK,QAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM;AAC/E;AACA,SAAS,mBAAmB,MAAM,OAAO,KAAK,WAAW,SAAS,QAAQ;AACxE,QAAM,aAAa;AACnB,QAAM,mBAAmB;AACzB,QAAM,iBAAiB;AACvB,MAAI,MAAM;AACV,MAAI,kBAAkB;AACtB,MAAI,aAAa;AACjB,QAAM;AAAA,IACJ;AAAA,EACF,IAAI;AACJ,aAAS;AACP,QAAI,OAAO,QAAQ;AACjB,aAAO,aAAa,YAAY,kBAAkB,cAAc;AAChE,aAAO,MAAM,MAAM,YAAY,GAAG;AAClC;AAAA,IACF;AACA,UAAM,KAAK,MAAM,WAAW,GAAG;AAC/B,QAAI,YAAY,MAAM,IAAI,OAAO,GAAG,GAAG;AACrC,aAAO,MAAM,MAAM,YAAY,GAAG;AAClC;AAAA,IACF;AACA,QAAI,OAAO,IAAI;AACb,aAAO,MAAM,MAAM,YAAY,GAAG;AAClC,YAAM,MAAM,gBAAgB,OAAO,KAAK,WAAW,SAAS,SAAS,YAAY,MAAM;AACvF,UAAI,IAAI,OAAO,QAAQ,CAAC,iBAAiB;AACvC,0BAAkB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF,OAAO;AACL,eAAO,IAAI;AAAA,MACb;AACA,OAAC;AAAA,QACC;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI;AACJ,mBAAa;AAAA,IACf,WAAW,OAAO,QAAQ,OAAO,MAAM;AACrC,QAAE;AACF,QAAE;AACF,kBAAY;AAAA,IACd,WAAW,OAAO,MAAM,OAAO,IAAI;AACjC,UAAI,SAAS,YAAY;AACvB,eAAO,MAAM,MAAM,YAAY,GAAG,IAAI;AACtC,UAAE;AACF,YAAI,OAAO,MAAM,MAAM,WAAW,GAAG,MAAM,IAAI;AAC7C,YAAE;AAAA,QACJ;AACA,UAAE;AACF,qBAAa,YAAY;AAAA,MAC3B,OAAO;AACL,eAAO,aAAa,YAAY,kBAAkB,cAAc;AAAA,MAClE;AAAA,IACF,OAAO;AACL,QAAE;AAAA,IACJ;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA,KAAK;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,iBAAiB,CAAC,CAAC;AAAA,EACrB;AACF;AACA,SAAS,YAAY,MAAM,IAAI,OAAO,KAAK;AACzC,MAAI,SAAS,YAAY;AACvB,WAAO,OAAO,MAAM,OAAO,MAAM,MAAM,WAAW,MAAM,CAAC,MAAM;AAAA,EACjE;AACA,SAAO,QAAQ,SAAS,WAAW,KAAK;AAC1C;AACA,SAAS,gBAAgB,OAAO,KAAK,WAAW,SAAS,YAAY,QAAQ;AAC3E,QAAM,iBAAiB,CAAC;AACxB;AACA,QAAM,MAAM,CAAAC,SAAO;AAAA,IACjB;AAAA,IACA,IAAAA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,KAAK,MAAM,WAAW,KAAK;AACjC,UAAQ,IAAI;AAAA,IACV,KAAK;AACH,aAAO,IAAI,IAAI;AAAA,IACjB,KAAK;AACH,aAAO,IAAI,IAAI;AAAA,IACjB,KAAK,KACH;AACE,UAAID;AACJ,OAAC;AAAA,QACC,MAAAA;AAAA,QACA;AAAA,MACF,IAAI,YAAY,OAAO,KAAK,WAAW,SAAS,GAAG,OAAO,gBAAgB,MAAM;AAChF,aAAO,IAAIA,UAAS,OAAO,OAAO,OAAO,aAAaA,KAAI,CAAC;AAAA,IAC7D;AAAA,IACF,KAAK,KACH;AACE,UAAIA;AACJ,OAAC;AAAA,QACC,MAAAA;AAAA,QACA;AAAA,MACF,IAAI,cAAc,OAAO,KAAK,WAAW,SAAS,gBAAgB,MAAM;AACxE,aAAO,IAAIA,UAAS,OAAO,OAAO,OAAO,cAAcA,KAAI,CAAC;AAAA,IAC9D;AAAA,IACF,KAAK;AACH,aAAO,IAAI,GAAI;AAAA,IACjB,KAAK;AACH,aAAO,IAAI,IAAI;AAAA,IACjB,KAAK;AACH,aAAO,IAAI,IAAQ;AAAA,IACrB,KAAK;AACH,aAAO,IAAI,IAAI;AAAA,IACjB,KAAK;AACH,UAAI,MAAM,WAAW,GAAG,MAAM,IAAI;AAChC,UAAE;AAAA,MACJ;AAAA,IACF,KAAK;AACH,kBAAY;AACZ,QAAE;AAAA,IACJ,KAAK;AAAA,IACL,KAAK;AACH,aAAO,IAAI,EAAE;AAAA,IACf,KAAK;AAAA,IACL,KAAK;AACH,UAAI,YAAY;AACd,eAAO,IAAI,IAAI;AAAA,MACjB,OAAO;AACL,eAAO,oBAAoB,MAAM,GAAG,WAAW,OAAO;AAAA,MACxD;AAAA,IACF;AACE,UAAI,MAAM,MAAM,MAAM,IAAI;AACxB,cAAM,WAAW,MAAM;AACvB,cAAM,QAAQ,MAAM,MAAM,UAAU,MAAM,CAAC,EAAE,MAAM,SAAS;AAC5D,YAAI,WAAW,MAAM,CAAC;AACtB,YAAI,QAAQ,SAAS,UAAU,CAAC;AAChC,YAAI,QAAQ,KAAK;AACf,qBAAW,SAAS,MAAM,GAAG,EAAE;AAC/B,kBAAQ,SAAS,UAAU,CAAC;AAAA,QAC9B;AACA,eAAO,SAAS,SAAS;AACzB,cAAM,OAAO,MAAM,WAAW,GAAG;AACjC,YAAI,aAAa,OAAO,SAAS,MAAM,SAAS,IAAI;AAClD,cAAI,YAAY;AACd,mBAAO,IAAI,IAAI;AAAA,UACjB,OAAO;AACL,mBAAO,oBAAoB,UAAU,WAAW,OAAO;AAAA,UACzD;AAAA,QACF;AACA,eAAO,IAAI,OAAO,aAAa,KAAK,CAAC;AAAA,MACvC;AACA,aAAO,IAAI,OAAO,aAAa,EAAE,CAAC;AAAA,EACtC;AACF;AACA,SAAS,YAAY,OAAO,KAAK,WAAW,SAAS,KAAK,UAAU,gBAAgB,QAAQ;AAC1F,QAAM,aAAa;AACnB,MAAI;AACJ,GAAC;AAAA,IACC;AAAA,IACA;AAAA,EACF,IAAI,QAAQ,OAAO,KAAK,WAAW,SAAS,IAAI,KAAK,UAAU,OAAO,QAAQ,CAAC,cAAc;AAC7F,MAAI,MAAM,MAAM;AACd,QAAI,gBAAgB;AAClB,aAAO,sBAAsB,YAAY,WAAW,OAAO;AAAA,IAC7D,OAAO;AACL,YAAM,aAAa;AAAA,IACrB;AAAA,EACF;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,EACF;AACF;AACA,SAAS,QAAQ,OAAO,KAAK,WAAW,SAAS,OAAO,KAAK,UAAU,mBAAmB,QAAQ,aAAa;AAC7G,QAAM,QAAQ;AACd,QAAM,oBAAoB,UAAU,KAAK,kCAAkC,MAAM,kCAAkC;AACnH,QAAM,mBAAmB,UAAU,KAAK,iCAAiC,MAAM,UAAU,KAAK,iCAAiC,MAAM,UAAU,IAAI,iCAAiC,MAAM,iCAAiC;AAC3N,MAAI,UAAU;AACd,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,OAAO,OAAO,WAAW,KAAK,IAAI,GAAG,EAAE,GAAG;AAC5D,UAAMA,QAAO,MAAM,WAAW,GAAG;AACjC,QAAI;AACJ,QAAIA,UAAS,MAAM,sBAAsB,QAAQ;AAC/C,YAAM,OAAO,MAAM,WAAW,MAAM,CAAC;AACrC,YAAM,OAAO,MAAM,WAAW,MAAM,CAAC;AACrC,UAAI,CAAC,mBAAmB;AACtB,YAAI;AAAa,iBAAO;AAAA,YACtB,GAAG;AAAA,YACH;AAAA,UACF;AACA,eAAO,iCAAiC,KAAK,WAAW,OAAO;AAAA,MACjE,WAAW,OAAO,MAAM,IAAI,KAAK,CAAC,iBAAiB,IAAI,KAAK,kBAAkB,IAAI,IAAI,KAAK,kBAAkB,IAAI,IAAI,GAAG;AACtH,YAAI;AAAa,iBAAO;AAAA,YACtB,GAAG;AAAA,YACH;AAAA,UACF;AACA,eAAO,2BAA2B,KAAK,WAAW,OAAO;AAAA,MAC3D;AACA,QAAE;AACF;AAAA,IACF;AACA,QAAIA,SAAQ,IAAI;AACd,YAAMA,QAAO,KAAK;AAAA,IACpB,WAAWA,SAAQ,IAAI;AACrB,YAAMA,QAAO,KAAK;AAAA,IACpB,WAAW,SAASA,KAAI,GAAG;AACzB,YAAMA,QAAO;AAAA,IACf,OAAO;AACL,YAAM;AAAA,IACR;AACA,QAAI,OAAO,OAAO;AAChB,UAAI,OAAO,KAAK,aAAa;AAC3B,eAAO;AAAA,UACL,GAAG;AAAA,UACH;AAAA,QACF;AAAA,MACF,WAAW,OAAO,KAAK,OAAO,aAAa,KAAK,WAAW,SAAS,KAAK,GAAG;AAC1E,cAAM;AAAA,MACR,WAAW,UAAU;AACnB,cAAM;AACN,kBAAU;AAAA,MACZ,OAAO;AACL;AAAA,MACF;AAAA,IACF;AACA,MAAE;AACF,YAAQ,QAAQ,QAAQ;AAAA,EAC1B;AACA,MAAI,QAAQ,SAAS,OAAO,QAAQ,MAAM,UAAU,OAAO,SAAS;AAClE,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,EACF;AACF;AACA,SAAS,cAAc,OAAO,KAAK,WAAW,SAAS,gBAAgB,QAAQ;AAC7E,QAAM,KAAK,MAAM,WAAW,GAAG;AAC/B,MAAIA;AACJ,MAAI,OAAO,KAAK;AACd,MAAE;AACF,KAAC;AAAA,MACC,MAAAA;AAAA,MACA;AAAA,IACF,IAAI,YAAY,OAAO,KAAK,WAAW,SAAS,MAAM,QAAQ,KAAK,GAAG,IAAI,KAAK,MAAM,gBAAgB,MAAM;AAC3G,MAAE;AACF,QAAIA,UAAS,QAAQA,QAAO,SAAU;AACpC,UAAI,gBAAgB;AAClB,eAAO,iBAAiB,KAAK,WAAW,OAAO;AAAA,MACjD,OAAO;AACL,eAAO;AAAA,UACL,MAAM;AAAA,UACN;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AACL,KAAC;AAAA,MACC,MAAAA;AAAA,MACA;AAAA,IACF,IAAI,YAAY,OAAO,KAAK,WAAW,SAAS,GAAG,OAAO,gBAAgB,MAAM;AAAA,EAClF;AACA,SAAO;AAAA,IACL,MAAAA;AAAA,IACA;AAAA,EACF;AACF;AACA,SAAS,cAAc,KAAK,WAAW,SAAS;AAC9C,SAAO,IAAI,SAAS,SAAS,MAAM,WAAW,GAAG;AACnD;AACA,MAAM,oBAAoB,oBAAI,IAAI,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC;AAC1E,MAAM,MAAM;AAAA,EACV,YAAY,OAAO;AACjB,SAAK,OAAO,MAAM;AAClB,SAAK,QAAQ,MAAM;AACnB,SAAK,QAAQ,MAAM;AACnB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,IAAI,eAAe,MAAM,UAAU,MAAM,MAAM;AAAA,EAC5D;AACF;AACA,MAAM,kBAAkB,eAAe;AAAA,EACrC,YAAY,SAAS,OAAO;AAC1B,UAAM;AACN,SAAK,cAAc;AACnB,SAAK,SAAS,CAAC;AACf,SAAK,wBAAwB;AAAA,MAC3B,cAAc,CAAC,KAAK,WAAW,SAAS,UAAU;AAChD,YAAI,CAAC,KAAK,QAAQ;AAAe,iBAAO;AACxC,aAAK,MAAM,OAAO,cAAc,cAAc,KAAK,WAAW,OAAO,GAAG;AAAA,UACtE;AAAA,QACF,CAAC;AACD,eAAO;AAAA,MACT;AAAA,MACA,kCAAkC,KAAK,aAAa,OAAO,gCAAgC;AAAA,MAC3F,4BAA4B,KAAK,aAAa,OAAO,0BAA0B;AAAA,IACjF;AACA,SAAK,8BAA8B,OAAO,OAAO,CAAC,GAAG,KAAK,uBAAuB;AAAA,MAC/E,uBAAuB,KAAK,aAAa,OAAO,qBAAqB;AAAA,MACrE,kBAAkB,KAAK,aAAa,OAAO,gBAAgB;AAAA,IAC7D,CAAC;AACD,SAAK,0CAA0C,OAAO,OAAO,CAAC,GAAG,KAAK,6BAA6B;AAAA,MACjG,qBAAqB,CAAC,KAAK,WAAW,YAAY;AAChD,aAAK,uBAAuB,OAAO,qBAAqB,cAAc,KAAK,WAAW,OAAO,CAAC;AAAA,MAChG;AAAA,MACA,cAAc,CAAC,KAAK,WAAW,YAAY;AACzC,cAAM,KAAK,MAAM,OAAO,oBAAoB,cAAc,MAAM,GAAG,WAAW,OAAO,CAAC;AAAA,MACxF;AAAA,IACF,CAAC;AACD,SAAK,4CAA4C,OAAO,OAAO,CAAC,GAAG,KAAK,6BAA6B;AAAA,MACnG,qBAAqB,KAAK,aAAa,OAAO,mBAAmB;AAAA,MACjE,cAAc,CAAC,KAAK,WAAW,YAAY;AACzC,cAAM,KAAK,MAAM,OAAO,sBAAsB,cAAc,KAAK,WAAW,OAAO,CAAC;AAAA,MACtF;AAAA,IACF,CAAC;AACD,SAAK,QAAQ,IAAI,MAAM;AACvB,SAAK,MAAM,KAAK,OAAO;AACvB,SAAK,QAAQ;AACb,SAAK,SAAS,MAAM;AACpB,SAAK,WAAW,CAAC;AACjB,SAAK,cAAc;AAAA,EACrB;AAAA,EACA,UAAU,OAAO;AACf,SAAK,OAAO,SAAS,KAAK,MAAM;AAChC,SAAK,OAAO,KAAK,KAAK;AACtB,MAAE,KAAK,MAAM;AAAA,EACf;AAAA,EACA,OAAO;AACL,SAAK,oBAAoB;AACzB,QAAI,KAAK,QAAQ,QAAQ;AACvB,WAAK,UAAU,IAAI,MAAM,KAAK,KAAK,CAAC;AAAA,IACtC;AACA,SAAK,MAAM,gBAAgB,KAAK,MAAM;AACtC,SAAK,MAAM,kBAAkB,KAAK,MAAM;AACxC,SAAK,UAAU;AAAA,EACjB;AAAA,EACA,IAAI,MAAM;AACR,QAAI,KAAK,MAAM,IAAI,GAAG;AACpB,WAAK,KAAK;AACV,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,MAAM,MAAM;AACV,WAAO,KAAK,MAAM,SAAS;AAAA,EAC7B;AAAA,EACA,qBAAqB,OAAO;AAC1B,WAAO;AAAA,MACL,KAAK,MAAM;AAAA,MACX,OAAO;AAAA,MACP,MAAM,MAAM;AAAA,MACZ,OAAO,MAAM;AAAA,MACb,KAAK,MAAM;AAAA,MACX,SAAS,CAAC,KAAK,WAAW,CAAC;AAAA,MAC3B,QAAQ,MAAM;AAAA,MACd,UAAU,MAAM;AAAA,MAChB,eAAe,MAAM;AAAA,MACrB,SAAS,MAAM;AAAA,MACf,WAAW,MAAM;AAAA,MACjB,aAAa,MAAM;AAAA,IACrB;AAAA,EACF;AAAA,EACA,YAAY;AACV,UAAM,MAAM,KAAK;AACjB,SAAK,QAAQ,KAAK,qBAAqB,GAAG;AAC1C,SAAK,cAAc;AACnB,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,UAAM,OAAO,KAAK;AAClB,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AACf,WAAO,KAAK,oBAAoB,KAAK,MAAM,GAAG;AAAA,EAChD;AAAA,EACA,oBAAoB,KAAK;AACvB,mBAAe,YAAY;AAC3B,WAAO,eAAe,KAAK,KAAK,KAAK,IAAI,eAAe,YAAY;AAAA,EACtE;AAAA,EACA,oBAAoB;AAClB,WAAO,KAAK,MAAM,WAAW,KAAK,eAAe,CAAC;AAAA,EACpD;AAAA,EACA,uBAAuB;AACrB,WAAO,KAAK,0BAA0B,KAAK,MAAM,GAAG;AAAA,EACtD;AAAA,EACA,0BAA0B,KAAK;AAC7B,yBAAqB,YAAY;AACjC,WAAO,qBAAqB,KAAK,KAAK,KAAK,IAAI,qBAAqB,YAAY;AAAA,EAClF;AAAA,EACA,0BAA0B;AACxB,WAAO,KAAK,MAAM,WAAW,KAAK,qBAAqB,CAAC;AAAA,EAC1D;AAAA,EACA,eAAe,KAAK;AAClB,QAAI,KAAK,KAAK,MAAM,WAAW,GAAG;AAClC,SAAK,KAAK,WAAY,SAAU,EAAE,MAAM,KAAK,MAAM,QAAQ;AACzD,YAAM,QAAQ,KAAK,MAAM,WAAW,GAAG;AACvC,WAAK,QAAQ,WAAY,OAAQ;AAC/B,aAAK,UAAY,KAAK,SAAU,OAAO,QAAQ;AAAA,MACjD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,UAAU,QAAQ;AAChB,SAAK,MAAM,SAAS;AACpB,QAAI,QAAQ;AACV,WAAK,MAAM,aAAa,QAAQ,CAAC,CAAC,cAAc,EAAE,MAAM,KAAK,MAAM,cAAc,EAAE,CAAC;AACpF,WAAK,MAAM,aAAa,MAAM;AAAA,IAChC;AAAA,EACF;AAAA,EACA,aAAa;AACX,WAAO,KAAK,MAAM,QAAQ,KAAK,MAAM,QAAQ,SAAS,CAAC;AAAA,EACzD;AAAA,EACA,YAAY;AACV,SAAK,UAAU;AACf,SAAK,MAAM,QAAQ,KAAK,MAAM;AAC9B,QAAI,CAAC,KAAK;AAAa,WAAK,MAAM,WAAW,KAAK,MAAM,YAAY;AACpE,QAAI,KAAK,MAAM,OAAO,KAAK,QAAQ;AACjC,WAAK,YAAY,GAAG;AACpB;AAAA,IACF;AACA,SAAK,iBAAiB,KAAK,eAAe,KAAK,MAAM,GAAG,CAAC;AAAA,EAC3D;AAAA,EACA,iBAAiB,YAAY;AAC3B,QAAI;AACJ,QAAI,CAAC,KAAK;AAAa,iBAAW,KAAK,MAAM,YAAY;AACzD,UAAM,QAAQ,KAAK,MAAM;AACzB,UAAM,MAAM,KAAK,MAAM,QAAQ,YAAY,QAAQ,CAAC;AACpD,QAAI,QAAQ,IAAI;AACd,YAAM,KAAK,MAAM,OAAO,qBAAqB,KAAK,MAAM,YAAY,CAAC;AAAA,IACvE;AACA,SAAK,MAAM,MAAM,MAAM,WAAW;AAClC,eAAW,YAAY,QAAQ;AAC/B,WAAO,WAAW,KAAK,KAAK,KAAK,KAAK,WAAW,aAAa,KAAK;AACjE,QAAE,KAAK,MAAM;AACb,WAAK,MAAM,YAAY,WAAW;AAAA,IACpC;AACA,QAAI,KAAK;AAAa;AACtB,UAAM,UAAU;AAAA,MACd,MAAM;AAAA,MACN,OAAO,KAAK,MAAM,MAAM,QAAQ,GAAG,GAAG;AAAA,MACtC;AAAA,MACA,KAAK,MAAM,WAAW;AAAA,MACtB,KAAK,IAAI,eAAe,UAAU,KAAK,MAAM,YAAY,CAAC;AAAA,IAC5D;AACA,QAAI,KAAK,QAAQ;AAAQ,WAAK,UAAU,OAAO;AAC/C,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,WAAW;AACzB,UAAM,QAAQ,KAAK,MAAM;AACzB,QAAI;AACJ,QAAI,CAAC,KAAK;AAAa,iBAAW,KAAK,MAAM,YAAY;AACzD,QAAI,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,OAAO,SAAS;AAC1D,QAAI,KAAK,MAAM,MAAM,KAAK,QAAQ;AAChC,aAAO,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,MAAM,MAAM,KAAK,QAAQ;AACvD,aAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAAA,MAC3C;AAAA,IACF;AACA,QAAI,KAAK;AAAa;AACtB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,QAAQ,KAAK,MAAM,MAAM,QAAQ,WAAW,GAAG;AACrD,UAAM,UAAU;AAAA,MACd,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,IAAI,eAAe,UAAU,KAAK,MAAM,YAAY,CAAC;AAAA,IAC5D;AACA,QAAI,KAAK,QAAQ;AAAQ,WAAK,UAAU,OAAO;AAC/C,WAAO;AAAA,EACT;AAAA,EACA,YAAY;AACV,UAAM,aAAa,KAAK,MAAM;AAC9B,UAAM,WAAW,CAAC;AAClB;AAAM,aAAO,KAAK,MAAM,MAAM,KAAK,QAAQ;AACzC,cAAM,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAC/C,gBAAQ,IAAI;AAAA,UACV,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,cAAE,KAAK,MAAM;AACb;AAAA,UACF,KAAK;AACH,gBAAI,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,IAAI;AACpD,gBAAE,KAAK,MAAM;AAAA,YACf;AAAA,UACF,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,cAAE,KAAK,MAAM;AACb,cAAE,KAAK,MAAM;AACb,iBAAK,MAAM,YAAY,KAAK,MAAM;AAClC;AAAA,UACF,KAAK;AACH,oBAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,GAAG;AAAA,cACjD,KAAK,IACH;AACE,sBAAM,UAAU,KAAK,iBAAiB,IAAI;AAC1C,oBAAI,YAAY,QAAW;AACzB,uBAAK,WAAW,OAAO;AACvB,sBAAI,KAAK,QAAQ;AAAe,6BAAS,KAAK,OAAO;AAAA,gBACvD;AACA;AAAA,cACF;AAAA,cACF,KAAK,IACH;AACE,sBAAM,UAAU,KAAK,gBAAgB,CAAC;AACtC,oBAAI,YAAY,QAAW;AACzB,uBAAK,WAAW,OAAO;AACvB,sBAAI,KAAK,QAAQ;AAAe,6BAAS,KAAK,OAAO;AAAA,gBACvD;AACA;AAAA,cACF;AAAA,cACF;AACE,sBAAM;AAAA,YACV;AACA;AAAA,UACF;AACE,gBAAI,aAAa,EAAE,GAAG;AACpB,gBAAE,KAAK,MAAM;AAAA,YACf,WAAW,OAAO,MAAM,CAAC,KAAK,YAAY,KAAK,QAAQ,QAAQ;AAC7D,oBAAM,MAAM,KAAK,MAAM;AACvB,kBAAI,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,MAAM,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,OAAO,eAAe,KAAK,KAAK,MAAM,YAAY,aAAa;AAC7I,sBAAM,UAAU,KAAK,gBAAgB,CAAC;AACtC,oBAAI,YAAY,QAAW;AACzB,uBAAK,WAAW,OAAO;AACvB,sBAAI,KAAK,QAAQ;AAAe,6BAAS,KAAK,OAAO;AAAA,gBACvD;AAAA,cACF,OAAO;AACL,sBAAM;AAAA,cACR;AAAA,YACF,WAAW,OAAO,MAAM,CAAC,KAAK,YAAY,KAAK,QAAQ,QAAQ;AAC7D,oBAAM,MAAM,KAAK,MAAM;AACvB,kBAAI,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,MAAM,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,MAAM,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,IAAI;AAC3H,sBAAM,UAAU,KAAK,gBAAgB,CAAC;AACtC,oBAAI,YAAY,QAAW;AACzB,uBAAK,WAAW,OAAO;AACvB,sBAAI,KAAK,QAAQ;AAAe,6BAAS,KAAK,OAAO;AAAA,gBACvD;AAAA,cACF,OAAO;AACL,sBAAM;AAAA,cACR;AAAA,YACF,OAAO;AACL,oBAAM;AAAA,YACR;AAAA,QACJ;AAAA,MACF;AACA,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,MAAM,KAAK,MAAM;AACvB,YAAM,oBAAoB;AAAA,QACxB,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA,aAAa;AAAA,QACb,cAAc;AAAA,QACd,gBAAgB;AAAA,MAClB;AACA,WAAK,MAAM,aAAa,KAAK,iBAAiB;AAAA,IAChD;AAAA,EACF;AAAA,EACA,YAAY,MAAM,KAAK;AACrB,SAAK,MAAM,MAAM,KAAK,MAAM;AAC5B,SAAK,MAAM,SAAS,KAAK,MAAM,YAAY;AAC3C,UAAM,WAAW,KAAK,MAAM;AAC5B,SAAK,MAAM,OAAO;AAClB,SAAK,MAAM,QAAQ;AACnB,QAAI,CAAC,KAAK,aAAa;AACrB,WAAK,cAAc,QAAQ;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,aAAa,MAAM;AACjB,SAAK,MAAM,OAAO;AAClB,SAAK,cAAc;AAAA,EACrB;AAAA,EACA,uBAAuB;AACrB,QAAI,KAAK,MAAM,QAAQ,KAAK,KAAK,sBAAsB,GAAG;AACxD;AAAA,IACF;AACA,UAAM,UAAU,KAAK,MAAM,MAAM;AACjC,UAAM,OAAO,KAAK,eAAe,OAAO;AACxC,QAAI,QAAQ,MAAM,QAAQ,IAAI;AAC5B,YAAM,KAAK,MAAM,OAAO,0BAA0B,KAAK,MAAM,YAAY,CAAC;AAAA,IAC5E;AACA,QAAI,SAAS,OAAO,SAAS,MAAM,KAAK,UAAU,gBAAgB,GAAG;AACnE,WAAK,aAAa,gBAAgB;AAClC,UAAI,KAAK,gBAAgB,kBAAkB,YAAY,MAAM,OAAO;AAClE,cAAM,KAAK,MAAM,SAAS,MAAM,OAAO,+CAA+C,OAAO,6CAA6C,KAAK,MAAM,YAAY,CAAC;AAAA,MACpK;AACA,WAAK,MAAM,OAAO;AAClB,UAAI,SAAS,KAAK;AAChB,aAAK,YAAY,CAAC;AAAA,MACpB,OAAO;AACL,aAAK,YAAY,CAAC;AAAA,MACpB;AAAA,IACF,WAAW,kBAAkB,IAAI,GAAG;AAClC,QAAE,KAAK,MAAM;AACb,WAAK,YAAY,KAAK,KAAK,UAAU,IAAI,CAAC;AAAA,IAC5C,WAAW,SAAS,IAAI;AACtB,QAAE,KAAK,MAAM;AACb,WAAK,YAAY,KAAK,KAAK,UAAU,CAAC;AAAA,IACxC,OAAO;AACL,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EACA,gBAAgB;AACd,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,QAAQ,MAAM,QAAQ,IAAI;AAC5B,WAAK,WAAW,IAAI;AACpB;AAAA,IACF;AACA,QAAI,SAAS,MAAM,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,IAAI;AACnE,WAAK,MAAM,OAAO;AAClB,WAAK,YAAY,EAAE;AAAA,IACrB,OAAO;AACL,QAAE,KAAK,MAAM;AACb,WAAK,YAAY,EAAE;AAAA,IACrB;AAAA,EACF;AAAA,EACA,kBAAkB;AAChB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,SAAS,IAAI;AACf,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB,OAAO;AACL,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EACA,wBAAwB;AACtB,QAAI,KAAK,MAAM,QAAQ,KAAK,KAAK,SAAS;AAAG,aAAO;AACpD,QAAI,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACjD,QAAI,OAAO;AAAI,aAAO;AACtB,UAAM,QAAQ,KAAK,MAAM;AACzB,SAAK,MAAM,OAAO;AAClB,WAAO,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,MAAM,MAAM,KAAK,QAAQ;AACvD,WAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAAA,IAC3C;AACA,UAAM,QAAQ,KAAK,MAAM,MAAM,QAAQ,GAAG,KAAK,MAAM,GAAG;AACxD,SAAK,YAAY,IAAI,KAAK;AAC1B,WAAO;AAAA,EACT;AAAA,EACA,sBAAsBA,OAAM;AAC1B,QAAI,OAAOA,UAAS,KAAK,KAAK;AAC9B,QAAI,QAAQ;AACZ,QAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACnD,QAAIA,UAAS,MAAM,SAAS,IAAI;AAC9B;AACA,aAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AAC/C,aAAO;AAAA,IACT;AACA,QAAI,SAAS,MAAM,CAAC,KAAK,MAAM,QAAQ;AACrC;AACA,aAAOA,UAAS,KAAK,KAAK;AAAA,IAC5B;AACA,SAAK,SAAS,MAAM,KAAK;AAAA,EAC3B;AAAA,EACA,mBAAmBA,OAAM;AACvB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,SAASA,OAAM;AACjB,UAAI,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,IAAI;AACpD,aAAK,SAAS,IAAI,CAAC;AAAA,MACrB,OAAO;AACL,aAAK,SAASA,UAAS,MAAM,KAAK,IAAI,CAAC;AAAA,MACzC;AACA;AAAA,IACF;AACA,QAAIA,UAAS,KAAK;AAChB,UAAI,SAAS,IAAI;AACf,aAAK,SAAS,IAAI,CAAC;AACnB;AAAA,MACF;AACA,UAAI,KAAK,UAAU,gBAAgB,KAAK,SAAS,KAAK;AACpD,YAAI,KAAK,gBAAgB,kBAAkB,YAAY,MAAM,OAAO;AAClE,gBAAM,KAAK,MAAM,OAAO,2CAA2C,KAAK,MAAM,YAAY,CAAC;AAAA,QAC7F;AACA,aAAK,MAAM,OAAO;AAClB,aAAK,YAAY,CAAC;AAClB;AAAA,MACF;AACA,UAAI,KAAK,UAAU,gBAAgB,KAAK,SAAS,IAAI;AACnD,YAAI,KAAK,gBAAgB,kBAAkB,YAAY,MAAM,OAAO;AAClE,gBAAM,KAAK,MAAM,OAAO,0CAA0C,KAAK,MAAM,YAAY,CAAC;AAAA,QAC5F;AACA,aAAK,MAAM,OAAO;AAClB,aAAK,YAAY,CAAC;AAClB;AAAA,MACF;AAAA,IACF;AACA,QAAI,SAAS,IAAI;AACf,WAAK,SAAS,IAAI,CAAC;AACnB;AAAA,IACF;AACA,SAAK,SAASA,UAAS,MAAM,KAAK,IAAI,CAAC;AAAA,EACzC;AAAA,EACA,kBAAkB;AAChB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,SAAS,MAAM,CAAC,KAAK,MAAM,QAAQ;AACrC,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB,WAAW,SAAS,MAAM,KAAK,UAAU,CAAC,oBAAoB;AAAA,MAC5D,UAAU;AAAA,MACV,YAAY;AAAA,IACd,CAAC,CAAC,GAAG;AACH,WAAK,SAAS,IAAI,CAAC;AACnB,YAAM,cAAc,KAAK,MAAM,YAAY,KAAK,MAAM,GAAG;AACzD,UAAI,gBAAgB,IAAI;AACtB,aAAK,WAAW;AAAA,MAClB;AAAA,IACF,OAAO;AACL,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,SAAS,MAAM,KAAK,UAAU,CAAC,oBAAoB;AAAA,MACrD,UAAU;AAAA,MACV,YAAY;AAAA,IACd,CAAC,CAAC,GAAG;AACH,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB,OAAO;AACL,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EACA,mBAAmBA,OAAM;AACvB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,SAASA,OAAM;AACjB,WAAK,SAAS,IAAI,CAAC;AACnB;AAAA,IACF;AACA,QAAI,SAAS,IAAI;AACf,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB,OAAO;AACL,WAAK,SAAS,IAAI,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EACA,eAAe;AACb,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,OAAO,KAAK,MAAM,WAAW,MAAM,CAAC;AAC1C,QAAI,SAAS,IAAI;AACf,UAAI,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,IAAI;AACzC,aAAK,SAAS,IAAI,CAAC;AACnB;AAAA,MACF;AACA,WAAK,SAAS,IAAI,CAAC;AACnB;AAAA,IACF;AACA,QAAI,SAAS,IAAI;AACf,WAAK,SAAS,IAAI,CAAC;AACnB;AAAA,IACF;AACA,SAAK,SAAS,IAAI,CAAC;AAAA,EACrB;AAAA,EACA,eAAe;AACb,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,OAAO,KAAK,MAAM,WAAW,MAAM,CAAC;AAC1C,QAAI,SAAS,IAAI;AACf,YAAM,OAAO,KAAK,MAAM,WAAW,MAAM,CAAC,MAAM,KAAK,IAAI;AACzD,UAAI,KAAK,MAAM,WAAW,MAAM,IAAI,MAAM,IAAI;AAC5C,aAAK,SAAS,IAAI,OAAO,CAAC;AAC1B;AAAA,MACF;AACA,WAAK,SAAS,IAAI,IAAI;AACtB;AAAA,IACF;AACA,QAAI,SAAS,IAAI;AACf,WAAK,SAAS,IAAI,CAAC;AACnB;AAAA,IACF;AACA,SAAK,SAAS,IAAI,CAAC;AAAA,EACrB;AAAA,EACA,kBAAkBA,OAAM;AACtB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAI,SAAS,IAAI;AACf,WAAK,SAAS,IAAI,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,KAAK,IAAI,CAAC;AAC1E;AAAA,IACF;AACA,QAAIA,UAAS,MAAM,SAAS,IAAI;AAC9B,WAAK,MAAM,OAAO;AAClB,WAAK,YAAY,EAAE;AACnB;AAAA,IACF;AACA,SAAK,SAASA,UAAS,KAAK,KAAK,IAAI,CAAC;AAAA,EACxC;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,UAAM,QAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACtD,QAAI,SAAS,IAAI;AACf,UAAI,UAAU,IAAI;AAChB,aAAK,SAAS,IAAI,CAAC;AAAA,MACrB,OAAO;AACL,aAAK,SAAS,IAAI,CAAC;AAAA,MACrB;AAAA,IACF,WAAW,SAAS,MAAM,EAAE,SAAS,MAAM,SAAS,KAAK;AACvD,WAAK,MAAM,OAAO;AAClB,WAAK,YAAY,EAAE;AAAA,IACrB,OAAO;AACL,QAAE,KAAK,MAAM;AACb,WAAK,YAAY,EAAE;AAAA,IACrB;AAAA,EACF;AAAA,EACA,iBAAiBA,OAAM;AACrB,YAAQA,OAAM;AAAA,MACZ,KAAK;AACH,aAAK,cAAc;AACnB;AAAA,MACF,KAAK;AACH,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,EAAE;AACnB;AAAA,MACF,KAAK;AACH,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,EAAE;AACnB;AAAA,MACF,KAAK;AACH,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,EAAE;AACnB;AAAA,MACF,KAAK;AACH,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,EAAE;AACnB;AAAA,MACF,KAAK;AACH,YAAI,KAAK,UAAU,gBAAgB,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,KAAK;AACzF,cAAI,KAAK,gBAAgB,kBAAkB,YAAY,MAAM,OAAO;AAClE,kBAAM,KAAK,MAAM,OAAO,4CAA4C,KAAK,MAAM,YAAY,CAAC;AAAA,UAC9F;AACA,eAAK,MAAM,OAAO;AAClB,eAAK,YAAY,CAAC;AAAA,QACpB,OAAO;AACL,YAAE,KAAK,MAAM;AACb,eAAK,YAAY,CAAC;AAAA,QACpB;AACA;AAAA,MACF,KAAK;AACH,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,CAAC;AAClB;AAAA,MACF,KAAK;AACH,YAAI,KAAK,UAAU,gBAAgB,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,KAAK;AACzF,cAAI,KAAK,gBAAgB,kBAAkB,YAAY,MAAM,OAAO;AAClE,kBAAM,KAAK,MAAM,OAAO,6CAA6C,KAAK,MAAM,YAAY,CAAC;AAAA,UAC/F;AACA,eAAK,MAAM,OAAO;AAClB,eAAK,YAAY,CAAC;AAAA,QACpB,OAAO;AACL,YAAE,KAAK,MAAM;AACb,eAAK,YAAY,CAAC;AAAA,QACpB;AACA;AAAA,MACF,KAAK;AACH,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,CAAC;AAClB;AAAA,MACF,KAAK;AACH,YAAI,KAAK,UAAU,cAAc,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,IAAI;AACtF,eAAK,SAAS,IAAI,CAAC;AAAA,QACrB,OAAO;AACL,YAAE,KAAK,MAAM;AACb,eAAK,YAAY,EAAE;AAAA,QACrB;AACA;AAAA,MACF,KAAK;AACH,aAAK,mBAAmB;AACxB;AAAA,MACF,KAAK;AACH,aAAK,kBAAkB;AACvB;AAAA,MACF,KAAK,IACH;AACE,cAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,YAAI,SAAS,OAAO,SAAS,IAAI;AAC/B,eAAK,gBAAgB,EAAE;AACvB;AAAA,QACF;AACA,YAAI,SAAS,OAAO,SAAS,IAAI;AAC/B,eAAK,gBAAgB,CAAC;AACtB;AAAA,QACF;AACA,YAAI,SAAS,MAAM,SAAS,IAAI;AAC9B,eAAK,gBAAgB,CAAC;AACtB;AAAA,QACF;AAAA,MACF;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,aAAK,WAAW,KAAK;AACrB;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,WAAWA,KAAI;AACpB;AAAA,MACF,KAAK;AACH,aAAK,gBAAgB;AACrB;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,sBAAsBA,KAAI;AAC/B;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,mBAAmBA,KAAI;AAC5B;AAAA,MACF,KAAK;AACH,aAAK,gBAAgB;AACrB;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,mBAAmBA,KAAI;AAC5B;AAAA,MACF,KAAK;AACH,aAAK,aAAa;AAClB;AAAA,MACF,KAAK;AACH,aAAK,aAAa;AAClB;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,kBAAkBA,KAAI;AAC3B;AAAA,MACF,KAAK;AACH,aAAK,SAAS,IAAI,CAAC;AACnB;AAAA,MACF,KAAK;AACH,aAAK,iBAAiB;AACtB;AAAA,MACF,KAAK;AACH,aAAK,qBAAqB;AAC1B;AAAA,MACF,KAAK;AACH,aAAK,SAAS;AACd;AAAA,MACF;AACE,YAAI,kBAAkBA,KAAI,GAAG;AAC3B,eAAK,SAASA,KAAI;AAClB;AAAA,QACF;AAAA,IACJ;AACA,UAAM,KAAK,MAAM,OAAO,0BAA0B,KAAK,MAAM,YAAY,GAAG;AAAA,MAC1E,YAAY,OAAO,cAAcA,KAAI;AAAA,IACvC,CAAC;AAAA,EACH;AAAA,EACA,SAAS,MAAM,MAAM;AACnB,UAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,KAAK,KAAK,MAAM,MAAM,IAAI;AAClE,SAAK,MAAM,OAAO;AAClB,SAAK,YAAY,MAAM,GAAG;AAAA,EAC5B;AAAA,EACA,aAAa;AACX,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,QAAQ,KAAK,MAAM,QAAQ;AACjC,QAAI,SAAS;AACb,QAAI;AAAA,MACF;AAAA,IACF,IAAI,KAAK;AACT,aAAQ,EAAE,KAAK;AACb,UAAI,OAAO,KAAK,QAAQ;AACtB,cAAM,KAAK,MAAM,OAAO,oBAAoB,+BAA+B,UAAU,CAAC,CAAC;AAAA,MACzF;AACA,YAAM,KAAK,KAAK,MAAM,WAAW,GAAG;AACpC,UAAI,UAAU,EAAE,GAAG;AACjB,cAAM,KAAK,MAAM,OAAO,oBAAoB,+BAA+B,UAAU,CAAC,CAAC;AAAA,MACzF;AACA,UAAI,SAAS;AACX,kBAAU;AAAA,MACZ,OAAO;AACL,YAAI,OAAO,IAAI;AACb,oBAAU;AAAA,QACZ,WAAW,OAAO,MAAM,SAAS;AAC/B,oBAAU;AAAA,QACZ,WAAW,OAAO,MAAM,CAAC,SAAS;AAChC;AAAA,QACF;AACA,kBAAU,OAAO;AAAA,MACnB;AAAA,IACF;AACA,UAAM,UAAU,KAAK,MAAM,MAAM,OAAO,GAAG;AAC3C,MAAE;AACF,QAAI,OAAO;AACX,UAAM,UAAU,MAAM,+BAA+B,UAAU,MAAM,IAAI,KAAK;AAC9E,WAAO,MAAM,KAAK,QAAQ;AACxB,YAAM,KAAK,KAAK,eAAe,GAAG;AAClC,YAAM,OAAO,OAAO,aAAa,EAAE;AACnC,UAAI,kBAAkB,IAAI,EAAE,GAAG;AAC7B,YAAI,OAAO,KAAK;AACd,cAAI,KAAK,SAAS,GAAG,GAAG;AACtB,iBAAK,MAAM,OAAO,2BAA2B,QAAQ,CAAC;AAAA,UACxD;AAAA,QACF,WAAW,OAAO,KAAK;AACrB,cAAI,KAAK,SAAS,GAAG,GAAG;AACtB,iBAAK,MAAM,OAAO,2BAA2B,QAAQ,CAAC;AAAA,UACxD;AAAA,QACF;AACA,YAAI,KAAK,SAAS,IAAI,GAAG;AACvB,eAAK,MAAM,OAAO,sBAAsB,QAAQ,CAAC;AAAA,QACnD;AAAA,MACF,WAAW,iBAAiB,EAAE,KAAK,OAAO,IAAI;AAC5C,aAAK,MAAM,OAAO,sBAAsB,QAAQ,CAAC;AAAA,MACnD,OAAO;AACL;AAAA,MACF;AACA,QAAE;AACF,cAAQ;AAAA,IACV;AACA,SAAK,MAAM,MAAM;AACjB,SAAK,YAAY,KAAK;AAAA,MACpB,SAAS;AAAA,MACT,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EACA,QAAQ,OAAO,KAAK,WAAW,OAAO,oBAAoB,MAAM;AAC9D,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,QAAQ,KAAK,OAAO,KAAK,MAAM,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,SAAS,OAAO,KAAK,UAAU,mBAAmB,KAAK,uBAAuB,KAAK;AAC5J,SAAK,MAAM,MAAM;AACjB,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,OAAO;AACrB,UAAM,WAAW,KAAK,MAAM,YAAY;AACxC,QAAI,WAAW;AACf,SAAK,MAAM,OAAO;AAClB,UAAM,MAAM,KAAK,QAAQ,KAAK;AAC9B,QAAI,OAAO,MAAM;AACf,WAAK,MAAM,OAAO,cAAc,+BAA+B,UAAU,CAAC,GAAG;AAAA,QAC3E;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AACjD,QAAI,SAAS,KAAK;AAChB,QAAE,KAAK,MAAM;AACb,iBAAW;AAAA,IACb,WAAW,SAAS,KAAK;AACvB,YAAM,KAAK,MAAM,OAAO,gBAAgB,QAAQ;AAAA,IAClD;AACA,QAAI,kBAAkB,KAAK,eAAe,KAAK,MAAM,GAAG,CAAC,GAAG;AAC1D,YAAM,KAAK,MAAM,OAAO,kBAAkB,KAAK,MAAM,YAAY,CAAC;AAAA,IACpE;AACA,QAAI,UAAU;AACZ,YAAM,MAAM,KAAK,MAAM,MAAM,SAAS,OAAO,KAAK,MAAM,GAAG,EAAE,QAAQ,SAAS,EAAE;AAChF,WAAK,YAAY,KAAK,GAAG;AACzB;AAAA,IACF;AACA,SAAK,YAAY,KAAK,GAAG;AAAA,EAC3B;AAAA,EACA,WAAW,eAAe;AACxB,UAAM,QAAQ,KAAK,MAAM;AACzB,UAAM,WAAW,KAAK,MAAM,YAAY;AACxC,QAAI,UAAU;AACd,QAAI,WAAW;AACf,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,UAAU;AACd,QAAI,CAAC,iBAAiB,KAAK,QAAQ,EAAE,MAAM,MAAM;AAC/C,WAAK,MAAM,OAAO,eAAe,KAAK,MAAM,YAAY,CAAC;AAAA,IAC3D;AACA,UAAM,iBAAiB,KAAK,MAAM,MAAM,SAAS,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM;AACvF,QAAI,gBAAgB;AAClB,YAAM,UAAU,KAAK,MAAM,MAAM,OAAO,KAAK,MAAM,GAAG;AACtD,WAAK,uBAAuB,OAAO,oBAAoB,QAAQ;AAC/D,UAAI,CAAC,KAAK,MAAM,QAAQ;AACtB,cAAM,gBAAgB,QAAQ,QAAQ,GAAG;AACzC,YAAI,gBAAgB,GAAG;AACrB,eAAK,MAAM,OAAO,2BAA2B,+BAA+B,UAAU,aAAa,CAAC;AAAA,QACtG;AAAA,MACF;AACA,gBAAU,kBAAkB,CAAC,OAAO,KAAK,OAAO;AAAA,IAClD;AACA,QAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAC/C,QAAI,SAAS,MAAM,CAAC,SAAS;AAC3B,QAAE,KAAK,MAAM;AACb,WAAK,QAAQ,EAAE;AACf,gBAAU;AACV,aAAO,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAAA,IAC7C;AACA,SAAK,SAAS,MAAM,SAAS,QAAQ,CAAC,SAAS;AAC7C,aAAO,KAAK,MAAM,WAAW,EAAE,KAAK,MAAM,GAAG;AAC7C,UAAI,SAAS,MAAM,SAAS,IAAI;AAC9B,UAAE,KAAK,MAAM;AAAA,MACf;AACA,UAAI,KAAK,QAAQ,EAAE,MAAM,MAAM;AAC7B,aAAK,MAAM,OAAO,0BAA0B,QAAQ;AAAA,MACtD;AACA,gBAAU;AACV,oBAAc;AACd,aAAO,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAAA,IAC7C;AACA,QAAI,SAAS,KAAK;AAChB,UAAI,WAAW,gBAAgB;AAC7B,aAAK,MAAM,OAAO,sBAAsB,QAAQ;AAAA,MAClD;AACA,QAAE,KAAK,MAAM;AACb,iBAAW;AAAA,IACb;AACA,QAAI,SAAS,KAAK;AAChB,WAAK,aAAa,WAAW,KAAK,MAAM,YAAY,CAAC;AACrD,UAAI,eAAe,gBAAgB;AACjC,aAAK,MAAM,OAAO,gBAAgB,QAAQ;AAAA,MAC5C;AACA,QAAE,KAAK,MAAM;AACb,kBAAY;AAAA,IACd;AACA,QAAI,kBAAkB,KAAK,eAAe,KAAK,MAAM,GAAG,CAAC,GAAG;AAC1D,YAAM,KAAK,MAAM,OAAO,kBAAkB,KAAK,MAAM,YAAY,CAAC;AAAA,IACpE;AACA,UAAM,MAAM,KAAK,MAAM,MAAM,OAAO,KAAK,MAAM,GAAG,EAAE,QAAQ,UAAU,EAAE;AACxE,QAAI,UAAU;AACZ,WAAK,YAAY,KAAK,GAAG;AACzB;AAAA,IACF;AACA,QAAI,WAAW;AACb,WAAK,YAAY,KAAK,GAAG;AACzB;AAAA,IACF;AACA,UAAM,MAAM,UAAU,SAAS,KAAK,CAAC,IAAI,WAAW,GAAG;AACvD,SAAK,YAAY,KAAK,GAAG;AAAA,EAC3B;AAAA,EACA,cAAc,gBAAgB;AAC5B,UAAM;AAAA,MACJ,MAAAA;AAAA,MACA;AAAA,IACF,IAAI,cAAc,KAAK,OAAO,KAAK,MAAM,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,SAAS,gBAAgB,KAAK,2BAA2B;AACxI,SAAK,MAAM,MAAM;AACjB,WAAOA;AAAA,EACT;AAAA,EACA,WAAW,OAAO;AAChB,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,mBAAmB,UAAU,KAAK,WAAW,UAAU,KAAK,OAAO,KAAK,MAAM,MAAM,GAAG,KAAK,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK,uCAAuC;AACjL,SAAK,MAAM,MAAM,MAAM;AACvB,SAAK,MAAM,YAAY;AACvB,SAAK,MAAM,UAAU;AACrB,SAAK,YAAY,KAAK,GAAG;AAAA,EAC3B;AAAA,EACA,2BAA2B;AACzB,QAAI,CAAC,KAAK,MAAM,CAAC,GAAG;AAClB,WAAK,WAAW,MAAM,CAAC;AAAA,IACzB;AACA,SAAK,MAAM;AACX,SAAK,kBAAkB;AAAA,EACzB;AAAA,EACA,oBAAoB;AAClB,UAAM,UAAU,KAAK,MAAM,KAAK,MAAM,GAAG;AACzC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,mBAAmB,YAAY,KAAK,OAAO,KAAK,MAAM,MAAM,GAAG,KAAK,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK,yCAAyC;AAC3J,SAAK,MAAM,MAAM,MAAM;AACvB,SAAK,MAAM,YAAY;AACvB,SAAK,MAAM,UAAU;AACrB,QAAI,iBAAiB;AACnB,WAAK,MAAM,gCAAgC,IAAI,SAAS,gBAAgB,SAAS,gBAAgB,MAAM,gBAAgB,WAAW,gBAAgB,GAAG;AAAA,IACvJ;AACA,QAAI,KAAK,MAAM,YAAY,GAAG,MAAM,IAAI;AACtC,WAAK,YAAY,IAAI,kBAAkB,OAAO,UAAU,MAAM,GAAG;AAAA,IACnE,OAAO;AACL,WAAK,MAAM;AACX,WAAK,YAAY,IAAI,kBAAkB,OAAO,UAAU,MAAM,IAAI;AAAA,IACpE;AAAA,EACF;AAAA,EACA,uBAAuB,cAAc,IAAI;AACvC,UAAM,QAAQ,GAAG;AACjB,QAAI,KAAK,MAAM,UAAU,CAAC,KAAK,MAAM,aAAa,IAAI,KAAK,GAAG;AAC5D,WAAK,MAAM,cAAc,EAAE;AAAA,IAC7B,OAAO;AACL,WAAK,MAAM,aAAa,IAAI,OAAO,CAAC,cAAc,EAAE,CAAC;AAAA,IACvD;AAAA,EACF;AAAA,EACA,UAAU,WAAW;AACnB,SAAK,MAAM,cAAc;AACzB,QAAI,OAAO;AACX,UAAM,QAAQ,KAAK,MAAM;AACzB,QAAI,aAAa,KAAK,MAAM;AAC5B,QAAI,cAAc,QAAW;AAC3B,WAAK,MAAM,OAAO,aAAa,QAAS,IAAI;AAAA,IAC9C;AACA,WAAO,KAAK,MAAM,MAAM,KAAK,QAAQ;AACnC,YAAM,KAAK,KAAK,eAAe,KAAK,MAAM,GAAG;AAC7C,UAAI,iBAAiB,EAAE,GAAG;AACxB,aAAK,MAAM,OAAO,MAAM,QAAS,IAAI;AAAA,MACvC,WAAW,OAAO,IAAI;AACpB,aAAK,MAAM,cAAc;AACzB,gBAAQ,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AACnD,cAAM,WAAW,KAAK,MAAM,YAAY;AACxC,cAAM,kBAAkB,KAAK,MAAM,QAAQ,QAAQ,oBAAoB;AACvE,YAAI,KAAK,MAAM,WAAW,EAAE,KAAK,MAAM,GAAG,MAAM,KAAK;AACnD,eAAK,MAAM,OAAO,sBAAsB,KAAK,MAAM,YAAY,CAAC;AAChE,uBAAa,KAAK,MAAM,MAAM;AAC9B;AAAA,QACF;AACA,UAAE,KAAK,MAAM;AACb,cAAM,MAAM,KAAK,cAAc,IAAI;AACnC,YAAI,QAAQ,MAAM;AAChB,cAAI,CAAC,gBAAgB,GAAG,GAAG;AACzB,iBAAK,MAAM,OAAO,4BAA4B,QAAQ;AAAA,UACxD;AACA,kBAAQ,OAAO,cAAc,GAAG;AAAA,QAClC;AACA,qBAAa,KAAK,MAAM;AAAA,MAC1B,OAAO;AACL;AAAA,MACF;AAAA,IACF;AACA,WAAO,OAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AAAA,EAC3D;AAAA,EACA,SAAS,WAAW;AAClB,UAAM,OAAO,KAAK,UAAU,SAAS;AACrC,UAAM,OAAO,WAAW,IAAI,IAAI;AAChC,QAAI,SAAS,QAAW;AACtB,WAAK,YAAY,MAAM,eAAe,IAAI,CAAC;AAAA,IAC7C,OAAO;AACL,WAAK,YAAY,KAAK,IAAI;AAAA,IAC5B;AAAA,EACF;AAAA,EACA,sBAAsB;AACpB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,eAAe,IAAI,KAAK,KAAK,MAAM,aAAa;AAClD,WAAK,MAAM,OAAO,4BAA4B,KAAK,MAAM,UAAU;AAAA,QACjE,cAAc,eAAe,IAAI;AAAA,MACnC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,MAAM,cAAc,IAAI,UAAU,CAAC,GAAG;AACpC,UAAM,MAAM,cAAc,WAAW,KAAK,GAAG,IAAI;AACjD,UAAM,QAAQ,aAAa,KAAK,OAAO;AACvC,QAAI,CAAC,KAAK,QAAQ;AAAe,YAAM;AACvC,QAAI,CAAC,KAAK;AAAa,WAAK,MAAM,OAAO,KAAK,KAAK;AACnD,WAAO;AAAA,EACT;AAAA,EACA,eAAe,cAAc,IAAI,UAAU,CAAC,GAAG;AAC7C,UAAM,MAAM,cAAc,WAAW,KAAK,GAAG,IAAI;AACjD,UAAM,MAAM,IAAI;AAChB,UAAM,SAAS,KAAK,MAAM;AAC1B,aAAS,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AAC3C,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,MAAM,IAAI,UAAU,KAAK;AAC3B,eAAO,OAAO,CAAC,IAAI,aAAa,KAAK,OAAO;AAAA,MAC9C;AACA,UAAI,MAAM,IAAI,QAAQ;AAAK;AAAA,IAC7B;AACA,WAAO,KAAK,MAAM,cAAc,IAAI,OAAO;AAAA,EAC7C;AAAA,EACA,cAAc,UAAU;AAAA,EAAC;AAAA,EACzB,WAAW,KAAK,MAAM;AACpB,UAAM,KAAK,MAAM,OAAO,iBAAiB,OAAO,OAAO,MAAM,KAAK,MAAM,UAAU;AAAA,MAChF,UAAU,OAAO,eAAe,IAAI,IAAI;AAAA,IAC1C,CAAC;AAAA,EACH;AAAA,EACA,aAAa,YAAY,KAAK;AAC5B,QAAI,KAAK,UAAU,UAAU,GAAG;AAC9B,aAAO;AAAA,IACT;AACA,UAAM,KAAK,MAAM,OAAO,eAAe,OAAO,OAAO,MAAM,KAAK,MAAM,UAAU;AAAA,MAC9E,eAAe,CAAC,UAAU;AAAA,IAC5B,CAAC;AAAA,EACH;AAAA,EACA,gBAAgB,aAAa;AAC3B,QAAI,CAAC,YAAY,KAAK,UAAQ,KAAK,UAAU,IAAI,CAAC,GAAG;AACnD,YAAM,KAAK,MAAM,OAAO,qBAAqB,KAAK,MAAM,UAAU;AAAA,QAChE,eAAe;AAAA,MACjB,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,aAAa,OAAO;AAClB,WAAO,CAAC,KAAK,WAAW,YAAY;AAClC,WAAK,MAAM,OAAO,cAAc,KAAK,WAAW,OAAO,CAAC;AAAA,IAC1D;AAAA,EACF;AACF;AACA,MAAM,WAAW;AAAA,EACf,cAAc;AACZ,SAAK,eAAe,oBAAI,IAAI;AAC5B,SAAK,gBAAgB,oBAAI,IAAI;AAC7B,SAAK,wBAAwB,oBAAI,IAAI;AAAA,EACvC;AACF;AACA,MAAM,kBAAkB;AAAA,EACtB,YAAY,QAAQ;AAClB,SAAK,SAAS;AACd,SAAK,QAAQ,CAAC;AACd,SAAK,wBAAwB,oBAAI,IAAI;AACrC,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,UAAU;AACR,WAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA,EACzC;AAAA,EACA,QAAQ;AACN,SAAK,MAAM,KAAK,IAAI,WAAW,CAAC;AAAA,EAClC;AAAA,EACA,OAAO;AACL,UAAM,gBAAgB,KAAK,MAAM,IAAI;AACrC,UAAM,UAAU,KAAK,QAAQ;AAC7B,eAAW,CAAC,MAAM,GAAG,KAAK,MAAM,KAAK,cAAc,qBAAqB,GAAG;AACzE,UAAI,SAAS;AACX,YAAI,CAAC,QAAQ,sBAAsB,IAAI,IAAI,GAAG;AAC5C,kBAAQ,sBAAsB,IAAI,MAAM,GAAG;AAAA,QAC7C;AAAA,MACF,OAAO;AACL,aAAK,OAAO,MAAM,OAAO,+BAA+B,KAAK;AAAA,UAC3D,gBAAgB;AAAA,QAClB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EACA,mBAAmB,MAAM,aAAa,KAAK;AACzC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,KAAK,QAAQ;AACjB,QAAI,YAAY,aAAa,IAAI,IAAI;AACrC,QAAI,cAAc,GAAG;AACnB,YAAM,WAAW,aAAa,cAAc,IAAI,IAAI;AACpD,UAAI,UAAU;AACZ,cAAM,YAAY,WAAW;AAC7B,cAAM,YAAY,cAAc;AAChC,cAAM,UAAU,WAAW;AAC3B,cAAM,UAAU,cAAc;AAC9B,oBAAY,YAAY,WAAW,cAAc;AACjD,YAAI,CAAC;AAAW,wBAAc,OAAO,IAAI;AAAA,MAC3C,WAAW,CAAC,WAAW;AACrB,sBAAc,IAAI,MAAM,WAAW;AAAA,MACrC;AAAA,IACF;AACA,QAAI,WAAW;AACb,WAAK,OAAO,MAAM,OAAO,0BAA0B,KAAK;AAAA,QACtD,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AACA,iBAAa,IAAI,IAAI;AACrB,0BAAsB,OAAO,IAAI;AAAA,EACnC;AAAA,EACA,eAAe,MAAM,KAAK;AACxB,QAAI;AACJ,SAAK,cAAc,KAAK,OAAO;AAC7B,UAAI,WAAW,aAAa,IAAI,IAAI;AAAG;AAAA,IACzC;AACA,QAAI,YAAY;AACd,iBAAW,sBAAsB,IAAI,MAAM,GAAG;AAAA,IAChD,OAAO;AACL,WAAK,OAAO,MAAM,OAAO,+BAA+B,KAAK;AAAA,QAC3D,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AAAA,EACF;AACF;AACA,MAAM,gBAAgB;AAAA,EACpB,YAAY,OAAO,GAAG;AACpB,SAAK,OAAO;AAAA,EACd;AAAA,EACA,iCAAiC;AAC/B,WAAO,KAAK,SAAS,KAAK,KAAK,SAAS;AAAA,EAC1C;AAAA,EACA,kCAAkC;AAChC,WAAO,KAAK,SAAS;AAAA,EACvB;AACF;AACA,MAAM,8BAA8B,gBAAgB;AAAA,EAClD,YAAY,MAAM;AAChB,UAAM,IAAI;AACV,SAAK,oBAAoB,oBAAI,IAAI;AAAA,EACnC;AAAA,EACA,uBAAuB,mBAAmB,IAAI;AAC5C,UAAM,QAAQ,GAAG;AACjB,SAAK,kBAAkB,IAAI,OAAO,CAAC,mBAAmB,EAAE,CAAC;AAAA,EAC3D;AAAA,EACA,sBAAsB,OAAO;AAC3B,SAAK,kBAAkB,OAAO,KAAK;AAAA,EACrC;AAAA,EACA,cAAc,UAAU;AACtB,SAAK,kBAAkB,QAAQ,QAAQ;AAAA,EACzC;AACF;AACA,MAAM,uBAAuB;AAAA,EAC3B,YAAY,QAAQ;AAClB,SAAK,SAAS;AACd,SAAK,QAAQ,CAAC,IAAI,gBAAgB,CAAC;AACnC,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,MAAM,OAAO;AACX,SAAK,MAAM,KAAK,KAAK;AAAA,EACvB;AAAA,EACA,OAAO;AACL,SAAK,MAAM,IAAI;AAAA,EACjB;AAAA,EACA,gCAAgC,cAAc,MAAM;AAClD,UAAM,SAAS,KAAK,IAAI;AACxB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,IAAI,MAAM,SAAS;AACvB,QAAI,QAAQ,MAAM,CAAC;AACnB,WAAO,CAAC,MAAM,gCAAgC,GAAG;AAC/C,UAAI,MAAM,+BAA+B,GAAG;AAC1C,cAAM,uBAAuB,cAAc,MAAM;AAAA,MACnD,OAAO;AACL;AAAA,MACF;AACA,cAAQ,MAAM,EAAE,CAAC;AAAA,IACnB;AACA,SAAK,OAAO,MAAM,cAAc,MAAM;AAAA,EACxC;AAAA,EACA,iCAAiC,OAAO,MAAM;AAC5C,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,UAAM,QAAQ,MAAM,MAAM,SAAS,CAAC;AACpC,UAAM,SAAS,KAAK,IAAI;AACxB,QAAI,MAAM,gCAAgC,GAAG;AAC3C,WAAK,OAAO,MAAM,OAAO,MAAM;AAAA,IACjC,WAAW,MAAM,+BAA+B,GAAG;AACjD,YAAM,uBAAuB,OAAO,MAAM;AAAA,IAC5C,OAAO;AACL;AAAA,IACF;AAAA,EACF;AAAA,EACA,gCAAgC,IAAI;AAClC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,IAAI,MAAM,SAAS;AACvB,QAAI,QAAQ,MAAM,CAAC;AACnB,WAAO,MAAM,+BAA+B,GAAG;AAC7C,UAAI,MAAM,SAAS,GAAG;AACpB,cAAM,uBAAuB,OAAO,wBAAwB,EAAE;AAAA,MAChE;AACA,cAAQ,MAAM,EAAE,CAAC;AAAA,IACnB;AAAA,EACF;AAAA,EACA,oBAAoB;AAClB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,UAAM,eAAe,MAAM,MAAM,SAAS,CAAC;AAC3C,QAAI,CAAC,aAAa,+BAA+B;AAAG;AACpD,iBAAa,cAAc,CAAC,CAAC,cAAc,GAAG,MAAM;AAClD,WAAK,OAAO,MAAM,cAAc,GAAG;AACnC,UAAI,IAAI,MAAM,SAAS;AACvB,UAAI,QAAQ,MAAM,CAAC;AACnB,aAAO,MAAM,+BAA+B,GAAG;AAC7C,cAAM,sBAAsB,IAAI,KAAK;AACrC,gBAAQ,MAAM,EAAE,CAAC;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,SAAS,+BAA+B;AACtC,SAAO,IAAI,gBAAgB,CAAC;AAC9B;AACA,SAAS,oBAAoB;AAC3B,SAAO,IAAI,sBAAsB,CAAC;AACpC;AACA,SAAS,qBAAqB;AAC5B,SAAO,IAAI,sBAAsB,CAAC;AACpC;AACA,SAAS,qBAAqB;AAC5B,SAAO,IAAI,gBAAgB;AAC7B;AACA,MAAM,2BAA2B;AAAA,EAC/B,cAAc;AACZ,SAAK,SAAS,CAAC;AAAA,EACjB;AAAA,EACA,MAAM,OAAO;AACX,SAAK,OAAO,KAAK,KAAK;AAAA,EACxB;AAAA,EACA,OAAO;AACL,SAAK,OAAO,IAAI;AAAA,EAClB;AAAA,EACA,eAAe;AACb,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,EAC3C;AAAA,EACA,IAAI,WAAW;AACb,YAAQ,KAAK,aAAa,IAAI,KAAK;AAAA,EACrC;AAAA,EACA,IAAI,WAAW;AACb,YAAQ,KAAK,aAAa,IAAI,KAAK;AAAA,EACrC;AAAA,EACA,IAAI,YAAY;AACd,YAAQ,KAAK,aAAa,IAAI,KAAK;AAAA,EACrC;AAAA,EACA,IAAI,QAAQ;AACV,YAAQ,KAAK,aAAa,IAAI,KAAK;AAAA,EACrC;AACF;AACA,SAAS,cAAc,SAAS,aAAa;AAC3C,UAAQ,UAAU,IAAI,MAAM,cAAc,IAAI;AAChD;AACA,MAAM,mBAAmB,UAAU;AAAA,EACjC,SAAS,MAAM,KAAK,OAAO,aAAa,MAAM;AAC5C,QAAI,CAAC;AAAM;AACX,UAAM,QAAQ,KAAK,QAAQ,KAAK,SAAS,CAAC;AAC1C,QAAI,YAAY;AACd,YAAM,GAAG,IAAI;AAAA,IACf,OAAO;AACL,aAAO,eAAe,OAAO,KAAK;AAAA,QAChC;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,aAAa,OAAO;AAClB,WAAO,KAAK,MAAM,SAAS,SAAS,CAAC,KAAK,MAAM;AAAA,EAClD;AAAA,EACA,qBAAqB,WAAW,MAAM;AACpC,UAAM,UAAU,YAAY,KAAK;AACjC,QAAI,KAAK,MAAM,MAAM,WAAW,OAAO,MAAM,MAAM;AACjD,YAAM,SAAS,KAAK,MAAM,WAAW,OAAO;AAC5C,aAAO,EAAE,iBAAiB,MAAM,MAAM,SAAS,WAAY;AAAA,IAC7D;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,MAAM;AAC1B,UAAM,OAAO,KAAK,eAAe;AACjC,WAAO,KAAK,qBAAqB,MAAM,IAAI;AAAA,EAC7C;AAAA,EACA,cAAc,OAAO;AACnB,QAAI,KAAK,aAAa,KAAK,GAAG;AAC5B,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB,OAAO,cAAc;AACpC,QAAI,CAAC,KAAK,cAAc,KAAK,GAAG;AAC9B,UAAI,gBAAgB,MAAM;AACxB,cAAM,KAAK,MAAM,cAAc,KAAK,MAAM,QAAQ;AAAA,MACpD;AACA,WAAK,WAAW,MAAM,KAAK;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,qBAAqB;AACnB,WAAO,KAAK,MAAM,GAAG,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,sBAAsB;AAAA,EACxE;AAAA,EACA,wBAAwB;AACtB,WAAO,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,MAAM,cAAc,OAAO,KAAK,MAAM,KAAK,CAAC;AAAA,EAC1F;AAAA,EACA,wBAAwB;AACtB,8BAA0B,YAAY,KAAK,MAAM;AACjD,WAAO,0BAA0B,KAAK,KAAK,KAAK;AAAA,EAClD;AAAA,EACA,mBAAmB;AACjB,WAAO,KAAK,IAAI,EAAE,KAAK,KAAK,mBAAmB;AAAA,EACjD;AAAA,EACA,UAAU,WAAW,MAAM;AACzB,QAAI,WAAW,KAAK,iBAAiB,IAAI,KAAK,IAAI,EAAE;AAAG;AACvD,SAAK,MAAM,OAAO,kBAAkB,KAAK,MAAM,aAAa;AAAA,EAC9D;AAAA,EACA,OAAO,MAAM,KAAK;AAChB,SAAK,IAAI,IAAI,KAAK,KAAK,WAAW,KAAK,IAAI;AAAA,EAC7C;AAAA,EACA,SAAS,IAAI,WAAW,KAAK,MAAM,MAAM,GAAG;AAC1C,UAAM,cAAc;AAAA,MAClB,MAAM;AAAA,IACR;AACA,QAAI;AACF,YAAM,OAAO,GAAG,CAACE,QAAO,SAAS;AAC/B,oBAAY,OAAOA;AACnB,cAAM;AAAA,MACR,CAAC;AACD,UAAI,KAAK,MAAM,OAAO,SAAS,SAAS,OAAO,QAAQ;AACrD,cAAM,YAAY,KAAK;AACvB,aAAK,QAAQ;AACb,aAAK,MAAM,eAAe,UAAU;AACpC,eAAO;AAAA,UACL;AAAA,UACA,OAAO,UAAU,OAAO,SAAS,OAAO,MAAM;AAAA,UAC9C,QAAQ;AAAA,UACR,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,QACL;AAAA,QACA,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,WAAW;AAAA,MACb;AAAA,IACF,SAAS,OAAO;AACd,YAAM,YAAY,KAAK;AACvB,WAAK,QAAQ;AACb,UAAI,iBAAiB,aAAa;AAChC,eAAO;AAAA,UACL,MAAM;AAAA,UACN;AAAA,UACA,QAAQ;AAAA,UACR,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AACA,UAAI,UAAU,aAAa;AACzB,eAAO;AAAA,UACL,MAAM,YAAY;AAAA,UAClB,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,sBAAsB,qBAAqB,UAAU;AACnD,QAAI,CAAC;AAAqB,aAAO;AACjC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,YAAY,CAAC,CAAC,sBAAsB,CAAC,CAAC,kBAAkB,CAAC,CAAC,yBAAyB,CAAC,CAAC;AAC3F,QAAI,CAAC,UAAU;AACb,aAAO;AAAA,IACT;AACA,QAAI,sBAAsB,MAAM;AAC9B,WAAK,MAAM,OAAO,6BAA6B,kBAAkB;AAAA,IACnE;AACA,QAAI,kBAAkB,MAAM;AAC1B,WAAK,MAAM,OAAO,gBAAgB,cAAc;AAAA,IAClD;AACA,QAAI,iBAAiB,MAAM;AACzB,WAAK,MAAM,OAAO,wBAAwB,aAAa;AAAA,IACzD;AACA,QAAI,yBAAyB,MAAM;AACjC,WAAK,WAAW,qBAAqB;AAAA,IACvC;AAAA,EACF;AAAA,EACA,wBAAwB;AACtB,WAAO,2BAA2B,KAAK,MAAM,IAAI;AAAA,EACnD;AAAA,EACA,cAAc,MAAM;AAClB,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EACA,iBAAiB,MAAM;AACrB,WAAO,KAAK,GAAG;AAAA,EACjB;AAAA,EACA,yBAAyB,MAAM;AAC7B,YAAQ,KAAK,SAAS,sBAAsB,KAAK,SAAS,+BAA+B,KAAK,cAAc,KAAK,QAAQ;AAAA,EAC3H;AAAA,EACA,iBAAiB,MAAM;AACrB,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EACA,eAAe,MAAM;AACnB,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EACA,iBAAiB,WAAW,KAAK,QAAQ,eAAe,UAAU;AAChE,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS,CAAC;AACrB,UAAM,yBAAyB,KAAK;AACpC,SAAK,sBAAsB,oBAAI,IAAI;AACnC,UAAM,cAAc,KAAK;AACzB,SAAK,WAAW;AAChB,UAAM,WAAW,KAAK;AACtB,UAAMC,gBAAe,KAAK,gBAAgB;AAC1C,SAAK,QAAQ,IAAIA,cAAa,MAAM,QAAQ;AAC5C,UAAM,eAAe,KAAK;AAC1B,SAAK,YAAY,IAAI,2BAA2B;AAChD,UAAM,gBAAgB,KAAK;AAC3B,SAAK,aAAa,IAAI,kBAAkB,IAAI;AAC5C,UAAM,qBAAqB,KAAK;AAChC,SAAK,kBAAkB,IAAI,uBAAuB,IAAI;AACtD,WAAO,MAAM;AACX,WAAK,MAAM,SAAS;AACpB,WAAK,sBAAsB;AAC3B,WAAK,WAAW;AAChB,WAAK,QAAQ;AACb,WAAK,YAAY;AACjB,WAAK,aAAa;AAClB,WAAK,kBAAkB;AAAA,IACzB;AAAA,EACF;AAAA,EACA,qBAAqB;AACnB,QAAI,aAAa;AACjB,QAAI,KAAK,UAAU;AACjB,oBAAc;AAAA,IAChB;AACA,SAAK,MAAM,MAAM,CAAC;AAClB,SAAK,UAAU,MAAM,UAAU;AAAA,EACjC;AAAA,EACA,0BAA0B,qBAAqB;AAC7C,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,kBAAkB,MAAM;AAC1B,WAAK,aAAa,wBAAwB,aAAa;AAAA,IACzD;AAAA,EACF;AACF;AACA,MAAM,iBAAiB;AAAA,EACrB,cAAc;AACZ,SAAK,qBAAqB;AAC1B,SAAK,iBAAiB;AACtB,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAAA,EAC/B;AACF;AACA,MAAM,KAAK;AAAA,EACT,YAAY,QAAQ,KAAK,KAAK;AAC5B,SAAK,OAAO;AACZ,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,MAAM,IAAI,eAAe,GAAG;AACjC,QAAI,UAAU,QAAQ,OAAO,QAAQ;AAAQ,WAAK,QAAQ,CAAC,KAAK,CAAC;AACjE,QAAI,UAAU,QAAQ,OAAO;AAAU,WAAK,IAAI,WAAW,OAAO;AAAA,EACpE;AACF;AACA,MAAM,gBAAgB,KAAK;AAC3B;AACE,gBAAc,UAAU,WAAY;AAClC,UAAM,UAAU,IAAI,KAAK,QAAW,KAAK,OAAO,KAAK,IAAI,KAAK;AAC9D,UAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,aAAS,IAAI,GAAG,SAAS,KAAK,QAAQ,IAAI,QAAQ,KAAK;AACrD,YAAM,MAAM,KAAK,CAAC;AAClB,UAAI,QAAQ,qBAAqB,QAAQ,sBAAsB,QAAQ,iBAAiB;AACtF,gBAAQ,GAAG,IAAI,KAAK,GAAG;AAAA,MACzB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;AACA,SAAS,iBAAiB,MAAM;AAC9B,SAAO,gBAAgB,IAAI;AAC7B;AACA,SAAS,gBAAgB,MAAM;AAC7B,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,SAAS,OAAO,OAAO,aAAa;AAC1C,SAAO,OAAO;AACd,SAAO,QAAQ;AACf,SAAO,MAAM;AACb,SAAO,MAAM;AACb,SAAO,QAAQ;AACf,SAAO,QAAQ;AACf,SAAO,OAAO;AACd,MAAI,SAAS,eAAe;AAC1B,WAAO,eAAe,KAAK;AAAA,EAC7B;AACA,SAAO;AACT;AACA,SAAS,mBAAmB,MAAM;AAChC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,MAAI,SAAS,eAAe;AAC1B,WAAO,iBAAiB,IAAI;AAAA,EAC9B;AACA,QAAM,SAAS,OAAO,OAAO,aAAa;AAC1C,SAAO,OAAO;AACd,SAAO,QAAQ;AACf,SAAO,MAAM;AACb,SAAO,MAAM;AACb,SAAO,QAAQ;AACf,MAAI,KAAK,QAAQ,QAAW;AAC1B,WAAO,MAAM,KAAK;AAAA,EACpB,OAAO;AACL,WAAO,QAAQ;AAAA,EACjB;AACA,SAAO,QAAQ,KAAK;AACpB,SAAO;AACT;AACA,MAAM,kBAAkB,WAAW;AAAA,EACjC,YAAY;AACV,UAAM,MAAM,KAAK,MAAM;AACvB,WAAO,IAAI,KAAK,MAAM,IAAI,OAAO,GAAG;AAAA,EACtC;AAAA,EACA,YAAY,KAAK;AACf,WAAO,IAAI,KAAK,MAAM,IAAI,OAAO,GAAG;AAAA,EACtC;AAAA,EACA,gBAAgB,MAAM;AACpB,WAAO,KAAK,YAAY,KAAK,IAAI,KAAK;AAAA,EACxC;AAAA,EACA,WAAW,MAAM,MAAM;AACrB,WAAO,KAAK,aAAa,MAAM,MAAM,KAAK,MAAM,aAAa;AAAA,EAC/D;AAAA,EACA,aAAa,MAAM,MAAM,QAAQ;AAC/B,SAAK,OAAO;AACZ,SAAK,MAAM,OAAO;AAClB,SAAK,IAAI,MAAM;AACf,QAAI,KAAK,QAAQ;AAAQ,WAAK,MAAM,CAAC,IAAI,OAAO;AAChD,QAAI,KAAK,QAAQ;AAAe,WAAK,eAAe,IAAI;AACxD,WAAO;AAAA,EACT;AAAA,EACA,mBAAmB,MAAM,UAAU;AACjC,SAAK,QAAQ,SAAS;AACtB,SAAK,IAAI,QAAQ;AACjB,QAAI,KAAK,QAAQ;AAAQ,WAAK,MAAM,CAAC,IAAI,SAAS;AAAA,EACpD;AAAA,EACA,iBAAiB,MAAM,SAAS,KAAK,MAAM,eAAe;AACxD,SAAK,MAAM,OAAO;AAClB,SAAK,IAAI,MAAM;AACf,QAAI,KAAK,QAAQ;AAAQ,WAAK,MAAM,CAAC,IAAI,OAAO;AAAA,EAClD;AAAA,EACA,2BAA2B,MAAM,cAAc;AAC7C,SAAK,mBAAmB,MAAM,aAAa,IAAI,KAAK;AAAA,EACtD;AACF;AACA,MAAM,gBAAgB,oBAAI,IAAI,CAAC,KAAK,OAAO,QAAQ,WAAW,SAAS,WAAW,SAAS,aAAa,SAAS,QAAQ,UAAU,UAAU,UAAU,QAAQ,UAAU,MAAM,CAAC;AAChL,MAAM,aAAa,qBAAqB;AAAA,EACtC,2BAA2B;AAAA,EAC3B,4BAA4B;AAAA,EAC5B,oBAAoB,CAAC;AAAA,IACnB;AAAA,EACF,MAAM,kCAAkC,YAAY;AAAA,EACpD,qBAAqB;AAAA,EACrB,8BAA8B;AAAA,EAC9B,+BAA+B;AAAA,EAC/B,iCAAiC,CAAC;AAAA,IAChC;AAAA,IACA;AAAA,EACF,MAAM,6DAA6D,UAAU,mBAAmB,UAAU,yBAAyB,QAAQ;AAAA,EAC3I,yBAAyB,CAAC;AAAA,IACxB;AAAA,IACA;AAAA,EACF,MAAM,uDAAuD,UAAU,6CAA6C,QAAQ;AAAA,EAC5H,8BAA8B,CAAC;AAAA,IAC7B;AAAA,EACF,MAAM,UAAU,QAAQ;AAAA,EACxB,yBAAyB,CAAC;AAAA,IACxB;AAAA,IACA;AAAA,EACF,MAAM,eAAe,eAAe,4FAA4F,QAAQ;AAAA,EACxI,wCAAwC,CAAC;AAAA,IACvC;AAAA,EACF,MAAM,4GAA4G,QAAQ;AAAA,EAC1H,yCAAyC,CAAC;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAM,UAAU,QAAQ,iBAAiB,YAAY,+BAA+B,UAAU,oBAAoB,YAAY;AAAA,EAC9H,wCAAwC,CAAC;AAAA,IACvC;AAAA,IACA;AAAA,EACF,MAAM,oDAAoD,UAAU,iBAAiB,QAAQ;AAAA,EAC7F,yCAAyC,CAAC;AAAA,IACxC;AAAA,IACA;AAAA,EACF,MAAM,qCAAqC,UAAU,4EAA4E,QAAQ;AAAA,EACzI,uBAAuB,CAAC;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAM,qFAAqF,UAAU,wBAAwB,UAAU,iBAAiB,QAAQ;AAAA,EAChK,gCAAgC,CAAC;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,MAAM,sDAAsD,UAAU,oBAAoB,QAAQ;AAAA,EAClG,2CAA2C,CAAC;AAAA,IAC1C;AAAA,EACF,MAAM,2GAA2G,QAAQ;AAAA,EACzH,2BAA2B;AAAA,EAC3B,+BAA+B;AAAA,EAC/B,qCAAqC;AAAA,EACrC,oBAAoB;AAAA,EACpB,wBAAwB;AAAA,EACxB,iBAAiB;AAAA,EACjB,qCAAqC;AAAA,EACrC,yBAAyB;AAAA,EACzB,qBAAqB;AAAA,EACrB,mBAAmB;AAAA,EACnB,mBAAmB,OAAO,OAAO;AAAA,IAC/B,SAAS;AAAA,EACX,GAAG;AAAA,IACD,YAAY;AAAA,EACd,CAAC;AAAA,EACD,2BAA2B;AAAA,EAC3B,gBAAgB;AAAA,EAChB,6BAA6B;AAAA,EAC7B,8BAA8B;AAAA,EAC9B,2BAA2B;AAAA,EAC3B,sBAAsB;AAAA,EACtB,oBAAoB;AAAA,EACpB,uBAAuB;AAAA,EACvB,mBAAmB;AAAA,EACnB,mCAAmC;AAAA,EACnC,wBAAwB,CAAC;AAAA,IACvB;AAAA,EACF,MAAM,4BAA4B,YAAY;AAAA,EAC9C,8BAA8B;AAAA,EAC9B,oCAAoC;AAAA,EACpC,sBAAsB;AAAA,EACtB,8BAA8B;AAAA,EAC9B,mCAAmC;AAAA,EACnC,iDAAiD;AAAA,EACjD,8BAA8B,CAAC;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,MAAM,oBAAoB,qBAAqB,8BAA8B,UAAU;AAAA,EACvF,qCAAqC;AAAA,EACrC,yBAAyB;AAC3B,CAAC;AACD,SAAS,eAAe,aAAa;AACnC,SAAO,YAAY,SAAS,iCAAiC,YAAY,SAAS,+BAA+B,CAAC,YAAY,eAAe,YAAY,YAAY,SAAS,eAAe,YAAY,YAAY,SAAS;AAChO;AACA,SAAS,kBAAkB,MAAM;AAC/B,SAAO,KAAK,eAAe,UAAU,KAAK,eAAe;AAC3D;AACA,MAAM,oBAAoB;AAAA,EACxB,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA,EACN,WAAW;AACb;AACA,SAAS,UAAU,MAAM,MAAM;AAC7B,QAAM,QAAQ,CAAC;AACf,QAAM,QAAQ,CAAC;AACf,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,KAAC,KAAK,KAAK,CAAC,GAAG,GAAG,IAAI,IAAI,QAAQ,OAAO,KAAK,KAAK,CAAC,CAAC;AAAA,EACvD;AACA,SAAO,CAAC,OAAO,KAAK;AACtB;AACA,MAAM,oBAAoB;AAC1B,IAAI,OAAO,gBAAc,MAAM,wBAAwB,WAAW;AAAA,EAChE,eAAe,MAAM;AACnB,UAAM,GAAG,IAAI;AACb,SAAK,aAAa;AAAA,EACpB;AAAA,EACA,kBAAkB;AAChB,WAAO;AAAA,EACT;AAAA,EACA,mBAAmB;AACjB,WAAO,KAAK,gBAAgB,QAAQ,KAAK,KAAK,KAAK,eAAe;AAAA,EACpE;AAAA,EACA,mBAAmB;AACjB,WAAO,CAAC,CAAC,KAAK,gBAAgB,QAAQ,OAAO;AAAA,EAC/C;AAAA,EACA,YAAY,MAAM,KAAK;AACrB,QAAI,SAAS,OAAO,SAAS,MAAM,SAAS,IAAI;AAC9C,UAAI,KAAK,eAAe,QAAW;AACjC,aAAK,aAAa;AAAA,MACpB;AAAA,IACF;AACA,UAAM,YAAY,MAAM,GAAG;AAAA,EAC7B;AAAA,EACA,WAAW,SAAS;AAClB,QAAI,KAAK,eAAe,QAAW;AACjC,YAAM,UAAU,kBAAkB,KAAK,QAAQ,KAAK;AACpD,UAAI,CAAC;AAAS;AAAA,eAAU,QAAQ,CAAC,MAAM,QAAQ;AAC7C,aAAK,aAAa;AAAA,MACpB,WAAW,QAAQ,CAAC,MAAM,UAAU;AAClC,aAAK,aAAa;AAAA,MACpB,OAAO;AACL,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC1C;AAAA,IACF;AACA,UAAM,WAAW,OAAO;AAAA,EAC1B;AAAA,EACA,yBAAyB,KAAK;AAC5B,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS;AACpB,SAAK,OAAO,OAAO,EAAE;AACrB,UAAM,OAAO,KAAK,cAAc;AAChC,SAAK,MAAM,SAAS;AACpB,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,KAAK;AACV,SAAK,iBAAiB,GAAG;AACzB,QAAI,KAAK,MAAM,gBAAgB,QAAQ,UAAU,QAAQ,GAAG;AAC1D,WAAK,MAAM,WAAW,oCAAoC,SAAS;AAAA,IACrE;AACA,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,QAAQ,MAAM,gBAAgB;AACnC,WAAK,OAAO,EAAE;AACd,aAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,IAClD,OAAO;AACL,aAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,IAClD;AAAA,EACF;AAAA,EACA,uCAAuC;AACrC,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS;AACpB,SAAK,OAAO,EAAE;AACd,QAAI,OAAO;AACX,QAAI,YAAY;AAChB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,MAAM,SAAS;AACpB,kBAAY,KAAK,mBAAmB;AAAA,IACtC,OAAO;AACL,aAAO,KAAK,cAAc;AAC1B,WAAK,MAAM,SAAS;AACpB,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,oBAAY,KAAK,mBAAmB;AAAA,MACtC;AAAA,IACF;AACA,WAAO,CAAC,MAAM,SAAS;AAAA,EACzB;AAAA,EACA,sBAAsB,MAAM;AAC1B,SAAK,KAAK;AACV,SAAK,sBAAsB,MAAM,IAAI;AACrC,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,yBAAyB,MAAM;AAC7B,SAAK,KAAK;AACV,UAAM,KAAK,KAAK,KAAK,KAAK,gBAAgB;AAC1C,UAAM,WAAW,KAAK,UAAU;AAChC,UAAM,gBAAgB,KAAK,UAAU;AACrC,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,eAAS,iBAAiB,KAAK,kCAAkC;AAAA,IACnE,OAAO;AACL,eAAS,iBAAiB;AAAA,IAC5B;AACA,SAAK,OAAO,EAAE;AACd,UAAM,MAAM,KAAK,4BAA4B;AAC7C,aAAS,SAAS,IAAI;AACtB,aAAS,OAAO,IAAI;AACpB,aAAS,OAAO,IAAI;AACpB,SAAK,OAAO,EAAE;AACd,KAAC,SAAS,YAAY,KAAK,SAAS,IAAI,KAAK,qCAAqC;AAClF,kBAAc,iBAAiB,KAAK,WAAW,UAAU,wBAAwB;AACjF,OAAG,iBAAiB,KAAK,WAAW,eAAe,gBAAgB;AACnE,SAAK,iBAAiB,EAAE;AACxB,SAAK,UAAU;AACf,SAAK,MAAM,YAAY,KAAK,GAAG,MAAM,MAAM,KAAK,GAAG,IAAI,KAAK;AAC5D,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,iBAAiB,MAAM,cAAc;AACnC,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,KAAK,sBAAsB,IAAI;AAAA,IACxC,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,aAAO,KAAK,yBAAyB,IAAI;AAAA,IAC3C,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,aAAO,KAAK,yBAAyB,IAAI;AAAA,IAC3C,WAAW,KAAK,cAAc,GAAG,GAAG;AAClC,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,eAAO,KAAK,8BAA8B,IAAI;AAAA,MAChD,OAAO;AACL,YAAI,cAAc;AAChB,eAAK,MAAM,WAAW,qBAAqB,KAAK,MAAM,eAAe;AAAA,QACvE;AACA,eAAO,KAAK,uBAAuB,IAAI;AAAA,MACzC;AAAA,IACF,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,aAAO,KAAK,0BAA0B,IAAI;AAAA,IAC5C,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,aAAO,KAAK,2BAA2B,IAAI;AAAA,IAC7C,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,aAAO,KAAK,0BAA0B,IAAI;AAAA,IAC5C,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,aAAO,KAAK,kCAAkC,MAAM,YAAY;AAAA,IAClE,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,yBAAyB,MAAM;AAC7B,SAAK,KAAK;AACV,SAAK,KAAK,KAAK,mCAAmC,IAAI;AACtD,SAAK,MAAM,YAAY,KAAK,GAAG,MAAM,GAAG,KAAK,GAAG,IAAI,KAAK;AACzD,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,uBAAuB,MAAM;AAC3B,SAAK,MAAM,MAAM,CAAC;AAClB,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,WAAK,KAAK,MAAM,cAAc;AAAA,IAChC,OAAO;AACL,WAAK,KAAK,KAAK,gBAAgB;AAAA,IACjC;AACA,UAAM,WAAW,KAAK,OAAO,KAAK,UAAU;AAC5C,UAAM,OAAO,SAAS,OAAO,CAAC;AAC9B,SAAK,OAAO,CAAC;AACb,WAAO,CAAC,KAAK,MAAM,CAAC,GAAG;AACrB,UAAIC,YAAW,KAAK,UAAU;AAC9B,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAK,KAAK;AACV,YAAI,CAAC,KAAK,aAAa,GAAG,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AAC9C,eAAK,MAAM,WAAW,qCAAqC,KAAK,MAAM,eAAe;AAAA,QACvF;AACA,cAAM,YAAYA,SAAQ;AAAA,MAC5B,OAAO;AACL,aAAK,iBAAiB,KAAK,WAAW,mCAAmC;AACzE,QAAAA,YAAW,KAAK,iBAAiBA,WAAU,IAAI;AAAA,MACjD;AACA,WAAK,KAAKA,SAAQ;AAAA,IACpB;AACA,SAAK,MAAM,KAAK;AAChB,SAAK,OAAO,CAAC;AACb,SAAK,WAAW,UAAU,gBAAgB;AAC1C,QAAI,OAAO;AACX,QAAI,kBAAkB;AACtB,SAAK,QAAQ,iBAAe;AAC1B,UAAI,eAAe,WAAW,GAAG;AAC/B,YAAI,SAAS,YAAY;AACvB,eAAK,MAAM,WAAW,4BAA4B,WAAW;AAAA,QAC/D;AACA,eAAO;AAAA,MACT,WAAW,YAAY,SAAS,wBAAwB;AACtD,YAAI,iBAAiB;AACnB,eAAK,MAAM,WAAW,+BAA+B,WAAW;AAAA,QAClE;AACA,YAAI,SAAS,MAAM;AACjB,eAAK,MAAM,WAAW,4BAA4B,WAAW;AAAA,QAC/D;AACA,eAAO;AACP,0BAAkB;AAAA,MACpB;AAAA,IACF,CAAC;AACD,SAAK,OAAO,QAAQ;AACpB,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,kCAAkC,MAAM,cAAc;AACpD,SAAK,OAAO,EAAE;AACd,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,aAAK,cAAc,KAAK,iBAAiB,KAAK,UAAU,CAAC;AAAA,MAC3D,OAAO;AACL,aAAK,cAAc,KAAK,cAAc;AACtC,aAAK,UAAU;AAAA,MACjB;AACA,WAAK,UAAU;AACf,aAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,IACzD,OAAO;AACL,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,MAAM,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,GAAG,MAAM,CAAC,cAAc;AACzG,cAAM,QAAQ,KAAK,MAAM;AACzB,cAAM,KAAK,MAAM,WAAW,8BAA8B,KAAK,MAAM,UAAU;AAAA,UAC7E,uBAAuB;AAAA,UACvB,YAAY,kBAAkB,KAAK;AAAA,QACrC,CAAC;AAAA,MACH;AACA,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,aAAa,GAAG,GAAG;AAChF,aAAK,cAAc,KAAK,iBAAiB,KAAK,UAAU,CAAC;AACzD,aAAK,UAAU;AACf,eAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,MACzD,WAAW,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,GAAG,GAAG;AACxH,eAAO,KAAK,YAAY,MAAM,IAAI;AAClC,YAAI,KAAK,SAAS,0BAA0B;AAC1C,eAAK,OAAO;AACZ,eAAK,UAAU;AACf,iBAAO,KAAK;AAAA,QACd;AACA,aAAK,OAAO,YAAY,KAAK;AAC7B,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,WAAW;AAAA,EAClB;AAAA,EACA,8BAA8B,MAAM;AAClC,SAAK,KAAK;AACV,SAAK,iBAAiB,GAAG;AACzB,SAAK,iBAAiB,KAAK,wBAAwB;AACnD,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,EACrD;AAAA,EACA,0BAA0B,MAAM;AAC9B,SAAK,KAAK;AACV,UAAM,WAAW,KAAK,mBAAmB,IAAI;AAC7C,aAAS,OAAO;AAChB,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B,MAAM;AAC/B,SAAK,KAAK;AACV,UAAM,WAAW,KAAK,oBAAoB,MAAM,IAAI;AACpD,aAAS,OAAO;AAChB,WAAO;AAAA,EACT;AAAA,EACA,0BAA0B,MAAM;AAC9B,SAAK,KAAK;AACV,SAAK,sBAAsB,MAAM,KAAK;AACtC,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,sBAAsB,MAAM,SAAS;AACnC,SAAK,KAAK,KAAK,8BAA8B,CAAC,SAAS,IAAI;AAC3D,SAAK,MAAM,YAAY,KAAK,GAAG,MAAM,UAAU,KAAK,MAAM,KAAK,GAAG,IAAI,KAAK;AAC3E,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,kCAAkC;AAAA,IAC/D,OAAO;AACL,WAAK,iBAAiB;AAAA,IACxB;AACA,SAAK,UAAU,CAAC;AAChB,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,SAAG;AACD,aAAK,QAAQ,KAAK,KAAK,0BAA0B,CAAC;AAAA,MACpD,SAAS,CAAC,WAAW,KAAK,IAAI,EAAE;AAAA,IAClC;AACA,QAAI,SAAS;AACX,WAAK,aAAa,CAAC;AACnB,WAAK,SAAS,CAAC;AACf,UAAI,KAAK,cAAc,GAAG,GAAG;AAC3B,WAAG;AACD,eAAK,OAAO,KAAK,KAAK,0BAA0B,CAAC;AAAA,QACnD,SAAS,KAAK,IAAI,EAAE;AAAA,MACtB;AACA,UAAI,KAAK,cAAc,GAAG,GAAG;AAC3B,WAAG;AACD,eAAK,WAAW,KAAK,KAAK,0BAA0B,CAAC;AAAA,QACvD,SAAS,KAAK,IAAI,EAAE;AAAA,MACtB;AAAA,IACF;AACA,SAAK,OAAO,KAAK,oBAAoB;AAAA,MACnC,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,cAAc;AAAA,IAChB,CAAC;AAAA,EACH;AAAA,EACA,4BAA4B;AAC1B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK,KAAK,iCAAiC;AAChD,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,oCAAoC;AAAA,IACjE,OAAO;AACL,WAAK,iBAAiB;AAAA,IACxB;AACA,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,mBAAmB,MAAM;AACvB,SAAK,sBAAsB,MAAM,KAAK;AACtC,WAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,EACrD;AAAA,EACA,mBAAmB,MAAM;AACvB,QAAI,SAAS,KAAK;AAChB,WAAK,MAAM,WAAW,8BAA8B,KAAK,MAAM,QAAQ;AAAA,IACzE;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM,UAAU,aAAa;AAC7C,QAAI,CAAC,cAAc,IAAI,IAAI;AAAG;AAC9B,SAAK,MAAM,cAAc,WAAW,qBAAqB,WAAW,wBAAwB,UAAU;AAAA,MACpG,cAAc;AAAA,IAChB,CAAC;AAAA,EACH;AAAA,EACA,8BAA8B,SAAS,aAAa;AAClD,SAAK,kBAAkB,KAAK,MAAM,OAAO,KAAK,MAAM,UAAU,WAAW;AACzE,WAAO,KAAK,gBAAgB,OAAO;AAAA,EACrC;AAAA,EACA,mBAAmB,MAAM;AACvB,SAAK,KAAK,KAAK,8BAA8B,OAAO,IAAI;AACxD,SAAK,MAAM,YAAY,KAAK,GAAG,MAAM,MAAM,KAAK,GAAG,IAAI,KAAK;AAC5D,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,kCAAkC;AAAA,IAC/D,OAAO;AACL,WAAK,iBAAiB;AAAA,IACxB;AACA,SAAK,QAAQ,KAAK,yBAAyB,EAAE;AAC7C,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,WAAW;AAAA,EAC1C;AAAA,EACA,oBAAoB,MAAM,SAAS;AACjC,SAAK,iBAAiB,GAAG;AACzB,SAAK,KAAK,KAAK,8BAA8B,MAAM,IAAI;AACvD,SAAK,MAAM,YAAY,KAAK,GAAG,MAAM,MAAM,KAAK,GAAG,IAAI,KAAK;AAC5D,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,kCAAkC;AAAA,IAC/D,OAAO;AACL,WAAK,iBAAiB;AAAA,IACxB;AACA,SAAK,YAAY;AACjB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,YAAY,KAAK,yBAAyB,EAAE;AAAA,IACnD;AACA,SAAK,WAAW;AAChB,QAAI,CAAC,SAAS;AACZ,WAAK,WAAW,KAAK,yBAAyB,EAAE;AAAA,IAClD;AACA,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,YAAY;AAAA,EAC3C;AAAA,EACA,uBAAuB,iBAAiB,OAAO;AAC7C,UAAM,eAAe,KAAK,MAAM;AAChC,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,WAAW,KAAK,kBAAkB;AACxC,UAAM,QAAQ,KAAK,mCAAmC;AACtD,SAAK,OAAO,MAAM;AAClB,SAAK,WAAW;AAChB,SAAK,QAAQ,MAAM;AACnB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,IAAI,EAAE;AACX,WAAK,UAAU,KAAK,cAAc;AAAA,IACpC,OAAO;AACL,UAAI,gBAAgB;AAClB,aAAK,MAAM,WAAW,yBAAyB,YAAY;AAAA,MAC7D;AAAA,IACF;AACA,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,oCAAoC;AAClC,UAAM,YAAY,KAAK,MAAM;AAC7B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,SAAS,CAAC;AACf,SAAK,MAAM,SAAS;AACpB,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,GAAG,GAAG;AACrC,WAAK,KAAK;AAAA,IACZ,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AACA,QAAI,kBAAkB;AACtB,OAAG;AACD,YAAM,gBAAgB,KAAK,uBAAuB,eAAe;AACjE,WAAK,OAAO,KAAK,aAAa;AAC9B,UAAI,cAAc,SAAS;AACzB,0BAAkB;AAAA,MACpB;AACA,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF,SAAS,CAAC,KAAK,MAAM,EAAE;AACvB,SAAK,OAAO,EAAE;AACd,SAAK,MAAM,SAAS;AACpB,WAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,EACzD;AAAA,EACA,sCAAsC;AACpC,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,SAAS,CAAC;AACf,SAAK,MAAM,SAAS;AACpB,SAAK,OAAO,EAAE;AACd,UAAM,wBAAwB,KAAK,MAAM;AACzC,SAAK,MAAM,qBAAqB;AAChC,WAAO,CAAC,KAAK,MAAM,EAAE,GAAG;AACtB,WAAK,OAAO,KAAK,KAAK,cAAc,CAAC;AACrC,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,SAAK,MAAM,qBAAqB;AAChC,SAAK,OAAO,EAAE;AACd,SAAK,MAAM,SAAS;AACpB,WAAO,KAAK,WAAW,MAAM,4BAA4B;AAAA,EAC3D;AAAA,EACA,+CAA+C;AAC7C,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,SAAS,CAAC;AACf,SAAK,MAAM,SAAS;AACpB,SAAK,OAAO,EAAE;AACd,WAAO,CAAC,KAAK,MAAM,EAAE,GAAG;AACtB,WAAK,OAAO,KAAK,KAAK,qCAAqC,CAAC;AAC5D,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,SAAK,OAAO,EAAE;AACd,SAAK,MAAM,SAAS;AACpB,WAAO,KAAK,WAAW,MAAM,4BAA4B;AAAA,EAC3D;AAAA,EACA,yBAAyB;AACvB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,iBAAiB,GAAG;AACzB,SAAK,UAAU,CAAC;AAChB,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,SAAG;AACD,aAAK,QAAQ,KAAK,KAAK,0BAA0B,CAAC;AAAA,MACpD,SAAS,KAAK,IAAI,EAAE;AAAA,IACtB;AACA,SAAK,OAAO,KAAK,oBAAoB;AAAA,MACnC,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,cAAc;AAAA,IAChB,CAAC;AACD,WAAO,KAAK,WAAW,MAAM,yBAAyB;AAAA,EACxD;AAAA,EACA,6BAA6B;AAC3B,WAAO,KAAK,MAAM,GAAG,KAAK,KAAK,MAAM,GAAG,IAAI,MAAM,cAAc,IAAI,KAAK,gBAAgB,IAAI;AAAA,EAC/F;AAAA,EACA,2BAA2B,MAAM,UAAU,UAAU;AACnD,SAAK,SAAS;AACd,QAAI,KAAK,UAAU,EAAE,SAAS,IAAI;AAChC,WAAK,KAAK,KAAK,2BAA2B;AAC1C,WAAK,MAAM,KAAK,yBAAyB;AAAA,IAC3C,OAAO;AACL,WAAK,KAAK;AACV,WAAK,MAAM,KAAK,cAAc;AAAA,IAChC;AACA,SAAK,OAAO,CAAC;AACb,SAAK,QAAQ,KAAK,yBAAyB;AAC3C,SAAK,WAAW;AAChB,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,gCAAgC,MAAM,UAAU;AAC9C,SAAK,SAAS;AACd,SAAK,KAAK,KAAK,2BAA2B;AAC1C,SAAK,OAAO,CAAC;AACb,SAAK,OAAO,CAAC;AACb,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,WAAK,SAAS;AACd,WAAK,WAAW;AAChB,WAAK,QAAQ,KAAK,6BAA6B,KAAK,YAAY,KAAK,IAAI,KAAK,CAAC;AAAA,IACjF,OAAO;AACL,WAAK,SAAS;AACd,UAAI,KAAK,IAAI,EAAE,GAAG;AAChB,aAAK,WAAW;AAAA,MAClB;AACA,WAAK,QAAQ,KAAK,yBAAyB;AAAA,IAC7C;AACA,WAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,EACvD;AAAA,EACA,6BAA6B,MAAM;AACjC,SAAK,SAAS,CAAC;AACf,SAAK,OAAO;AACZ,SAAK,iBAAiB;AACtB,SAAK,OAAO;AACZ,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,kCAAkC;AAAA,IAC/D;AACA,SAAK,OAAO,EAAE;AACd,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,OAAO,KAAK,2BAA2B,IAAI;AAChD,WAAK,KAAK,OAAO;AACjB,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,WAAO,CAAC,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AACzC,WAAK,OAAO,KAAK,KAAK,2BAA2B,KAAK,CAAC;AACvD,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,OAAO,KAAK,2BAA2B,KAAK;AAAA,IACnD;AACA,SAAK,OAAO,EAAE;AACd,SAAK,aAAa,KAAK,yBAAyB;AAChD,WAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,EACvD;AAAA,EACA,gCAAgC,MAAM,UAAU;AAC9C,UAAM,YAAY,KAAK,UAAU;AACjC,SAAK,SAAS;AACd,SAAK,QAAQ,KAAK,6BAA6B,SAAS;AACxD,WAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,EACvD;AAAA,EACA,oBAAoB;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAAG;AACD,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS;AACpB,UAAM,YAAY,KAAK,UAAU;AACjC,cAAU,iBAAiB,CAAC;AAC5B,cAAU,aAAa,CAAC;AACxB,cAAU,WAAW,CAAC;AACtB,cAAU,gBAAgB,CAAC;AAC3B,QAAI;AACJ,QAAI;AACJ,QAAI,UAAU;AACd,QAAI,cAAc,KAAK,MAAM,CAAC,GAAG;AAC/B,WAAK,OAAO,CAAC;AACb,iBAAW;AACX,cAAQ;AAAA,IACV,OAAO;AACL,WAAK,OAAO,CAAC;AACb,iBAAW;AACX,cAAQ;AAAA,IACV;AACA,cAAU,QAAQ;AAClB,WAAO,CAAC,KAAK,MAAM,QAAQ,GAAG;AAC5B,UAAI,WAAW;AACf,UAAI,gBAAgB;AACpB,UAAI,kBAAkB;AACtB,YAAM,OAAO,KAAK,UAAU;AAC5B,UAAI,cAAc,KAAK,aAAa,GAAG,GAAG;AACxC,cAAM,YAAY,KAAK,UAAU;AACjC,YAAI,UAAU,SAAS,MAAM,UAAU,SAAS,IAAI;AAClD,eAAK,KAAK;AACV,0BAAgB,KAAK,MAAM;AAC3B,wBAAc;AAAA,QAChB;AAAA,MACF;AACA,UAAI,eAAe,KAAK,aAAa,GAAG,GAAG;AACzC,cAAM,YAAY,KAAK,UAAU;AACjC,YAAI,UAAU,SAAS,MAAM,UAAU,SAAS,IAAI;AAClD,eAAK,KAAK;AACV,qBAAW;AAAA,QACb;AAAA,MACF;AACA,YAAM,WAAW,KAAK,kBAAkB;AACxC,UAAI,KAAK,IAAI,CAAC,GAAG;AACf,YAAI,iBAAiB,MAAM;AACzB,eAAK,WAAW,aAAa;AAAA,QAC/B;AACA,YAAI,KAAK,IAAI,CAAC,GAAG;AACf,cAAI,UAAU;AACZ,iBAAK,WAAW,SAAS,IAAI,KAAK;AAAA,UACpC;AACA,oBAAU,cAAc,KAAK,KAAK,gCAAgC,MAAM,QAAQ,CAAC;AAAA,QACnF,OAAO;AACL,oBAAU,SAAS,KAAK,KAAK,2BAA2B,MAAM,UAAU,QAAQ,CAAC;AAAA,QACnF;AAAA,MACF,WAAW,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AAC3C,YAAI,iBAAiB,MAAM;AACzB,eAAK,WAAW,aAAa;AAAA,QAC/B;AACA,YAAI,UAAU;AACZ,eAAK,WAAW,SAAS,IAAI,KAAK;AAAA,QACpC;AACA,kBAAU,eAAe,KAAK,KAAK,gCAAgC,MAAM,QAAQ,CAAC;AAAA,MACpF,OAAO;AACL,YAAI,OAAO;AACX,YAAI,KAAK,aAAa,EAAE,KAAK,KAAK,aAAa,GAAG,GAAG;AACnD,gBAAM,YAAY,KAAK,UAAU;AACjC,cAAI,2BAA2B,UAAU,IAAI,GAAG;AAC9C,mBAAO,KAAK,MAAM;AAClB,iBAAK,KAAK;AAAA,UACZ;AAAA,QACF;AACA,cAAM,gBAAgB,KAAK,4BAA4B,MAAM,UAAU,eAAe,UAAU,MAAM,aAAa,gBAAgB,OAAO,eAAe,CAAC,KAAK;AAC/J,YAAI,kBAAkB,MAAM;AAC1B,oBAAU;AACV,4BAAkB,KAAK,MAAM;AAAA,QAC/B,OAAO;AACL,oBAAU,WAAW,KAAK,aAAa;AAAA,QACzC;AAAA,MACF;AACA,WAAK,wBAAwB;AAC7B,UAAI,mBAAmB,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,KAAK,MAAM,CAAC,GAAG;AACvD,aAAK,MAAM,WAAW,mCAAmC,eAAe;AAAA,MAC1E;AAAA,IACF;AACA,SAAK,OAAO,QAAQ;AACpB,QAAI,aAAa;AACf,gBAAU,UAAU;AAAA,IACtB;AACA,UAAM,MAAM,KAAK,WAAW,WAAW,sBAAsB;AAC7D,SAAK,MAAM,SAAS;AACpB,WAAO;AAAA,EACT;AAAA,EACA,4BAA4B,MAAM,UAAU,eAAe,UAAU,MAAM,aAAa,cAAc;AACpG,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,iBAAiB,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC;AACxF,UAAI,gBAAgB;AAClB,YAAI,CAAC,aAAa;AAChB,eAAK,MAAM,WAAW,wBAAwB,KAAK,MAAM,eAAe;AAAA,QAC1E,WAAW,CAAC,cAAc;AACxB,eAAK,MAAM,WAAW,oBAAoB,KAAK,MAAM,eAAe;AAAA,QACtE;AACA,YAAI,UAAU;AACZ,eAAK,MAAM,WAAW,iBAAiB,QAAQ;AAAA,QACjD;AACA,eAAO;AAAA,MACT;AACA,UAAI,CAAC,aAAa;AAChB,aAAK,MAAM,WAAW,sBAAsB,KAAK,MAAM,eAAe;AAAA,MACxE;AACA,UAAI,iBAAiB,MAAM;AACzB,aAAK,WAAW,aAAa;AAAA,MAC/B;AACA,UAAI,UAAU;AACZ,aAAK,MAAM,WAAW,gBAAgB,QAAQ;AAAA,MAChD;AACA,WAAK,WAAW,KAAK,cAAc;AACnC,aAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,IACzD,OAAO;AACL,WAAK,MAAM,KAAK,2BAA2B;AAC3C,WAAK,SAAS;AACd,WAAK,QAAQ,iBAAiB;AAC9B,WAAK,OAAO;AACZ,UAAI,WAAW;AACf,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,aAAK,SAAS;AACd,YAAI,iBAAiB,MAAM;AACzB,eAAK,WAAW,aAAa;AAAA,QAC/B;AACA,YAAI,UAAU;AACZ,eAAK,WAAW,SAAS,IAAI,KAAK;AAAA,QACpC;AACA,aAAK,QAAQ,KAAK,6BAA6B,KAAK,YAAY,KAAK,IAAI,KAAK,CAAC;AAC/E,YAAI,SAAS,SAAS,SAAS,OAAO;AACpC,eAAK,4BAA4B,IAAI;AAAA,QACvC;AACA,YAAI,CAAC,eAAe,KAAK,IAAI,SAAS,iBAAiB,KAAK,MAAM,MAAM;AACtE,eAAK,MAAM,WAAW,8BAA8B,KAAK,MAAM,IAAI;AAAA,QACrE;AAAA,MACF,OAAO;AACL,YAAI,SAAS;AAAQ,eAAK,WAAW;AACrC,aAAK,SAAS;AACd,YAAI,KAAK,IAAI,EAAE,GAAG;AAChB,qBAAW;AAAA,QACb;AACA,aAAK,QAAQ,KAAK,yBAAyB;AAC3C,aAAK,WAAW;AAAA,MAClB;AACA,WAAK,WAAW;AAChB,aAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,IACnD;AAAA,EACF;AAAA,EACA,4BAA4B,UAAU;AACpC,UAAM,aAAa,SAAS,SAAS,QAAQ,IAAI;AACjD,UAAM,SAAS,SAAS,MAAM,OAAO,UAAU,SAAS,MAAM,OAAO,IAAI;AACzE,QAAI,SAAS,MAAM,MAAM;AACvB,WAAK,MAAM,SAAS,SAAS,QAAQ,WAAW,4BAA4B,WAAW,2BAA2B,SAAS,MAAM,IAAI;AAAA,IACvI;AACA,QAAI,WAAW,YAAY;AACzB,WAAK,MAAM,SAAS,SAAS,QAAQ,OAAO,iBAAiB,OAAO,gBAAgB,QAAQ;AAAA,IAC9F;AACA,QAAI,SAAS,SAAS,SAAS,SAAS,MAAM,MAAM;AAClD,WAAK,MAAM,OAAO,wBAAwB,QAAQ;AAAA,IACpD;AAAA,EACF;AAAA,EACA,0BAA0B;AACxB,QAAI,CAAC,KAAK,IAAI,EAAE,KAAK,CAAC,KAAK,IAAI,EAAE,KAAK,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,KAAK,MAAM,CAAC,GAAG;AACtE,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,iCAAiC,UAAU,IAAI;AAC7C,QAAI;AACJ,KAAC,YAAY,aAAa,OAAO,YAAY,WAAW,KAAK,MAAM;AACnE,QAAI,OAAO,MAAM,KAAK,8BAA8B,IAAI;AACxD,WAAO,KAAK,IAAI,EAAE,GAAG;AACnB,YAAM,QAAQ,KAAK,YAAY,QAAQ;AACvC,YAAM,gBAAgB;AACtB,YAAM,KAAK,KAAK,8BAA8B,IAAI;AAClD,aAAO,KAAK,WAAW,OAAO,yBAAyB;AAAA,IACzD;AACA,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB,UAAU,IAAI;AACjC,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,iBAAiB;AACtB,SAAK,KAAK,KAAK,iCAAiC,UAAU,EAAE;AAC5D,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,oCAAoC;AAAA,IACjE;AACA,WAAO,KAAK,WAAW,MAAM,uBAAuB;AAAA,EACtD;AAAA,EACA,sBAAsB;AACpB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,EAAE;AACd,SAAK,WAAW,KAAK,qBAAqB;AAC1C,WAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,EACrD;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,QAAQ,CAAC;AACd,SAAK,OAAO,CAAC;AACb,WAAO,KAAK,MAAM,MAAM,KAAK,UAAU,CAAC,KAAK,MAAM,CAAC,GAAG;AACrD,WAAK,MAAM,KAAK,KAAK,cAAc,CAAC;AACpC,UAAI,KAAK,MAAM,CAAC;AAAG;AACnB,WAAK,OAAO,EAAE;AAAA,IAChB;AACA,SAAK,OAAO,CAAC;AACb,WAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACpD;AAAA,EACA,2BAA2B,OAAO;AAChC,QAAI,OAAO;AACX,QAAI,WAAW;AACf,QAAI,iBAAiB;AACrB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,KAAK,KAAK,UAAU;AAC1B,UAAM,SAAS,KAAK,MAAM,SAAS;AACnC,QAAI,GAAG,SAAS,MAAM,GAAG,SAAS,IAAI;AACpC,UAAI,UAAU,CAAC,OAAO;AACpB,aAAK,MAAM,WAAW,sBAAsB,IAAI;AAAA,MAClD;AACA,aAAO,KAAK,gBAAgB,MAAM;AAClC,UAAI,KAAK,IAAI,EAAE,GAAG;AAChB,mBAAW;AACX,YAAI,QAAQ;AACV,eAAK,MAAM,WAAW,2BAA2B,IAAI;AAAA,QACvD;AAAA,MACF;AACA,uBAAiB,KAAK,yBAAyB;AAAA,IACjD,OAAO;AACL,uBAAiB,KAAK,cAAc;AAAA,IACtC;AACA,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,iBAAiB;AACtB,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,mCAAmC,MAAM;AACvC,UAAM,OAAO,KAAK,YAAY,KAAK,IAAI,KAAK;AAC5C,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,iBAAiB;AACtB,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,4BAA4B,SAAS,CAAC,GAAG;AACvC,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,cAAQ,KAAK,2BAA2B,IAAI;AAC5C,YAAM,OAAO;AACb,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,WAAO,CAAC,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AACzC,aAAO,KAAK,KAAK,2BAA2B,KAAK,CAAC;AAClD,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,aAAO,KAAK,2BAA2B,KAAK;AAAA,IAC9C;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,0BAA0B,UAAU,MAAM,IAAI;AAC5C,YAAQ,GAAG,MAAM;AAAA,MACf,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,MAClD,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,uBAAuB;AAAA,MACtD,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,MACpD,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,MACpD,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,MACrD,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,MACrD,KAAK;AACH,eAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,MACrD;AACE,aAAK,mBAAmB,GAAG,IAAI;AAC/B,eAAO,KAAK,qBAAqB,UAAU,EAAE;AAAA,IACjD;AAAA,EACF;AAAA,EACA,uBAAuB;AACrB,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI;AACJ,QAAI;AACJ,QAAI,gBAAgB;AACpB,UAAM,wBAAwB,KAAK,MAAM;AACzC,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK;AACH,eAAO,KAAK,oBAAoB;AAAA,UAC9B,aAAa;AAAA,UACb,YAAY;AAAA,UACZ,aAAa;AAAA,UACb,YAAY;AAAA,UACZ,cAAc;AAAA,QAChB,CAAC;AAAA,MACH,KAAK;AACH,eAAO,KAAK,oBAAoB;AAAA,UAC9B,aAAa;AAAA,UACb,YAAY;AAAA,UACZ,aAAa;AAAA,UACb,YAAY;AAAA,UACZ,cAAc;AAAA,QAChB,CAAC;AAAA,MACH,KAAK;AACH,aAAK,MAAM,qBAAqB;AAChC,eAAO,KAAK,mBAAmB;AAC/B,aAAK,MAAM,qBAAqB;AAChC,eAAO;AAAA,MACT,KAAK;AACH,aAAK,iBAAiB,KAAK,kCAAkC;AAC7D,aAAK,OAAO,EAAE;AACd,cAAM,KAAK,4BAA4B;AACvC,aAAK,SAAS,IAAI;AAClB,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,EAAE;AACd,aAAK,OAAO,EAAE;AACd,aAAK,aAAa,KAAK,cAAc;AACrC,eAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,MACvD,KAAK;AACH,aAAK,KAAK;AACV,YAAI,CAAC,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AACtC,cAAI,kBAAkB,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,EAAE,GAAG;AACxD,kBAAM,QAAQ,KAAK,UAAU,EAAE;AAC/B,4BAAgB,UAAU,MAAM,UAAU;AAAA,UAC5C,OAAO;AACL,4BAAgB;AAAA,UAClB;AAAA,QACF;AACA,YAAI,eAAe;AACjB,eAAK,MAAM,qBAAqB;AAChC,iBAAO,KAAK,cAAc;AAC1B,eAAK,MAAM,qBAAqB;AAChC,cAAI,KAAK,MAAM,sBAAsB,EAAE,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,UAAU,EAAE,SAAS,KAAK;AACxG,iBAAK,OAAO,EAAE;AACd,mBAAO;AAAA,UACT,OAAO;AACL,iBAAK,IAAI,EAAE;AAAA,UACb;AAAA,QACF;AACA,YAAI,MAAM;AACR,gBAAM,KAAK,4BAA4B,CAAC,KAAK,mCAAmC,IAAI,CAAC,CAAC;AAAA,QACxF,OAAO;AACL,gBAAM,KAAK,4BAA4B;AAAA,QACzC;AACA,aAAK,SAAS,IAAI;AAClB,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,EAAE;AACd,aAAK,OAAO,EAAE;AACd,aAAK,aAAa,KAAK,cAAc;AACrC,aAAK,iBAAiB;AACtB,eAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,MACvD,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,MAAM,OAAO,6BAA6B;AAAA,MAC1E,KAAK;AAAA,MACL,KAAK;AACH,aAAK,QAAQ,KAAK,MAAM,EAAE;AAC1B,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,8BAA8B;AAAA,MAC7D,KAAK;AACH,YAAI,KAAK,MAAM,UAAU,KAAK;AAC5B,eAAK,KAAK;AACV,cAAI,KAAK,MAAM,GAAG,GAAG;AACnB,mBAAO,KAAK,mBAAmB,CAAC,KAAK,MAAM,OAAO,+BAA+B,IAAI;AAAA,UACvF;AACA,cAAI,KAAK,MAAM,GAAG,GAAG;AACnB,mBAAO,KAAK,mBAAmB,CAAC,KAAK,MAAM,OAAO,+BAA+B,IAAI;AAAA,UACvF;AACA,gBAAM,KAAK,MAAM,WAAW,8BAA8B,KAAK,MAAM,QAAQ;AAAA,QAC/E;AACA,aAAK,WAAW;AAChB;AAAA,MACF,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,MAAM,OAAO,6BAA6B;AAAA,MAC1E,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,MAAM,OAAO,6BAA6B;AAAA,MAC1E,KAAK;AACH,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,MACnD,KAAK;AACH,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,2BAA2B;AAAA,MAC1D,KAAK;AACH,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,MACnD,KAAK;AACH,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,MACrD,KAAK;AACH,eAAO,KAAK,oBAAoB;AAAA,MAClC;AACE,YAAI,eAAe,KAAK,MAAM,IAAI,GAAG;AACnC,gBAAM,QAAQ,eAAe,KAAK,MAAM,IAAI;AAC5C,eAAK,KAAK;AACV,iBAAO,MAAM,iBAAiB,MAAM,KAAK;AAAA,QAC3C,WAAW,kBAAkB,KAAK,MAAM,IAAI,GAAG;AAC7C,cAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,mBAAO,KAAK,uBAAuB;AAAA,UACrC;AACA,iBAAO,KAAK,0BAA0B,UAAU,MAAM,KAAK,gBAAgB,CAAC;AAAA,QAC9E;AAAA,IACJ;AACA,SAAK,WAAW;AAAA,EAClB;AAAA,EACA,uBAAuB;AACrB,UAAM,WAAW,KAAK,MAAM;AAC5B,QAAI,OAAO,KAAK,qBAAqB;AACrC,QAAI,4BAA4B;AAChC,YAAQ,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,EAAE,MAAM,CAAC,KAAK,mBAAmB,GAAG;AACtE,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,YAAM,WAAW,KAAK,IAAI,EAAE;AAC5B,kCAA4B,6BAA6B;AACzD,WAAK,OAAO,CAAC;AACb,UAAI,CAAC,YAAY,KAAK,MAAM,CAAC,GAAG;AAC9B,aAAK,cAAc;AACnB,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,MACpD,OAAO;AACL,aAAK,aAAa;AAClB,aAAK,YAAY,KAAK,cAAc;AACpC,aAAK,OAAO,CAAC;AACb,YAAI,2BAA2B;AAC7B,eAAK,WAAW;AAChB,iBAAO,KAAK,WAAW,MAAM,2BAA2B;AAAA,QAC1D,OAAO;AACL,iBAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB;AACpB,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,iBAAiB,KAAK,oBAAoB;AAC/C,aAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,IACvD,OAAO;AACL,aAAO,KAAK,qBAAqB;AAAA,IACnC;AAAA,EACF;AAAA,EACA,qCAAqC;AACnC,UAAM,QAAQ,KAAK,oBAAoB;AACvC,QAAI,CAAC,KAAK,MAAM,sBAAsB,KAAK,IAAI,EAAE,GAAG;AAClD,YAAM,OAAO,KAAK,YAAY,MAAM,IAAI,KAAK;AAC7C,WAAK,SAAS,CAAC,KAAK,mCAAmC,KAAK,CAAC;AAC7D,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ,WAAK,aAAa,KAAK,cAAc;AACrC,WAAK,iBAAiB;AACtB,aAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,IACvD;AACA,WAAO;AAAA,EACT;AAAA,EACA,4BAA4B;AAC1B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,IAAI,EAAE;AACX,UAAM,OAAO,KAAK,mCAAmC;AACrD,SAAK,QAAQ,CAAC,IAAI;AAClB,WAAO,KAAK,IAAI,EAAE,GAAG;AACnB,WAAK,MAAM,KAAK,KAAK,mCAAmC,CAAC;AAAA,IAC3D;AACA,WAAO,KAAK,MAAM,WAAW,IAAI,OAAO,KAAK,WAAW,MAAM,4BAA4B;AAAA,EAC5F;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,IAAI,EAAE;AACX,UAAM,OAAO,KAAK,0BAA0B;AAC5C,SAAK,QAAQ,CAAC,IAAI;AAClB,WAAO,KAAK,IAAI,EAAE,GAAG;AACnB,WAAK,MAAM,KAAK,KAAK,0BAA0B,CAAC;AAAA,IAClD;AACA,WAAO,KAAK,MAAM,WAAW,IAAI,OAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACrF;AAAA,EACA,gBAAgB;AACd,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS;AACpB,UAAM,OAAO,KAAK,mBAAmB;AACrC,SAAK,MAAM,SAAS;AACpB,WAAO;AAAA,EACT;AAAA,EACA,uCAAuC;AACrC,QAAI,KAAK,MAAM,SAAS,OAAO,KAAK,MAAM,UAAU,KAAK;AACvD,YAAM,WAAW,KAAK,MAAM;AAC5B,YAAM,OAAO,KAAK,gBAAgB;AAClC,aAAO,KAAK,qBAAqB,UAAU,IAAI;AAAA,IACjD,OAAO;AACL,aAAO,KAAK,cAAc;AAAA,IAC5B;AAAA,EACF;AAAA,EACA,0BAA0B;AACxB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,iBAAiB,KAAK,yBAAyB;AACpD,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,mCAAmC,wBAAwB;AACzD,UAAM,QAAQ,yBAAyB,KAAK,gBAAgB,IAAI,KAAK,8BAA8B;AACnG,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,iBAAiB,KAAK,wBAAwB;AACpD,WAAK,iBAAiB,KAAK;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA,EACA,oBAAoB,MAAM;AACxB,SAAK,WAAW,iBAAiB,KAAK;AACtC,SAAK,iBAAiB,KAAK,YAAY,KAAK,eAAe,IAAI,GAAG;AAClE,WAAO,KAAK;AAAA,EACd;AAAA,EACA,oBAAoB;AAClB,QAAI,WAAW;AACf,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,iBAAW,KAAK,UAAU;AAC1B,UAAI,KAAK,MAAM,UAAU,KAAK;AAC5B,iBAAS,OAAO;AAAA,MAClB,OAAO;AACL,iBAAS,OAAO;AAAA,MAClB;AACA,WAAK,KAAK;AACV,aAAO,KAAK,WAAW,UAAU,UAAU;AAAA,IAC7C;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,MAAM,qBAAqB,WAAW,OAAO;AAC7D,QAAI,qBAAqB;AACvB,WAAK,iCAAiC,MAAM,MAAM,MAAM,kBAAkB,MAAM,MAAM,QAAQ,CAAC;AAC/F;AAAA,IACF;AACA,UAAM,kBAAkB,MAAM,OAAO,QAAQ;AAAA,EAC/C;AAAA,EACA,2BAA2B,MAAM,MAAM,WAAW,OAAO;AACvD,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,WAAW,KAAK,UAAU;AAChC,OAAC,SAAS,gBAAgB,KAAK,SAAS,IAAI,KAAK,qCAAqC;AACtF,WAAK,aAAa,SAAS,iBAAiB,KAAK,WAAW,UAAU,gBAAgB,IAAI;AAAA,IAC5F;AACA,WAAO,MAAM,2BAA2B,MAAM,MAAM,QAAQ;AAAA,EAC9D;AAAA,EACA,mBAAmB,OAAO;AACxB,QAAI,KAAK,MAAM,UAAU,KAAK,aAAa,GAAG,GAAG;AAC/C,YAAM,YAAY,KAAK,UAAU;AACjC,UAAI,2BAA2B,UAAU,IAAI,GAAG;AAC9C,cAAM,OAAO,KAAK,UAAU;AAC5B,aAAK,KAAK;AACV,eAAO,KAAK,mBAAmB,IAAI;AAAA,MACrC;AAAA,IACF,WAAW,KAAK,iBAAiB,KAAK,KAAK,aAAa,GAAG,GAAG;AAC5D,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,KAAK;AACV,aAAO,KAAK,yBAAyB,IAAI;AAAA,IAC3C;AACA,UAAM,OAAO,MAAM,mBAAmB,KAAK;AAC3C,QAAI,KAAK,eAAe,UAAa,CAAC,KAAK,iBAAiB,IAAI,GAAG;AACjE,WAAK,aAAa;AAAA,IACpB;AACA,WAAO;AAAA,EACT;AAAA,EACA,yBAAyB,MAAM,MAAM,YAAY;AAC/C,QAAI,KAAK,SAAS,cAAc;AAC9B,UAAI,KAAK,SAAS,WAAW;AAC3B,YAAI,KAAK,MAAM,EAAE,KAAK,kBAAkB,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AAC9G,iBAAO,KAAK,iBAAiB,IAAI;AAAA,QACnC;AAAA,MACF,WAAW,kBAAkB,KAAK,MAAM,IAAI,GAAG;AAC7C,YAAI,KAAK,SAAS,aAAa;AAC7B,iBAAO,KAAK,mBAAmB,IAAI;AAAA,QACrC,WAAW,KAAK,SAAS,QAAQ;AAC/B,iBAAO,KAAK,mBAAmB,IAAI;AAAA,QACrC,WAAW,KAAK,SAAS,UAAU;AACjC,iBAAO,KAAK,oBAAoB,MAAM,KAAK;AAAA,QAC7C;AAAA,MACF;AAAA,IACF;AACA,WAAO,MAAM,yBAAyB,MAAM,MAAM,UAAU;AAAA,EAC9D;AAAA,EACA,+BAA+B;AAC7B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,mCAAmC,IAAI,KAAK,KAAK,iBAAiB,KAAK,SAAS,KAAK;AACvF,aAAO,CAAC,KAAK,MAAM;AAAA,IACrB;AACA,WAAO,MAAM,6BAA6B;AAAA,EAC5C;AAAA,EACA,2BAA2B;AACzB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,mCAAmC,IAAI,KAAK,KAAK,iBAAiB,KAAK,SAAS,KAAK;AACvF,aAAO,KAAK,MAAM;AAAA,IACpB;AACA,WAAO,MAAM,yBAAyB;AAAA,EACxC;AAAA,EACA,+BAA+B;AAC7B,QAAI,KAAK,iBAAiB,KAAK,KAAK,aAAa,GAAG,GAAG;AACrD,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,KAAK;AACV,aAAO,KAAK,yBAAyB,IAAI;AAAA,IAC3C;AACA,WAAO,MAAM,6BAA6B;AAAA,EAC5C;AAAA,EACA,iBAAiB,MAAM,UAAU,qBAAqB;AACpD,QAAI,CAAC,KAAK,MAAM,EAAE;AAAG,aAAO;AAC5B,QAAI,KAAK,MAAM,wBAAwB;AACrC,YAAM,SAAS,KAAK,kBAAkB;AACtC,UAAI,WAAW,MAAM,WAAW,MAAM,WAAW,MAAM,WAAW,IAAI;AACpE,aAAK,2BAA2B,mBAAmB;AACnD,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,OAAO,EAAE;AACd,UAAM,QAAQ,KAAK,MAAM,MAAM;AAC/B,UAAM,oBAAoB,KAAK,MAAM;AACrC,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,QAAI;AAAA,MACF;AAAA,MACA;AAAA,IACF,IAAI,KAAK,8BAA8B;AACvC,QAAI,CAAC,OAAO,OAAO,IAAI,KAAK,wBAAwB,UAAU;AAC9D,QAAI,UAAU,QAAQ,SAAS,GAAG;AAChC,YAAM,YAAY,CAAC,GAAG,iBAAiB;AACvC,UAAI,QAAQ,SAAS,GAAG;AACtB,aAAK,QAAQ;AACb,aAAK,MAAM,YAAY;AACvB,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,oBAAU,KAAK,QAAQ,CAAC,EAAE,KAAK;AAAA,QACjC;AACA,SAAC;AAAA,UACC;AAAA,UACA;AAAA,QACF,IAAI,KAAK,8BAA8B;AACvC,SAAC,OAAO,OAAO,IAAI,KAAK,wBAAwB,UAAU;AAAA,MAC5D;AACA,UAAI,UAAU,MAAM,SAAS,GAAG;AAC9B,aAAK,MAAM,WAAW,2BAA2B,MAAM,QAAQ;AAAA,MACjE;AACA,UAAI,UAAU,MAAM,WAAW,GAAG;AAChC,aAAK,QAAQ;AACb,kBAAU,KAAK,MAAM,CAAC,EAAE,KAAK;AAC7B,aAAK,MAAM,YAAY;AACvB,SAAC;AAAA,UACC;AAAA,UACA;AAAA,QACF,IAAI,KAAK,8BAA8B;AAAA,MACzC;AAAA,IACF;AACA,SAAK,wBAAwB,YAAY,IAAI;AAC7C,SAAK,MAAM,YAAY;AACvB,SAAK,OAAO,EAAE;AACd,SAAK,OAAO;AACZ,SAAK,aAAa;AAClB,SAAK,YAAY,KAAK,iCAAiC,MAAM,MAAM,KAAK,iBAAiB,QAAW,MAAS,CAAC;AAC9G,WAAO,KAAK,WAAW,MAAM,uBAAuB;AAAA,EACtD;AAAA,EACA,gCAAgC;AAC9B,SAAK,MAAM,0BAA0B,KAAK,KAAK,MAAM,KAAK;AAC1D,UAAM,aAAa,KAAK,wBAAwB;AAChD,UAAM,SAAS,CAAC,KAAK,MAAM,EAAE;AAC7B,SAAK,MAAM,0BAA0B,IAAI;AACzC,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,wBAAwB,MAAM,iBAAiB;AAC7C,UAAM,QAAQ,CAAC,IAAI;AACnB,UAAM,SAAS,CAAC;AAChB,WAAO,MAAM,WAAW,GAAG;AACzB,YAAMF,QAAO,MAAM,IAAI;AACvB,UAAIA,MAAK,SAAS,2BAA2B;AAC3C,YAAIA,MAAK,kBAAkB,CAACA,MAAK,YAAY;AAC3C,eAAK,sBAAsBA,KAAI;AAAA,QACjC,OAAO;AACL,iBAAO,KAAKA,KAAI;AAAA,QAClB;AACA,cAAM,KAAKA,MAAK,IAAI;AAAA,MACtB,WAAWA,MAAK,SAAS,yBAAyB;AAChD,cAAM,KAAKA,MAAK,UAAU;AAC1B,cAAM,KAAKA,MAAK,SAAS;AAAA,MAC3B;AAAA,IACF;AACA,QAAI,iBAAiB;AACnB,aAAO,QAAQ,CAAAA,UAAQ,KAAK,sBAAsBA,KAAI,CAAC;AACvD,aAAO,CAAC,QAAQ,CAAC,CAAC;AAAA,IACpB;AACA,WAAO,UAAU,QAAQ,CAAAA,UAAQA,MAAK,OAAO,MAAM,WAAS,KAAK,aAAa,OAAO,IAAI,CAAC,CAAC;AAAA,EAC7F;AAAA,EACA,sBAAsB,MAAM;AAC1B,QAAI;AACJ,SAAK,iBAAiB,KAAK,SAAS,cAAc,KAAK,UAAU,OAAO,SAAS,YAAY,kBAAkB,KAAK;AACpH,SAAK,MAAM,MAAM,IAAI,CAAC;AACtB,UAAM,YAAY,MAAM,OAAO,IAAI;AACnC,SAAK,MAAM,KAAK;AAAA,EAClB;AAAA,EACA,iCAAiC,MAAMG,QAAO;AAC5C,QAAI;AACJ,QAAI,KAAK,MAAM,0BAA0B,QAAQ,KAAK,KAAK,MAAM,IAAI;AACnE,WAAK,MAAM,0BAA0B,KAAK,KAAK,MAAM,KAAK;AAC1D,eAASA,OAAM;AACf,WAAK,MAAM,0BAA0B,IAAI;AAAA,IAC3C,OAAO;AACL,eAASA,OAAM;AAAA,IACjB;AACA,WAAO;AAAA,EACT;AAAA,EACA,eAAe,MAAM,UAAU;AAC7B,WAAO,MAAM,eAAe,MAAM,QAAQ;AAC1C,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,WAAW;AAChB,WAAK,iBAAiB,IAAI;AAAA,IAC5B;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,eAAe,KAAK,YAAY,QAAQ;AAC9C,mBAAa,aAAa;AAC1B,mBAAa,iBAAiB,KAAK,wBAAwB;AAC3D,aAAO,KAAK,WAAW,cAAc,oBAAoB;AAAA,IAC3D;AACA,WAAO;AAAA,EACT;AAAA,EACA,wBAAwB,MAAM;AAC5B,QAAI,KAAK,SAAS,wBAAwB,KAAK,eAAe,UAAU,KAAK,eAAe,aAAa,KAAK,SAAS,4BAA4B,KAAK,eAAe,UAAU,KAAK,SAAS,0BAA0B,KAAK,eAAe,QAAQ;AACnP;AAAA,IACF;AACA,UAAM,wBAAwB,IAAI;AAAA,EACpC;AAAA,EACA,uBAAuB,MAAM;AAC3B,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,WAAK,aAAa;AAClB,YAAM,kBAAkB,KAAK,UAAU;AACvC,WAAK,KAAK;AACV,UAAI,KAAK,MAAM,CAAC,GAAG;AACjB,aAAK,aAAa,KAAK,sBAAsB,IAAI;AACjD,cAAM,gBAAgB,IAAI;AAC1B,eAAO;AAAA,MACT,OAAO;AACL,eAAO,KAAK,mBAAmB,eAAe;AAAA,MAChD;AAAA,IACF,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,WAAK,aAAa;AAClB,YAAM,kBAAkB,KAAK,UAAU;AACvC,WAAK,KAAK;AACV,aAAO,KAAK,oBAAoB,iBAAiB,KAAK;AAAA,IACxD,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,WAAK,aAAa;AAClB,YAAM,kBAAkB,KAAK,UAAU;AACvC,WAAK,KAAK;AACV,aAAO,KAAK,mBAAmB,eAAe;AAAA,IAChD,WAAW,KAAK,iBAAiB,KAAK,KAAK,aAAa,GAAG,GAAG;AAC5D,WAAK,aAAa;AAClB,YAAM,kBAAkB,KAAK,UAAU;AACvC,WAAK,KAAK;AACV,aAAO,KAAK,yBAAyB,eAAe;AAAA,IACtD,OAAO;AACL,aAAO,MAAM,uBAAuB,IAAI;AAAA,IAC1C;AAAA,EACF;AAAA,EACA,cAAc,MAAM;AAClB,QAAI,MAAM,cAAc,IAAI;AAAG,aAAO;AACtC,QAAI,KAAK,aAAa,GAAG,KAAK,KAAK,UAAU,EAAE,SAAS,IAAI;AAC1D,WAAK,aAAa;AAClB,WAAK,KAAK;AACV,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,mCAAmC,MAAM;AACvC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,eAAe,MAAM,mCAAmC,IAAI;AAClE,QAAI,gBAAgB,KAAK,eAAe,QAAQ;AAC9C,WAAK,WAAW,QAAQ;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AAAA,EACA,aAAa,MAAM,aAAa,YAAY;AAC1C,UAAM,aAAa,MAAM,aAAa,UAAU;AAChD,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,kCAAkC;AAAA,IAC/D;AAAA,EACF;AAAA,EACA,iBAAiB,WAAW,QAAQ,OAAO;AACzC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,UAAI,MAAM,6BAA6B,WAAW,MAAM,GAAG;AACzD;AAAA,MACF;AACA,aAAO,UAAU;AAAA,IACnB;AACA,UAAM,iBAAiB,WAAW,QAAQ,KAAK;AAC/C,QAAI,OAAO,SAAS;AAClB,UAAI,OAAO,SAAS,mBAAmB,OAAO,SAAS,0BAA0B,OAAO,SAAS,sBAAsB;AACrH,aAAK,MAAM,WAAW,qBAAqB,QAAQ;AAAA,MACrD,WAAW,OAAO,OAAO;AACvB,aAAK,MAAM,WAAW,8BAA8B,OAAO,KAAK;AAAA,MAClE;AAAA,IACF;AAAA,EACF;AAAA,EACA,WAAW,MAAM;AACf,WAAO,SAAS,cAAc,SAAS;AAAA,EACzC;AAAA,EACA,eAAe;AACb,UAAM,OAAO,MAAM,UAAU;AAC7B,UAAM,WAAW,OAAO;AACxB,QAAI,CAAC,KAAK,WAAW,IAAI,KAAK,CAAC,KAAK,MAAM,QAAQ;AAChD,WAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,YAAY,GAAG;AAAA,QAC7D,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AACA,SAAK,YAAY,KAAK,QAAQ;AAAA,EAChC;AAAA,EACA,iBAAiBL,OAAM;AACrB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAIA,UAAS,OAAO,SAAS,KAAK;AAChC,WAAK,SAAS,GAAG,CAAC;AAAA,IACpB,WAAW,KAAK,MAAM,WAAWA,UAAS,MAAMA,UAAS,KAAK;AAC5D,WAAK,SAASA,UAAS,KAAK,KAAK,IAAI,CAAC;AAAA,IACxC,WAAW,KAAK,MAAM,UAAUA,UAAS,IAAI;AAC3C,UAAI,SAAS,IAAI;AACf,aAAK,SAAS,IAAI,CAAC;AAAA,MACrB,OAAO;AACL,aAAK,SAAS,IAAI,CAAC;AAAA,MACrB;AAAA,IACF,WAAW,gBAAgBA,OAAM,MAAM,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,CAAC,GAAG;AACjF,WAAK,MAAM,OAAO;AAClB,WAAK,aAAa;AAAA,IACpB,OAAO;AACL,YAAM,iBAAiBA,KAAI;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,aAAa,MAAM,WAAW;AAC5B,QAAI,KAAK,SAAS,sBAAsB;AACtC,aAAO,KAAK,aAAa,KAAK,YAAY,SAAS;AAAA,IACrD,OAAO;AACL,aAAO,MAAM,aAAa,MAAM,SAAS;AAAA,IAC3C;AAAA,EACF;AAAA,EACA,aAAa,MAAM,QAAQ,OAAO;AAChC,QAAI,CAAC,SAAS,KAAK,SAAS,0BAA0B,KAAK,KAAK,SAAS,sBAAsB;AAC7F,WAAK,OAAO,KAAK,oBAAoB,KAAK,IAAI;AAAA,IAChD;AACA,UAAM,aAAa,MAAM,KAAK;AAAA,EAChC;AAAA,EACA,iBAAiB,UAAU,kBAAkB,OAAO;AAClD,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,OAAO,SAAS,CAAC;AACvB,WAAK,QAAQ,OAAO,SAAS,KAAK,UAAU,sBAAsB;AAChE,iBAAS,CAAC,IAAI,KAAK,oBAAoB,IAAI;AAAA,MAC7C;AAAA,IACF;AACA,UAAM,iBAAiB,UAAU,kBAAkB,KAAK;AAAA,EAC1D;AAAA,EACA,iBAAiB,UAAU,qBAAqB;AAC9C,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,UAAI;AACJ,YAAM,OAAO,SAAS,CAAC;AACvB,UAAI,QAAQ,KAAK,SAAS,wBAAwB,GAAG,cAAc,KAAK,UAAU,QAAQ,YAAY,mBAAmB,SAAS,SAAS,KAAK,CAAC,sBAAsB;AACrK,aAAK,MAAM,WAAW,mBAAmB,KAAK,cAAc;AAAA,MAC9D;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,eAAe,OAAO,cAAc,SAAS,qBAAqB;AAChE,UAAM,OAAO,MAAM,eAAe,OAAO,cAAc,SAAS,mBAAmB;AACnF,QAAI,gBAAgB,CAAC,KAAK,MAAM,wBAAwB;AACtD,WAAK,iBAAiB,KAAK,QAAQ;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM,iBAAiB,SAAS;AAC1C,WAAO,SAAS,wBAAwB,MAAM,YAAY,MAAM,iBAAiB,OAAO;AAAA,EAC1F;AAAA,EACA,mBAAmB,MAAM;AACvB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,wBAAwB;AAAA,IACrD;AACA,WAAO,MAAM,mBAAmB,IAAI;AAAA,EACtC;AAAA,EACA,0BAA0B,MAAM;AAC9B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,wBAAwB;AAAA,IACrD;AACA,WAAO,MAAM,0BAA0B,IAAI;AAAA,EAC7C;AAAA,EACA,gBAAgB;AACd,WAAO,KAAK,MAAM,EAAE,KAAK,MAAM,cAAc;AAAA,EAC/C;AAAA,EACA,kBAAkB;AAChB,WAAO,KAAK,MAAM,EAAE,KAAK,MAAM,gBAAgB;AAAA,EACjD;AAAA,EACA,uBAAuB,QAAQ;AAC7B,WAAO,CAAC,KAAK,MAAM,EAAE,KAAK,MAAM,uBAAuB,MAAM;AAAA,EAC/D;AAAA,EACA,gBAAgB,WAAW,QAAQ,aAAa,SAAS,eAAe,mBAAmB;AACzF,QAAI,OAAO,UAAU;AACnB,WAAK,WAAW,OAAO,SAAS,IAAI,KAAK;AAAA,IAC3C;AACA,WAAO,OAAO;AACd,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,iBAAiB,KAAK,kCAAkC;AAAA,IACjE;AACA,UAAM,gBAAgB,WAAW,QAAQ,aAAa,SAAS,eAAe,iBAAiB;AAC/F,QAAI,OAAO,UAAU,eAAe;AAClC,YAAM,SAAS,OAAO;AACtB,UAAI,OAAO,SAAS,KAAK,KAAK,YAAY,OAAO,CAAC,CAAC,GAAG;AACpD,aAAK,MAAM,WAAW,8BAA8B,MAAM;AAAA,MAC5D;AAAA,IACF,WAAW,OAAO,SAAS,sBAAsB,iBAAiB,OAAO,MAAM,QAAQ;AACrF,YAAM,SAAS,OAAO,MAAM;AAC5B,UAAI,OAAO,SAAS,KAAK,KAAK,YAAY,OAAO,CAAC,CAAC,GAAG;AACpD,aAAK,MAAM,WAAW,8BAA8B,MAAM;AAAA,MAC5D;AAAA,IACF;AAAA,EACF;AAAA,EACA,uBAAuB,WAAW,QAAQ,aAAa,SAAS;AAC9D,QAAI,OAAO,UAAU;AACnB,WAAK,WAAW,OAAO,SAAS,IAAI,KAAK;AAAA,IAC3C;AACA,WAAO,OAAO;AACd,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,iBAAiB,KAAK,kCAAkC;AAAA,IACjE;AACA,UAAM,uBAAuB,WAAW,QAAQ,aAAa,OAAO;AAAA,EACtE;AAAA,EACA,gBAAgB,MAAM;AACpB,UAAM,gBAAgB,IAAI;AAC1B,QAAI,KAAK,cAAc,KAAK,MAAM,EAAE,GAAG;AACrC,WAAK,sBAAsB,KAAK,oCAAoC;AAAA,IACtE;AACA,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,WAAK,KAAK;AACV,YAAM,cAAc,KAAK,aAAa,CAAC;AACvC,SAAG;AACD,cAAME,QAAO,KAAK,UAAU;AAC5B,QAAAA,MAAK,KAAK,KAAK,8BAA8B,IAAI;AACjD,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAAA,MAAK,iBAAiB,KAAK,oCAAoC;AAAA,QACjE,OAAO;AACL,UAAAA,MAAK,iBAAiB;AAAA,QACxB;AACA,oBAAY,KAAK,KAAK,WAAWA,OAAM,iBAAiB,CAAC;AAAA,MAC3D,SAAS,KAAK,IAAI,EAAE;AAAA,IACtB;AAAA,EACF;AAAA,EACA,wBAAwB,QAAQ;AAC9B,UAAM,wBAAwB,MAAM;AACpC,UAAM,SAAS,KAAK,6BAA6B,MAAM;AACvD,QAAI,OAAO,SAAS,GAAG;AACrB,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,KAAK,YAAY,KAAK,KAAK,OAAO,SAAS,OAAO;AACpD,aAAK,MAAM,WAAW,2BAA2B,KAAK;AAAA,MACxD,WAAW,KAAK,YAAY,KAAK,GAAG;AAClC,aAAK,MAAM,WAAW,2BAA2B,KAAK;AAAA,MACxD;AAAA,IACF;AAAA,EACF;AAAA,EACA,gCAAgC,MAAM;AACpC,SAAK,WAAW,KAAK,kBAAkB;AAAA,EACzC;AAAA,EACA,kBAAkB,MAAM,UAAU,aAAa,SAAS,WAAW,YAAY,qBAAqB;AAClG,QAAI,KAAK,UAAU;AACjB,WAAK,WAAW,KAAK,SAAS,IAAI,KAAK;AAAA,IACzC;AACA,WAAO,KAAK;AACZ,QAAI;AACJ,QAAI,KAAK,MAAM,EAAE,KAAK,CAAC,YAAY;AACjC,uBAAiB,KAAK,kCAAkC;AACxD,UAAI,CAAC,KAAK,MAAM,EAAE;AAAG,aAAK,WAAW;AAAA,IACvC;AACA,UAAM,SAAS,MAAM,kBAAkB,MAAM,UAAU,aAAa,SAAS,WAAW,YAAY,mBAAmB;AACvH,QAAI,gBAAgB;AAClB,OAAC,OAAO,SAAS,QAAQ,iBAAiB;AAAA,IAC5C;AACA,WAAO;AAAA,EACT;AAAA,EACA,6BAA6B,OAAO;AAClC,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,UAAI,MAAM,SAAS,cAAc;AAC/B,aAAK,MAAM,WAAW,mBAAmB,KAAK;AAAA,MAChD;AACA,UAAI,KAAK,YAAY,KAAK,GAAG;AAC3B,aAAK,MAAM,WAAW,2BAA2B,KAAK;AAAA,MACxD;AACA,YAAM,WAAW;AAAA,IACnB;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,iBAAiB,KAAK,wBAAwB;AAAA,IACtD,WAAW,KAAK,YAAY,KAAK,GAAG;AAClC,WAAK,MAAM,WAAW,6BAA6B,KAAK;AAAA,IAC1D;AACA,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,YAAY,KAAK,GAAG;AAC7C,WAAK,MAAM,WAAW,oBAAoB,KAAK;AAAA,IACjD;AACA,SAAK,iBAAiB,KAAK;AAC3B,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,UAAU,MAAM;AAChC,UAAM,OAAO,MAAM,kBAAkB,UAAU,IAAI;AACnD,QAAI,KAAK,SAAS,uBAAuB,KAAK,kBAAkB,KAAK,MAAM,QAAQ,KAAK,eAAe,OAAO;AAC5G,WAAK,MAAM,WAAW,uBAAuB,KAAK,cAAc;AAAA,IAClE;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,MAAM;AAC1B,UAAM,sBAAsB,IAAI;AAChC,QAAI,KAAK,UAAU,KAAK,eAAe,SAAS;AAC9C,WAAK,MAAM,WAAW,+BAA+B,KAAK,WAAW,CAAC,EAAE,IAAI,KAAK;AAAA,IACnF;AAAA,EACF;AAAA,EACA,0BAA0B,MAAM,WAAW,MAAM;AAC/C,cAAU,QAAQ,kBAAkB,IAAI,IAAI,KAAK,8BAA8B,MAAM,IAAI,IAAI,KAAK,gBAAgB;AAClH,SAAK,WAAW,KAAK,KAAK,sBAAsB,WAAW,IAAI,CAAC;AAAA,EAClE;AAAA,EACA,uBAAuB,UAAU;AAC/B,QAAI,MAAM,uBAAuB,QAAQ;AAAG,aAAO;AACnD,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,UAAI,CAAC;AAAU,eAAO;AACtB,YAAM,KAAK,KAAK,kBAAkB;AAClC,aAAO,OAAO,OAAO,OAAO;AAAA,IAC9B;AACA,WAAO,CAAC,YAAY,KAAK,aAAa,EAAE;AAAA,EAC1C;AAAA,EACA,iBAAiB,MAAM,UAAU,OAAO,KAAK;AAC3C,UAAM,iBAAiB,MAAM,UAAU,OAAO,GAAG;AACjD,QAAI,UAAU;AACZ,UAAI,CAAC,SAAS,KAAK,MAAM,EAAE,GAAG;AAC5B;AAAA,MACF;AACA,WAAK,aAAa,UAAU,SAAS,QAAQ;AAAA,IAC/C,OAAO;AACL,UAAI,UAAU,UAAU,KAAK,MAAM,EAAE;AAAG,aAAK,WAAW;AACxD,WAAK,aAAa,UAAU,UAAU,UAAU,WAAW,QAAQ;AAAA,IACrE;AAAA,EACF;AAAA,EACA,qBAAqB,WAAW,kBAAkB,oBAAoB,iBAAiB,aAAa;AAClG,UAAM,aAAa,UAAU;AAC7B,QAAI,oBAAoB;AACxB,QAAI,WAAW,SAAS,cAAc;AACpC,UAAI,WAAW,SAAS,QAAQ;AAC9B,4BAAoB;AAAA,MACtB,WAAW,WAAW,SAAS,UAAU;AACvC,4BAAoB;AAAA,MACtB;AAAA,IACF;AACA,QAAI,YAAY;AAChB,QAAI,KAAK,aAAa,EAAE,KAAK,CAAC,KAAK,sBAAsB,IAAI,GAAG;AAC9D,YAAM,WAAW,KAAK,gBAAgB,IAAI;AAC1C,UAAI,sBAAsB,QAAQ,CAAC,2BAA2B,KAAK,MAAM,IAAI,GAAG;AAC9E,kBAAU,WAAW;AACrB,kBAAU,aAAa;AACvB,kBAAU,QAAQ,gBAAgB,QAAQ;AAAA,MAC5C,OAAO;AACL,kBAAU,WAAW;AACrB,kBAAU,aAAa;AACvB,kBAAU,QAAQ,KAAK,gBAAgB;AAAA,MACzC;AAAA,IACF,OAAO;AACL,UAAI,sBAAsB,QAAQ,2BAA2B,KAAK,MAAM,IAAI,GAAG;AAC7E,kBAAU,WAAW,KAAK,gBAAgB,IAAI;AAC9C,kBAAU,aAAa;AAAA,MACzB,OAAO;AACL,YAAI,kBAAkB;AACpB,gBAAM,KAAK,MAAM,OAAO,uBAAuB,WAAW;AAAA,YACxD,YAAY,WAAW;AAAA,UACzB,CAAC;AAAA,QACH;AACA,kBAAU,WAAW;AACrB,kBAAU,aAAa;AAAA,MACzB;AACA,UAAI,KAAK,cAAc,EAAE,GAAG;AAC1B,kBAAU,QAAQ,KAAK,gBAAgB;AAAA,MACzC,OAAO;AACL,oBAAY;AACZ,kBAAU,QAAQ,gBAAgB,UAAU,QAAQ;AAAA,MACtD;AAAA,IACF;AACA,UAAM,wBAAwB,kBAAkB,SAAS;AACzD,QAAI,sBAAsB,uBAAuB;AAC/C,WAAK,MAAM,WAAW,qCAAqC,SAAS;AAAA,IACtE;AACA,QAAI,sBAAsB,uBAAuB;AAC/C,WAAK,kBAAkB,UAAU,MAAM,MAAM,UAAU,MAAM,IAAI,OAAO,IAAI;AAAA,IAC9E;AACA,QAAI,aAAa,CAAC,sBAAsB,CAAC,uBAAuB;AAC9D,WAAK,kBAAkB,UAAU,MAAM,MAAM,UAAU,IAAI,OAAO,MAAM,IAAI;AAAA,IAC9E;AACA,WAAO,KAAK,sBAAsB,WAAW,iBAAiB;AAAA,EAChE;AAAA,EACA,mBAAmB;AACjB,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK;AACH,eAAO,KAAK,gBAAgB,IAAI;AAAA,MAClC;AACE,eAAO,MAAM,iBAAiB;AAAA,IAClC;AAAA,EACF;AAAA,EACA,oBAAoB,MAAM,eAAe;AACvC,UAAM,OAAO,KAAK;AAClB,QAAI,SAAS,SAAS,SAAS,SAAS,KAAK,MAAM,EAAE,GAAG;AACtD,WAAK,iBAAiB,KAAK,kCAAkC;AAAA,IAC/D;AACA,UAAM,oBAAoB,MAAM,aAAa;AAAA,EAC/C;AAAA,EACA,WAAW,MAAM,MAAM;AACrB,UAAM,WAAW,MAAM,IAAI;AAC3B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,GAAG,iBAAiB,KAAK,wBAAwB;AACtD,WAAK,iBAAiB,KAAK,EAAE;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,kCAAkC,MAAM,MAAM;AAC5C,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,wBAAwB,KAAK,MAAM;AACzC,WAAK,MAAM,qBAAqB;AAChC,WAAK,aAAa,KAAK,wBAAwB;AAC/C,WAAK,MAAM,qBAAqB;AAAA,IAClC;AACA,WAAO,MAAM,kCAAkC,MAAM,IAAI;AAAA,EAC3D;AAAA,EACA,wBAAwB;AACtB,WAAO,KAAK,MAAM,EAAE,KAAK,MAAM,sBAAsB;AAAA,EACvD;AAAA,EACA,iBAAiB,qBAAqB,gBAAgB;AACpD,QAAI;AACJ,QAAI,QAAQ;AACZ,QAAII;AACJ,QAAI,KAAK,UAAU,KAAK,MAAM,KAAK,MAAM,GAAG,KAAK,KAAK,MAAM,EAAE,IAAI;AAChE,cAAQ,KAAK,MAAM,MAAM;AACzB,MAAAA,OAAM,KAAK,SAAS,MAAM,MAAM,iBAAiB,qBAAqB,cAAc,GAAG,KAAK;AAC5F,UAAI,CAACA,KAAI;AAAO,eAAOA,KAAI;AAC3B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK;AACT,YAAM,iBAAiB,QAAQ,QAAQ,SAAS,CAAC;AACjD,UAAI,mBAAmB,MAAM,UAAU,mBAAmB,MAAM,QAAQ;AACtE,gBAAQ,IAAI;AAAA,MACd;AAAA,IACF;AACA,SAAK,OAAOA,SAAQ,QAAQ,KAAK,SAAS,KAAK,MAAM,EAAE,GAAG;AACxD,UAAI,OAAO;AACX,cAAQ,SAAS,KAAK,MAAM,MAAM;AAClC,UAAI;AACJ,YAAM,QAAQ,KAAK,SAAS,WAAS;AACnC,YAAI;AACJ,yBAAiB,KAAK,kCAAkC;AACxD,cAAMC,mBAAkB,KAAK,iCAAiC,gBAAgB,MAAM;AAClF,gBAAM,SAAS,MAAM,iBAAiB,qBAAqB,cAAc;AACzE,eAAK,2BAA2B,QAAQ,cAAc;AACtD,iBAAO;AAAA,QACT,CAAC;AACD,aAAK,wBAAwBA,iBAAgB,UAAU,QAAQ,sBAAsB;AAAe,gBAAM;AAC1G,cAAM,OAAO,KAAK,8BAA8BA,gBAAe;AAC/D,YAAI,KAAK,SAAS;AAA2B,gBAAM;AACnD,aAAK,iBAAiB;AACtB,aAAK,2BAA2B,MAAM,cAAc;AACpD,eAAOA;AAAA,MACT,GAAG,KAAK;AACR,UAAI,kBAAkB;AACtB,UAAI,MAAM,QAAQ,KAAK,8BAA8B,MAAM,IAAI,EAAE,SAAS,2BAA2B;AACnG,YAAI,CAAC,MAAM,SAAS,CAAC,MAAM,SAAS;AAClC,cAAI,MAAM,KAAK,OAAO;AACpB,iBAAK,MAAM,WAAW,iDAAiD,cAAc;AAAA,UACvF;AACA,iBAAO,MAAM;AAAA,QACf;AACA,0BAAkB,MAAM;AAAA,MAC1B;AACA,WAAK,QAAQD,SAAQ,QAAQ,MAAM,MAAM;AACvC,aAAK,QAAQA,KAAI;AACjB,eAAOA,KAAI;AAAA,MACb;AACA,UAAI,iBAAiB;AACnB,aAAK,QAAQ,MAAM;AACnB,eAAO;AAAA,MACT;AACA,WAAK,QAAQA,SAAQ,QAAQ,MAAM;AAAQ,cAAMA,KAAI;AACrD,UAAI,MAAM;AAAQ,cAAM,MAAM;AAC9B,YAAM,KAAK,MAAM,WAAW,mCAAmC,cAAc;AAAA,IAC/E;AACA,WAAO,MAAM,iBAAiB,qBAAqB,cAAc;AAAA,EACnE;AAAA,EACA,WAAW,MAAM;AACf,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,SAAS,KAAK,SAAS,MAAM;AACjC,cAAM,wBAAwB,KAAK,MAAM;AACzC,aAAK,MAAM,qBAAqB;AAChC,cAAM,WAAW,KAAK,UAAU;AAChC,SAAC,SAAS,gBAAgB,KAAK,SAAS,IAAI,KAAK,qCAAqC;AACtF,aAAK,MAAM,qBAAqB;AAChC,YAAI,KAAK,mBAAmB;AAAG,eAAK,WAAW;AAC/C,YAAI,CAAC,KAAK,MAAM,EAAE;AAAG,eAAK,WAAW;AACrC,eAAO;AAAA,MACT,CAAC;AACD,UAAI,OAAO;AAAQ,eAAO;AAC1B,UAAI,OAAO;AAAO,aAAK,QAAQ,OAAO;AACtC,WAAK,aAAa,OAAO,KAAK,iBAAiB,KAAK,WAAW,OAAO,MAAM,gBAAgB,IAAI;AAAA,IAClG;AACA,WAAO,MAAM,WAAW,IAAI;AAAA,EAC9B;AAAA,EACA,iBAAiB,QAAQ;AACvB,WAAO,KAAK,MAAM,EAAE,KAAK,MAAM,iBAAiB,MAAM;AAAA,EACxD;AAAA,EACA,2BAA2B,MAAM,QAAQ;AACvC,QAAI,KAAK,MAAM,0BAA0B,QAAQ,KAAK,KAAK,MAAM,IAAI;AACnE,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,YAAM,2BAA2B,MAAM,MAAM;AAAA,IAC/C;AAAA,EACF;AAAA,EACA,YAAY,MAAM,iBAAiB,iBAAiB,oBAAoB,MAAM;AAC5E,QAAI,mBAAmB,KAAK,MAAM,0BAA0B,QAAQ,KAAK,KAAK,MAAM,IAAI;AACtF;AAAA,IACF;AACA,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAC3C,UAAI,KAAK,YAAY,KAAK,OAAO,CAAC,CAAC,KAAK,IAAI,GAAG;AAC7C,aAAK,MAAM,WAAW,sBAAsB,KAAK,OAAO,CAAC,CAAC;AAAA,MAC5D;AAAA,IACF;AACA,UAAM,YAAY,MAAM,iBAAiB,iBAAiB,iBAAiB;AAAA,EAC7E;AAAA,EACA,mCAAmC,YAAY;AAC7C,WAAO,MAAM,mCAAmC,cAAc,KAAK,MAAM,UAAU,QAAQ,KAAK,MAAM,KAAK,MAAM,EAAE;AAAA,EACrH;AAAA,EACA,gBAAgB,MAAM,UAAU,SAAS;AACvC,QAAI,KAAK,SAAS,gBAAgB,KAAK,SAAS,WAAW,KAAK,MAAM,UAAU,QAAQ,SAAS,KAAK,MAAM,IAAI;AAC9G,WAAK,KAAK;AACV,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,WAAK,SAAS;AACd,WAAK,YAAY,MAAM,6BAA6B,IAAI,KAAK;AAC7D,aAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,IAC/C,WAAW,KAAK,SAAS,gBAAgB,KAAK,SAAS,WAAW,KAAK,MAAM,EAAE,GAAG;AAChF,YAAM,QAAQ,KAAK,MAAM,MAAM;AAC/B,YAAM,QAAQ,KAAK,SAAS,WAAS,KAAK,kCAAkC,QAAQ,KAAK,MAAM,GAAG,KAAK;AACvG,UAAI,CAAC,MAAM,SAAS,CAAC,MAAM;AAAS,eAAO,MAAM;AACjD,YAAM,SAAS,KAAK,SAAS,MAAM,MAAM,gBAAgB,MAAM,UAAU,OAAO,GAAG,KAAK;AACxF,UAAI,OAAO,QAAQ,CAAC,OAAO;AAAO,eAAO,OAAO;AAChD,UAAI,MAAM,MAAM;AACd,aAAK,QAAQ,MAAM;AACnB,eAAO,MAAM;AAAA,MACf;AACA,UAAI,OAAO,MAAM;AACf,aAAK,QAAQ,OAAO;AACpB,eAAO,OAAO;AAAA,MAChB;AACA,YAAM,MAAM,SAAS,OAAO;AAAA,IAC9B;AACA,WAAO,MAAM,gBAAgB,MAAM,UAAU,OAAO;AAAA,EACtD;AAAA,EACA,eAAe,MAAM,UAAU,SAAS,gBAAgB;AACtD,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,oBAAoB,GAAG;AAChD,qBAAe,sBAAsB;AACrC,UAAI,SAAS;AACX,uBAAe,OAAO;AACtB,eAAO;AAAA,MACT;AACA,WAAK,KAAK;AACV,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,WAAK,SAAS;AACd,WAAK,gBAAgB,KAAK,oCAAoC;AAC9D,WAAK,OAAO,EAAE;AACd,WAAK,YAAY,KAAK,6BAA6B,IAAI,KAAK;AAC5D,WAAK,WAAW;AAChB,aAAO,KAAK,qBAAqB,MAAM,IAAI;AAAA,IAC7C,WAAW,CAAC,WAAW,KAAK,iBAAiB,KAAK,KAAK,MAAM,EAAE,GAAG;AAChE,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,WAAK,SAAS;AACd,YAAM,SAAS,KAAK,SAAS,MAAM;AACjC,aAAK,gBAAgB,KAAK,6CAA6C;AACvE,aAAK,OAAO,EAAE;AACd,aAAK,YAAY,MAAM,6BAA6B,IAAI,KAAK;AAC7D,YAAI,eAAe,qBAAqB;AACtC,eAAK,WAAW;AAAA,QAClB;AACA,eAAO,KAAK,qBAAqB,MAAM,eAAe,mBAAmB;AAAA,MAC3E,CAAC;AACD,UAAI,OAAO,MAAM;AACf,YAAI,OAAO;AAAO,eAAK,QAAQ,OAAO;AACtC,eAAO,OAAO;AAAA,MAChB;AAAA,IACF;AACA,WAAO,MAAM,eAAe,MAAM,UAAU,SAAS,cAAc;AAAA,EACrE;AAAA,EACA,eAAe,MAAM;AACnB,UAAM,eAAe,IAAI;AACzB,QAAI,QAAQ;AACZ,QAAI,KAAK,iBAAiB,KAAK,KAAK,MAAM,EAAE,GAAG;AAC7C,cAAQ,KAAK,SAAS,MAAM,KAAK,6CAA6C,CAAC,EAAE;AAAA,IACnF;AACA,SAAK,gBAAgB;AAAA,EACvB;AAAA,EACA,kCAAkC,UAAU;AAC1C,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,oBAAoB,MAAM,KAAK;AACpC,QAAI,CAAC,KAAK,WAAW,IAAI;AAAG;AAC5B,WAAO,MAAM,qBAAqB,MAAM,QAAW,IAAI;AAAA,EACzD;AAAA,EACA,sBAAsBN,OAAM;AAC1B,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAIA,UAAS,MAAM,SAAS,MAAM,KAAK,MAAM,gBAAgB;AAC3D,WAAK,MAAM,iBAAiB;AAC5B,WAAK,MAAM,OAAO;AAClB,WAAK,UAAU;AACf;AAAA,IACF;AACA,UAAM,sBAAsBA,KAAI;AAAA,EAClC;AAAA,EACA,mBAAmBA,OAAM;AACvB,UAAM,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC;AACrD,QAAIA,UAAS,OAAO,SAAS,KAAK;AAChC,WAAK,SAAS,GAAG,CAAC;AAClB;AAAA,IACF;AACA,UAAM,mBAAmBA,KAAI;AAAA,EAC/B;AAAA,EACA,cAAc,MAAM,SAAS;AAC3B,UAAM,WAAW,MAAM,cAAc,MAAM,OAAO;AAClD,QAAI,KAAK,MAAM,gBAAgB;AAC7B,WAAK,MAAM,WAAW,yBAAyB,KAAK,MAAM,YAAY,CAAC;AAAA,IACzE;AACA,WAAO;AAAA,EACT;AAAA,EACA,mBAAmB;AACjB,QAAI,KAAK,UAAU,cAAc,KAAK,KAAK,gBAAgB,GAAG;AAC5D,UAAI,KAAK,MAAM,gBAAgB;AAC7B,cAAM,KAAK,MAAM,WAAW,mBAAmB,KAAK,MAAM,QAAQ;AAAA,MACpE;AACA,WAAK,yBAAyB;AAC9B,YAAM,cAAc,KAAK,gBAAgB;AACzC,UAAI,aAAa;AACf,aAAK,MAAM,OAAO;AAClB,aAAK,MAAM,iBAAiB;AAAA,MAC9B;AACA;AAAA,IACF;AACA,WAAO,MAAM,iBAAiB,KAAK,MAAM,iBAAiB,QAAQ,IAAI;AAAA,EACxE;AAAA,EACA,kBAAkB;AAChB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,4BAA4B;AAChC,WAAO,CAAC,IAAI,CAAC,EAAE,SAAS,KAAK,MAAM,WAAW,MAAM,yBAAyB,CAAC,GAAG;AAC/E;AAAA,IACF;AACA,UAAM,MAAM,KAAK,MAAM,WAAW,4BAA4B,GAAG;AACjE,UAAM,MAAM,KAAK,MAAM,WAAW,4BAA4B,MAAM,CAAC;AACrE,QAAI,QAAQ,MAAM,QAAQ,IAAI;AAC5B,aAAO,4BAA4B;AAAA,IACrC;AACA,QAAI,KAAK,MAAM,MAAM,4BAA4B,KAAK,4BAA4B,MAAM,EAAE,MAAM,gBAAgB;AAC9G,aAAO,4BAA4B;AAAA,IACrC;AACA,QAAI,QAAQ,MAAM,QAAQ,IAAI;AAC5B,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B;AACzB,UAAM,MAAM,KAAK,MAAM,QAAQ,MAAM,KAAK,MAAM,GAAG;AACnD,QAAI,QAAQ,IAAI;AACd,YAAM,KAAK,MAAM,OAAO,qBAAqB,KAAK,MAAM,YAAY,CAAC;AAAA,IACvE;AAAA,EACF;AAAA,EACA,yCAAyC,KAAK;AAAA,IAC5C;AAAA,IACA;AAAA,EACF,GAAG;AACD,SAAK,MAAM,WAAW,iCAAiC,KAAK;AAAA,MAC1D;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,sCAAsC,KAAK,aAAa;AACtD,WAAO,KAAK,MAAM,CAAC,YAAY,eAAe,WAAW,0CAA0C,YAAY,iBAAiB,WAAW,WAAW,yCAAyC,WAAW,yCAAyC,KAAK,WAAW;AAAA,EACrQ;AAAA,EACA,wCAAwC,KAAK,SAAS;AACpD,SAAK,MAAM,WAAW,gCAAgC,KAAK,OAAO;AAAA,EACpE;AAAA,EACA,mDAAmD,MAAM,SAAS;AAChE,SAAK,MAAM,WAAW,2CAA2C,MAAM,OAAO;AAAA,EAChF;AAAA,EACA,qBAAqB;AACnB,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,YAAY,MAAM,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,CAAC;AACtD,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK,KACH;AACE,cAAM,UAAU,KAAK,oBAAoB,KAAK,MAAM,KAAK;AACzD,YAAI,UAAU,GAAG;AACf,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,KAAK,QAAQ,IAAI;AAAA,YACjB,OAAO;AAAA,UACT;AAAA,QACF;AACA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK;AAAA,QACP;AAAA,MACF;AAAA,MACF,KAAK,KACH;AACE,cAAM,UAAU,KAAK,mBAAmB,KAAK,MAAM,KAAK;AACxD,YAAI,UAAU,GAAG;AACf,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,KAAK,QAAQ,IAAI;AAAA,YACjB,OAAO;AAAA,UACT;AAAA,QACF;AACA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK;AAAA,QACP;AAAA,MACF;AAAA,MACF,KAAK;AAAA,MACL,KAAK,IACH;AACE,cAAM,UAAU,KAAK,oBAAoB,KAAK,MAAM,EAAE,CAAC;AACvD,YAAI,UAAU,GAAG;AACf,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,KAAK,QAAQ,IAAI;AAAA,YACjB,OAAO;AAAA,UACT;AAAA,QACF;AACA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK;AAAA,QACP;AAAA,MACF;AAAA,MACF;AACE,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK;AAAA,QACP;AAAA,IACJ;AAAA,EACF;AAAA,EACA,oBAAoB;AAClB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,KAAK,KAAK,gBAAgB,IAAI;AACpC,UAAM,OAAO,KAAK,IAAI,EAAE,IAAI,KAAK,mBAAmB,IAAI;AAAA,MACtD,MAAM;AAAA,MACN;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,kCAAkC,KAAK,SAAS,cAAc;AAC5D,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,iBAAiB,MAAM;AACzB;AAAA,IACF;AACA,QAAI,iBAAiB,cAAc;AACjC,WAAK,sCAAsC,KAAK,OAAO;AAAA,IACzD;AAAA,EACF;AAAA,EACA,gBAAgB;AAAA,IACd;AAAA,IACA;AAAA,EACF,GAAG;AACD,UAAM,YAAY,oBAAI,IAAI;AAC1B,UAAM,UAAU;AAAA,MACd,gBAAgB,CAAC;AAAA,MACjB,eAAe,CAAC;AAAA,MAChB,eAAe,CAAC;AAAA,MAChB,kBAAkB,CAAC;AAAA,IACrB;AACA,QAAI,oBAAoB;AACxB,WAAO,CAAC,KAAK,MAAM,CAAC,GAAG;AACrB,UAAI,KAAK,IAAI,EAAE,GAAG;AAChB,4BAAoB;AACpB;AAAA,MACF;AACA,YAAM,aAAa,KAAK,UAAU;AAClC,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,MACF,IAAI,KAAK,kBAAkB;AAC3B,YAAM,aAAa,GAAG;AACtB,UAAI,eAAe,IAAI;AACrB;AAAA,MACF;AACA,UAAI,SAAS,KAAK,UAAU,GAAG;AAC7B,aAAK,MAAM,WAAW,uBAAuB,IAAI;AAAA,UAC/C;AAAA,UACA,YAAY,WAAW,CAAC,EAAE,YAAY,IAAI,WAAW,MAAM,CAAC;AAAA,UAC5D;AAAA,QACF,CAAC;AAAA,MACH;AACA,UAAI,UAAU,IAAI,UAAU,GAAG;AAC7B,aAAK,MAAM,WAAW,yBAAyB,IAAI;AAAA,UACjD;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AACA,gBAAU,IAAI,UAAU;AACxB,YAAM,UAAU;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,iBAAW,KAAK;AAChB,cAAQ,KAAK,MAAM;AAAA,QACjB,KAAK,WACH;AACE,eAAK,kCAAkC,KAAK,KAAK,SAAS,SAAS;AACnE,qBAAW,OAAO,KAAK;AACvB,kBAAQ,eAAe,KAAK,KAAK,WAAW,YAAY,mBAAmB,CAAC;AAC5E;AAAA,QACF;AAAA,QACF,KAAK,UACH;AACE,eAAK,kCAAkC,KAAK,KAAK,SAAS,QAAQ;AAClE,qBAAW,OAAO,KAAK;AACvB,kBAAQ,cAAc,KAAK,KAAK,WAAW,YAAY,kBAAkB,CAAC;AAC1E;AAAA,QACF;AAAA,QACF,KAAK,UACH;AACE,eAAK,kCAAkC,KAAK,KAAK,SAAS,QAAQ;AAClE,qBAAW,OAAO,KAAK;AACvB,kBAAQ,cAAc,KAAK,KAAK,WAAW,YAAY,kBAAkB,CAAC;AAC1E;AAAA,QACF;AAAA,QACF,KAAK,WACH;AACE,gBAAM,KAAK,sCAAsC,KAAK,KAAK,OAAO;AAAA,QACpE;AAAA,QACF,KAAK,QACH;AACE,kBAAQ,cAAc;AAAA,YACpB,KAAK;AACH,mBAAK,yCAAyC,KAAK,KAAK,OAAO;AAC/D;AAAA,YACF,KAAK;AACH,mBAAK,wCAAwC,KAAK,KAAK,OAAO;AAC9D;AAAA,YACF;AACE,sBAAQ,iBAAiB,KAAK,KAAK,WAAW,YAAY,qBAAqB,CAAC;AAAA,UACpF;AAAA,QACF;AAAA,MACJ;AACA,UAAI,CAAC,KAAK,MAAM,CAAC,GAAG;AAClB,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,sBAAsB,oBAAoB,kBAAkB;AAAA,IAC1D;AAAA,EACF,GAAG;AACD,QAAI,mBAAmB,WAAW,GAAG;AACnC,aAAO;AAAA,IACT,WAAW,iBAAiB,WAAW,GAAG;AACxC,aAAO;AAAA,IACT,WAAW,iBAAiB,SAAS,mBAAmB,QAAQ;AAC9D,iBAAW,UAAU,oBAAoB;AACvC,aAAK,mDAAmD,QAAQ;AAAA,UAC9D;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT,OAAO;AACL,iBAAW,UAAU,kBAAkB;AACrC,aAAK,mDAAmD,QAAQ;AAAA,UAC9D;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,0BAA0B;AAAA,IACxB;AAAA,EACF,GAAG;AACD,QAAI,CAAC,KAAK,cAAc,GAAG;AAAG,aAAO;AACrC,QAAI,CAAC,kBAAkB,KAAK,MAAM,IAAI,GAAG;AACvC,YAAM,KAAK,MAAM,WAAW,wCAAwC,KAAK,MAAM,UAAU;AAAA,QACvF;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,SAAK,KAAK;AACV,QAAI,UAAU,aAAa,UAAU,YAAY,UAAU,YAAY,UAAU,UAAU;AACzF,WAAK,MAAM,WAAW,yBAAyB,KAAK,MAAM,UAAU;AAAA,QAClE;AAAA,QACA,iBAAiB;AAAA,MACnB,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EACA,aAAa,MAAM,IAAI;AACrB,UAAM,WAAW,GAAG;AACpB,UAAM,UAAU,GAAG,IAAI;AACvB,UAAM,eAAe,KAAK,0BAA0B;AAAA,MAClD;AAAA,IACF,CAAC;AACD,SAAK,OAAO,CAAC;AACb,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,KAAK,gBAAgB;AAAA,MACvB;AAAA,MACA;AAAA,IACF,CAAC;AACD,SAAK,oBAAoB;AACzB,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,aAAK,eAAe;AACpB,aAAK,UAAU,QAAQ;AACvB,aAAK,OAAO,CAAC;AACb,eAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,MAChD,KAAK;AACH,aAAK,eAAe;AACpB,aAAK,UAAU,QAAQ;AACvB,aAAK,OAAO,CAAC;AACb,eAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,MAC/C,KAAK;AACH,aAAK,eAAe;AACpB,aAAK,UAAU,KAAK,sBAAsB,QAAQ,eAAe,QAAQ,kBAAkB;AAAA,UACzF;AAAA,QACF,CAAC;AACD,aAAK,OAAO,CAAC;AACb,eAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,MAC/C,KAAK;AACH,aAAK,UAAU,QAAQ;AACvB,aAAK,OAAO,CAAC;AACb,eAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,MAC/C,SACE;AACE,cAAM,QAAQ,MAAM;AAClB,eAAK,UAAU,CAAC;AAChB,eAAK,OAAO,CAAC;AACb,iBAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,QAC/C;AACA,aAAK,eAAe;AACpB,cAAM,WAAW,QAAQ,eAAe;AACxC,cAAM,UAAU,QAAQ,cAAc;AACtC,cAAM,UAAU,QAAQ,cAAc;AACtC,cAAM,eAAe,QAAQ,iBAAiB;AAC9C,YAAI,CAAC,YAAY,CAAC,WAAW,CAAC,WAAW,CAAC,cAAc;AACtD,iBAAO,MAAM;AAAA,QACf,WAAW,CAAC,YAAY,CAAC,SAAS;AAChC,eAAK,UAAU,KAAK,sBAAsB,QAAQ,eAAe,QAAQ,kBAAkB;AAAA,YACzF;AAAA,UACF,CAAC;AACD,eAAK,OAAO,CAAC;AACb,iBAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,QAC/C,WAAW,CAAC,WAAW,CAAC,WAAW,YAAY,cAAc;AAC3D,qBAAW,UAAU,QAAQ,kBAAkB;AAC7C,iBAAK,yCAAyC,OAAO,IAAI,OAAO;AAAA,cAC9D;AAAA,cACA,YAAY,OAAO,GAAG;AAAA,YACxB,CAAC;AAAA,UACH;AACA,eAAK,UAAU,QAAQ;AACvB,eAAK,OAAO,CAAC;AACb,iBAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,QAChD,WAAW,CAAC,YAAY,CAAC,WAAW,WAAW,cAAc;AAC3D,qBAAW,UAAU,QAAQ,kBAAkB;AAC7C,iBAAK,wCAAwC,OAAO,IAAI,OAAO;AAAA,cAC7D;AAAA,cACA,YAAY,OAAO,GAAG;AAAA,YACxB,CAAC;AAAA,UACH;AACA,eAAK,UAAU,QAAQ;AACvB,eAAK,OAAO,CAAC;AACb,iBAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,QAC/C,OAAO;AACL,eAAK,MAAM,WAAW,8BAA8B,SAAS;AAAA,YAC3D;AAAA,UACF,CAAC;AACD,iBAAO,MAAM;AAAA,QACf;AAAA,MACF;AAAA,IACJ;AAAA,EACF;AAAA,EACA,yBAAyB,MAAM;AAC7B,UAAM,KAAK,KAAK,gBAAgB;AAChC,SAAK,KAAK;AACV,SAAK,OAAO,KAAK,aAAa,KAAK,UAAU,GAAG,EAAE;AAClD,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,sBAAsB;AACpB,UAAM,OAAO,KAAK,eAAe;AACjC,QAAI,KAAK,MAAM,WAAW,IAAI,MAAM,IAAI;AACtC,YAAM,YAAY,KAAK,MAAM,WAAW,OAAO,CAAC;AAChD,aAAO,cAAc,MAAM,cAAc;AAAA,IAC3C;AACA,WAAO;AAAA,EACT;AAAA,EACA,8BAA8B,MAAM;AAClC,WAAO,KAAK,SAAS,uBAAuB,KAAK,aAAa;AAAA,EAChE;AACF;AACA,MAAM,WAAW;AAAA,EACf,WAAW;AAAA,EACX,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,KAAK;AAAA,EACL,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,SAAS;AAAA,EACT,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,KAAK;AAAA,EACL,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,SAAS;AAAA,EACT,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO;AAAA,EACP,UAAU;AAAA,EACV,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AACT;AACA,MAAM,YAAY,oBAAoB;AAAA,EACpC,kBAAkB;AAAA,EAClB,0BAA0B,CAAC;AAAA,IACzB;AAAA,EACF,MAAM,+CAA+C,cAAc;AAAA,EACnE,2BAA2B;AAAA,EAC3B,8BAA8B;AAAA,EAC9B,iBAAiB,CAAC;AAAA,IAChB;AAAA,IACA;AAAA,EACF,MAAM,sBAAsB,UAAU,sBAAsB,UAAU,aAAa,UAAU;AAAA,EAC7F,qBAAqB;AAAA,EACrB,wBAAwB;AAAA,EACxB,8BAA8B;AAChC,CAAC;AACD,SAAS,WAAW,QAAQ;AAC1B,SAAO,SAAS,OAAO,SAAS,wBAAwB,OAAO,SAAS,uBAAuB;AACjG;AACA,SAAS,oBAAoB,QAAQ;AACnC,MAAI,OAAO,SAAS,iBAAiB;AACnC,WAAO,OAAO;AAAA,EAChB;AACA,MAAI,OAAO,SAAS,qBAAqB;AACvC,WAAO,OAAO,UAAU,OAAO,MAAM,OAAO,KAAK;AAAA,EACnD;AACA,MAAI,OAAO,SAAS,uBAAuB;AACzC,WAAO,oBAAoB,OAAO,MAAM,IAAI,MAAM,oBAAoB,OAAO,QAAQ;AAAA,EACvF;AACA,QAAM,IAAI,MAAM,+BAA+B,OAAO,IAAI;AAC5D;AACA,IAAI,MAAM,gBAAc,MAAM,uBAAuB,WAAW;AAAA,EAC9D,eAAe;AACb,QAAI,MAAM;AACV,QAAI,aAAa,KAAK,MAAM;AAC5B,eAAS;AACP,UAAI,KAAK,MAAM,OAAO,KAAK,QAAQ;AACjC,cAAM,KAAK,MAAM,UAAU,wBAAwB,KAAK,MAAM,QAAQ;AAAA,MACxE;AACA,YAAM,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAC/C,cAAQ,IAAI;AAAA,QACV,KAAK;AAAA,QACL,KAAK;AACH,cAAI,KAAK,MAAM,QAAQ,KAAK,MAAM,OAAO;AACvC,gBAAI,OAAO,MAAM,KAAK,MAAM,oBAAoB;AAC9C,gBAAE,KAAK,MAAM;AACb,mBAAK,YAAY,GAAG;AAAA,YACtB,OAAO;AACL,oBAAM,iBAAiB,EAAE;AAAA,YAC3B;AACA;AAAA,UACF;AACA,iBAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AAClD,eAAK,YAAY,KAAK,GAAG;AACzB;AAAA,QACF,KAAK;AACH,iBAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AAClD,iBAAO,KAAK,cAAc;AAC1B,uBAAa,KAAK,MAAM;AACxB;AAAA,QACF,KAAK;AAAA,QACL,KAAK;AAAA,QACL;AACE,cAAI,UAAU,EAAE,GAAG;AACjB,mBAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AAClD,mBAAO,KAAK,eAAe,IAAI;AAC/B,yBAAa,KAAK,MAAM;AAAA,UAC1B,OAAO;AACL,cAAE,KAAK,MAAM;AAAA,UACf;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AAAA,EACA,eAAe,eAAe;AAC5B,UAAM,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAC/C,QAAI;AACJ,MAAE,KAAK,MAAM;AACb,QAAI,OAAO,MAAM,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG,MAAM,IAAI;AAC7D,QAAE,KAAK,MAAM;AACb,YAAM,gBAAgB,OAAO;AAAA,IAC/B,OAAO;AACL,YAAM,OAAO,aAAa,EAAE;AAAA,IAC9B;AACA,MAAE,KAAK,MAAM;AACb,SAAK,MAAM,YAAY,KAAK,MAAM;AAClC,WAAO;AAAA,EACT;AAAA,EACA,cAAc,OAAO;AACnB,QAAI,MAAM;AACV,QAAI,aAAa,EAAE,KAAK,MAAM;AAC9B,eAAS;AACP,UAAI,KAAK,MAAM,OAAO,KAAK,QAAQ;AACjC,cAAM,KAAK,MAAM,OAAO,oBAAoB,KAAK,MAAM,QAAQ;AAAA,MACjE;AACA,YAAM,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG;AAC/C,UAAI,OAAO;AAAO;AAClB,UAAI,OAAO,IAAI;AACb,eAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AAClD,eAAO,KAAK,cAAc;AAC1B,qBAAa,KAAK,MAAM;AAAA,MAC1B,WAAW,UAAU,EAAE,GAAG;AACxB,eAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,GAAG;AAClD,eAAO,KAAK,eAAe,KAAK;AAChC,qBAAa,KAAK,MAAM;AAAA,MAC1B,OAAO;AACL,UAAE,KAAK,MAAM;AAAA,MACf;AAAA,IACF;AACA,WAAO,KAAK,MAAM,MAAM,YAAY,KAAK,MAAM,KAAK;AACpD,SAAK,YAAY,KAAK,GAAG;AAAA,EAC3B;AAAA,EACA,gBAAgB;AACd,UAAM,WAAW,EAAE,KAAK,MAAM;AAC9B,QAAI,KAAK,eAAe,KAAK,MAAM,GAAG,MAAM,IAAI;AAC9C,QAAE,KAAK,MAAM;AACb,UAAI,QAAQ;AACZ,UAAI,KAAK,eAAe,KAAK,MAAM,GAAG,MAAM,KAAK;AAC/C,gBAAQ;AACR,UAAE,KAAK,MAAM;AAAA,MACf;AACA,YAAM,YAAY,KAAK,QAAQ,OAAO,QAAW,OAAO,MAAM;AAC9D,UAAI,cAAc,QAAQ,KAAK,eAAe,KAAK,MAAM,GAAG,MAAM,IAAI;AACpE,UAAE,KAAK,MAAM;AACb,eAAO,OAAO,cAAc,SAAS;AAAA,MACvC;AAAA,IACF,OAAO;AACL,UAAI,QAAQ;AACZ,UAAI,OAAO;AACX,aAAO,UAAU,MAAM,KAAK,MAAM,MAAM,KAAK,UAAU,EAAE,OAAO,KAAK,eAAe,KAAK,MAAM,GAAG,KAAK,KAAK;AAC1G,UAAE,KAAK,MAAM;AAAA,MACf;AACA,UAAI,MAAM;AACR,cAAM,OAAO,KAAK,MAAM,MAAM,UAAU,KAAK,MAAM,GAAG;AACtD,cAAM,SAAS,SAAS,IAAI;AAC5B,UAAE,KAAK,MAAM;AACb,YAAI,QAAQ;AACV,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,SAAK,MAAM,MAAM;AACjB,WAAO;AAAA,EACT;AAAA,EACA,cAAc;AACZ,QAAI;AACJ,UAAM,QAAQ,KAAK,MAAM;AACzB,OAAG;AACD,WAAK,KAAK,MAAM,WAAW,EAAE,KAAK,MAAM,GAAG;AAAA,IAC7C,SAAS,iBAAiB,EAAE,KAAK,OAAO;AACxC,SAAK,YAAY,KAAK,KAAK,MAAM,MAAM,OAAO,KAAK,MAAM,GAAG,CAAC;AAAA,EAC/D;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,WAAK,OAAO,KAAK,MAAM;AAAA,IACzB,WAAW,eAAe,KAAK,MAAM,IAAI,GAAG;AAC1C,WAAK,OAAO,eAAe,KAAK,MAAM,IAAI;AAAA,IAC5C,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,yBAAyB;AACvB,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,OAAO,KAAK,mBAAmB;AACrC,QAAI,CAAC,KAAK,IAAI,EAAE;AAAG,aAAO;AAC1B,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,YAAY;AACjB,SAAK,OAAO,KAAK,mBAAmB;AACpC,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,sBAAsB;AACpB,UAAM,WAAW,KAAK,MAAM;AAC5B,QAAI,OAAO,KAAK,uBAAuB;AACvC,QAAI,KAAK,SAAS,qBAAqB;AACrC,aAAO;AAAA,IACT;AACA,WAAO,KAAK,IAAI,EAAE,GAAG;AACnB,YAAM,UAAU,KAAK,YAAY,QAAQ;AACzC,cAAQ,SAAS;AACjB,cAAQ,WAAW,KAAK,mBAAmB;AAC3C,aAAO,KAAK,WAAW,SAAS,qBAAqB;AAAA,IACvD;AACA,WAAO;AAAA,EACT;AAAA,EACA,yBAAyB;AACvB,QAAI;AACJ,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK;AACH,eAAO,KAAK,UAAU;AACtB,aAAK,WAAW,MAAM,KAAK;AAC3B,aAAK,KAAK;AACV,eAAO,KAAK,4BAA4B,MAAM,MAAM,MAAM;AAC1D,YAAI,KAAK,WAAW,SAAS,sBAAsB;AACjD,eAAK,MAAM,UAAU,kBAAkB,IAAI;AAAA,QAC7C;AACA,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,cAAc;AAAA,MAC5B;AACE,cAAM,KAAK,MAAM,UAAU,qBAAqB,KAAK,MAAM,QAAQ;AAAA,IACvE;AAAA,EACF;AAAA,EACA,0BAA0B;AACxB,UAAM,OAAO,KAAK,YAAY,KAAK,MAAM,aAAa;AACtD,WAAO,KAAK,aAAa,MAAM,sBAAsB,KAAK,MAAM,QAAQ;AAAA,EAC1E;AAAA,EACA,oBAAoB,MAAM;AACxB,SAAK,KAAK;AACV,SAAK,aAAa,KAAK,gBAAgB;AACvC,SAAK,WAAW,MAAM,MAAM;AAC5B,SAAK,MAAM,qBAAqB;AAChC,SAAK,OAAO,CAAC;AACb,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,4BAA4B,MAAM,iBAAiB;AACjD,QAAI,KAAK,MAAM,CAAC,GAAG;AACjB,WAAK,aAAa,KAAK,wBAAwB;AAAA,IACjD,OAAO;AACL,YAAM,aAAa,KAAK,gBAAgB;AACxC,WAAK,aAAa;AAAA,IACpB;AACA,SAAK,WAAW,eAAe;AAC/B,SAAK,MAAM,qBAAqB;AAChC,SAAK,OAAO,CAAC;AACb,WAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,EACvD;AAAA,EACA,oBAAoB;AAClB,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,KAAK,MAAM,CAAC,GAAG;AACjB,WAAK,WAAW,MAAM,KAAK;AAC3B,WAAK,KAAK;AACV,WAAK,OAAO,EAAE;AACd,WAAK,WAAW,KAAK,wBAAwB;AAC7C,WAAK,WAAW,MAAM,MAAM;AAC5B,WAAK,MAAM,qBAAqB;AAChC,WAAK,OAAO,CAAC;AACb,aAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,IACnD;AACA,SAAK,OAAO,KAAK,uBAAuB;AACxC,SAAK,QAAQ,KAAK,IAAI,EAAE,IAAI,KAAK,uBAAuB,IAAI;AAC5D,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,yBAAyB,UAAU;AACjC,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,QAAI,KAAK,IAAI,GAAG,GAAG;AACjB,aAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,IACnD;AACA,SAAK,OAAO,KAAK,oBAAoB;AACrC,WAAO,KAAK,gCAAgC,IAAI;AAAA,EAClD;AAAA,EACA,gCAAgC,MAAM;AACpC,UAAM,aAAa,CAAC;AACpB,WAAO,CAAC,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,GAAG,GAAG;AAC1C,iBAAW,KAAK,KAAK,kBAAkB,CAAC;AAAA,IAC1C;AACA,SAAK,aAAa;AAClB,SAAK,cAAc,KAAK,IAAI,EAAE;AAC9B,SAAK,OAAO,GAAG;AACf,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,yBAAyB,UAAU;AACjC,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,QAAI,KAAK,IAAI,GAAG,GAAG;AACjB,aAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,IACnD;AACA,SAAK,OAAO,KAAK,oBAAoB;AACrC,SAAK,OAAO,GAAG;AACf,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,kBAAkB,UAAU;AAC1B,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,UAAM,WAAW,CAAC;AAClB,UAAM,iBAAiB,KAAK,yBAAyB,QAAQ;AAC7D,QAAI,iBAAiB;AACrB,QAAI,CAAC,eAAe,aAAa;AAC/B;AAAU,mBAAS;AACjB,kBAAQ,KAAK,MAAM,MAAM;AAAA,YACvB,KAAK;AACH,yBAAW,KAAK,MAAM;AACtB,mBAAK,KAAK;AACV,kBAAI,KAAK,IAAI,EAAE,GAAG;AAChB,iCAAiB,KAAK,yBAAyB,QAAQ;AACvD,sBAAM;AAAA,cACR;AACA,uBAAS,KAAK,KAAK,kBAAkB,QAAQ,CAAC;AAC9C;AAAA,YACF,KAAK;AACH,uBAAS,KAAK,KAAK,cAAc,CAAC;AAClC;AAAA,YACF,KAAK,GACH;AACE,oBAAME,QAAO,KAAK,UAAU;AAC5B,mBAAK,WAAW,MAAM,KAAK;AAC3B,mBAAK,KAAK;AACV,kBAAI,KAAK,MAAM,EAAE,GAAG;AAClB,yBAAS,KAAK,KAAK,oBAAoBA,KAAI,CAAC;AAAA,cAC9C,OAAO;AACL,yBAAS,KAAK,KAAK,4BAA4BA,OAAM,MAAM,MAAM,CAAC;AAAA,cACpE;AACA;AAAA,YACF;AAAA,YACF;AACE,mBAAK,WAAW;AAAA,UACpB;AAAA,QACF;AACA,UAAI,WAAW,cAAc,KAAK,CAAC,WAAW,cAAc,KAAK,mBAAmB,MAAM;AACxF,aAAK,MAAM,UAAU,2BAA2B,cAAc;AAAA,MAChE,WAAW,CAAC,WAAW,cAAc,KAAK,WAAW,cAAc,GAAG;AACpE,aAAK,MAAM,UAAU,0BAA0B,gBAAgB;AAAA,UAC7D,gBAAgB,oBAAoB,eAAe,IAAI;AAAA,QACzD,CAAC;AAAA,MACH,WAAW,CAAC,WAAW,cAAc,KAAK,CAAC,WAAW,cAAc,GAAG;AACrE,YAAI,oBAAoB,eAAe,IAAI,MAAM,oBAAoB,eAAe,IAAI,GAAG;AACzF,eAAK,MAAM,UAAU,0BAA0B,gBAAgB;AAAA,YAC7D,gBAAgB,oBAAoB,eAAe,IAAI;AAAA,UACzD,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AACA,QAAI,WAAW,cAAc,GAAG;AAC9B,WAAK,kBAAkB;AACvB,WAAK,kBAAkB;AAAA,IACzB,OAAO;AACL,WAAK,iBAAiB;AACtB,WAAK,iBAAiB;AAAA,IACxB;AACA,SAAK,WAAW;AAChB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,KAAK,MAAM,UAAU,8BAA8B,KAAK,MAAM,QAAQ;AAAA,IAC9E;AACA,WAAO,WAAW,cAAc,IAAI,KAAK,WAAW,MAAM,aAAa,IAAI,KAAK,WAAW,MAAM,YAAY;AAAA,EAC/G;AAAA,EACA,kBAAkB;AAChB,UAAM,WAAW,KAAK,MAAM;AAC5B,SAAK,KAAK;AACV,WAAO,KAAK,kBAAkB,QAAQ;AAAA,EACxC;AAAA,EACA,WAAW,YAAY;AACrB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,YAAQ,QAAQ,SAAS,CAAC,IAAI;AAAA,EAChC;AAAA,EACA,cAAc,qBAAqB;AACjC,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,aAAO,KAAK,aAAa,KAAK,MAAM,OAAO,SAAS;AAAA,IACtD,WAAW,KAAK,MAAM,GAAG,GAAG;AAC1B,aAAO,KAAK,gBAAgB;AAAA,IAC9B,WAAW,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM,GAAG,MAAM,IAAI;AACzE,WAAK,aAAa,GAAG;AACrB,aAAO,KAAK,gBAAgB;AAAA,IAC9B,OAAO;AACL,aAAO,MAAM,cAAc,mBAAmB;AAAA,IAChD;AAAA,EACF;AAAA,EACA,YAAY;AACV,UAAM,aAAa,KAAK,WAAW;AACnC,QAAI,CAAC,WAAW;AAAe,YAAM,UAAU;AAAA,EACjD;AAAA,EACA,iBAAiBF,OAAM;AACrB,UAAM,UAAU,KAAK,WAAW;AAChC,QAAI,YAAY,MAAM,QAAQ;AAC5B,WAAK,aAAa;AAClB;AAAA,IACF;AACA,QAAI,YAAY,MAAM,UAAU,YAAY,MAAM,QAAQ;AACxD,UAAI,kBAAkBA,KAAI,GAAG;AAC3B,aAAK,YAAY;AACjB;AAAA,MACF;AACA,UAAIA,UAAS,IAAI;AACf,UAAE,KAAK,MAAM;AACb,aAAK,YAAY,GAAG;AACpB;AAAA,MACF;AACA,WAAKA,UAAS,MAAMA,UAAS,OAAO,YAAY,MAAM,QAAQ;AAC5D,aAAK,cAAcA,KAAI;AACvB;AAAA,MACF;AAAA,IACF;AACA,QAAIA,UAAS,MAAM,KAAK,MAAM,sBAAsB,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,IAAI;AACpG,QAAE,KAAK,MAAM;AACb,WAAK,YAAY,GAAG;AACpB;AAAA,IACF;AACA,UAAM,iBAAiBA,KAAI;AAAA,EAC7B;AAAA,EACA,cAAc,UAAU;AACtB,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAAS,MAAM,aAAa,KAAK;AACnC,cAAQ,OAAO,IAAI,GAAG,MAAM,MAAM;AAClC,WAAK,MAAM,qBAAqB;AAAA,IAClC,WAAW,SAAS,KAAK;AACvB,cAAQ,KAAK,MAAM,MAAM;AAAA,IAC3B,WAAW,SAAS,KAAK;AACvB,YAAM,MAAM,QAAQ,QAAQ,SAAS,CAAC;AACtC,UAAI,QAAQ,MAAM,UAAU,aAAa,MAAM,QAAQ,MAAM,QAAQ;AACnE,gBAAQ,IAAI;AACZ,aAAK,MAAM,qBAAqB,QAAQ,QAAQ,SAAS,CAAC,MAAM,MAAM;AAAA,MACxE,OAAO;AACL,aAAK,WAAW,MAAM,MAAM;AAC5B,aAAK,MAAM,qBAAqB;AAAA,MAClC;AAAA,IACF,OAAO;AACL,WAAK,MAAM,qBAAqB,2BAA2B,IAAI;AAAA,IACjE;AAAA,EACF;AACF;AACA,MAAM,wBAAwB,MAAM;AAAA,EAClC,eAAe,MAAM;AACnB,UAAM,GAAG,IAAI;AACb,SAAK,UAAU,oBAAI,IAAI;AAAA,EACzB;AACF;AACA,MAAM,+BAA+B,aAAa;AAAA,EAChD,eAAe,MAAM;AACnB,UAAM,GAAG,IAAI;AACb,SAAK,eAAe,CAAC;AAAA,EACvB;AAAA,EACA,YAAY,OAAO;AACjB,SAAK,aAAa,KAAK,oBAAI,IAAI,CAAC;AAChC,WAAO,IAAI,gBAAgB,KAAK;AAAA,EAClC;AAAA,EACA,MAAM,OAAO;AACX,QAAI,SAAS,KAAK;AAChB,WAAK,aAAa,KAAK,oBAAI,IAAI,CAAC;AAAA,IAClC;AACA,UAAM,MAAM,KAAK;AAAA,EACnB;AAAA,EACA,OAAO;AACL,UAAM,QAAQ,MAAM,KAAK;AACzB,QAAI,SAAS,KAAK;AAChB,WAAK,aAAa,IAAI;AAAA,IACxB;AACA,WAAO;AAAA,EACT;AAAA,EACA,UAAU,MAAM,aAAa;AAC3B,UAAM,MAAM,KAAK,aAAa;AAC9B,QAAI,KAAK,aAAa,MAAM,CAAC,EAAE,IAAI,IAAI,GAAG;AACxC,aAAO;AAAA,IACT;AACA,QAAI,CAAC,eAAe,MAAM,GAAG;AAC3B,eAAS,IAAI,GAAG,IAAI,MAAM,GAAG,KAAK;AAChC,YAAI,KAAK,aAAa,CAAC,EAAE,IAAI,IAAI;AAAG,iBAAO;AAAA,MAC7C;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM,aAAa,KAAK;AAClC,QAAI,cAAc,MAAM;AACtB,UAAI,KAAK,UAAU,MAAM,IAAI,GAAG;AAC9B,aAAK,OAAO,MAAM,OAAO,kBAAkB,KAAK;AAAA,UAC9C,gBAAgB;AAAA,QAClB,CAAC;AAAA,MACH;AACA,WAAK,aAAa,KAAK,aAAa,SAAS,CAAC,EAAE,IAAI,IAAI;AACxD;AAAA,IACF;AACA,UAAM,QAAQ,KAAK,aAAa;AAChC,QAAI,OAAO,MAAM,QAAQ,IAAI,IAAI,KAAK;AACtC,QAAI,cAAc,MAAM;AACtB,WAAK,mBAAmB,OAAO,IAAI;AACnC,YAAM,QAAQ,IAAI,MAAM,OAAO,EAAE;AACjC;AAAA,IACF;AACA,UAAM,YAAY,MAAM,aAAa,GAAG;AACxC,QAAI,cAAc,GAAG;AACnB,UAAI,EAAE,cAAc,IAAI;AACtB,aAAK,0BAA0B,OAAO,MAAM,aAAa,GAAG;AAC5D,aAAK,mBAAmB,OAAO,IAAI;AAAA,MACrC;AACA,aAAO,OAAO;AAAA,IAChB;AACA,QAAI,cAAc,KAAK;AACrB,aAAO,OAAO;AAAA,IAChB;AACA,QAAI,cAAc,KAAK;AACrB,aAAO,OAAO;AAAA,IAChB;AACA,QAAI,cAAc,KAAK;AACrB,aAAO,OAAO;AAAA,IAChB;AACA,QAAI;AAAM,YAAM,QAAQ,IAAI,MAAM,IAAI;AAAA,EACxC;AAAA,EACA,oBAAoB,OAAO,MAAM,aAAa;AAC5C,UAAM,OAAO,MAAM,QAAQ,IAAI,IAAI;AACnC,SAAK,OAAO,KAAK,GAAG;AAClB,UAAI,cAAc,KAAK;AACrB,cAAM,UAAU,CAAC,EAAE,cAAc;AACjC,cAAM,YAAY,OAAO,KAAK;AAC9B,eAAO,YAAY;AAAA,MACrB;AACA,aAAO;AAAA,IACT;AACA,QAAI,cAAc,QAAQ,OAAO,KAAK,GAAG;AACvC,UAAI,MAAM,MAAM,IAAI,IAAI,IAAI,GAAG;AAC7B,eAAO,CAAC,EAAE,cAAc;AAAA,MAC1B,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI,cAAc,MAAM,OAAO,KAAK,GAAG;AACrC,aAAO;AAAA,IACT;AACA,WAAO,MAAM,oBAAoB,OAAO,MAAM,WAAW;AAAA,EAC3D;AAAA,EACA,iBAAiB,IAAI;AACnB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,KAAK,UAAU,IAAI;AAAG;AAC1B,UAAM,MAAM,KAAK,WAAW;AAC5B,aAAS,IAAI,MAAM,GAAG,KAAK,GAAG,KAAK;AACjC,YAAM,QAAQ,KAAK,WAAW,CAAC;AAC/B,YAAM,OAAO,MAAM,QAAQ,IAAI,IAAI;AACnC,WAAK,OAAO,KAAK,MAAM,OAAO,MAAM,GAAG;AACrC;AAAA,MACF;AAAA,IACF;AACA,UAAM,iBAAiB,EAAE;AAAA,EAC3B;AACF;AACA,MAAM,WAAW,CAAC,QAAQ,QAAQ,OAAO,eAAe,KAAK,QAAQ,GAAG,KAAK,OAAO,GAAG;AACvF,MAAM,gCAAgC,UAAQ;AAC5C,SAAO,KAAK,SAAS,4BAA4B,8BAA8B,KAAK,UAAU,IAAI;AACpG;AACA,MAAM,mBAAmB,UAAU;AAAA,EACjC,aAAa,MAAM,QAAQ,OAAO;AAChC,QAAI,aAAa;AACjB,QAAI,gBAAgB;AACpB,QAAI,KAAK,SAAS,8BAA8B,cAAc,KAAK,UAAU,QAAQ,YAAY,eAAe;AAC9G,sBAAgB,8BAA8B,IAAI;AAClD,UAAI,OAAO;AACT,YAAI,cAAc,SAAS,cAAc;AACvC,eAAK,gBAAgB,iCAAiC,OAAO,gCAAgC,IAAI;AAAA,QACnG,WAAW,cAAc,SAAS,sBAAsB,CAAC,KAAK,2BAA2B,aAAa,GAAG;AACvG,eAAK,MAAM,OAAO,gCAAgC,IAAI;AAAA,QACxD;AAAA,MACF,OAAO;AACL,aAAK,MAAM,OAAO,gCAAgC,IAAI;AAAA,MACxD;AAAA,IACF;AACA,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH;AAAA,MACF,KAAK;AACH,aAAK,OAAO;AACZ,iBAAS,IAAI,GAAG,SAAS,KAAK,WAAW,QAAQ,OAAO,SAAS,GAAG,IAAI,QAAQ,KAAK;AACnF,cAAI;AACJ,gBAAM,OAAO,KAAK,WAAW,CAAC;AAC9B,gBAAM,SAAS,MAAM;AACrB,eAAK,iCAAiC,MAAM,QAAQ,KAAK;AACzD,cAAI,UAAU,KAAK,SAAS,kBAAkB,eAAe,KAAK,UAAU,QAAQ,aAAa,kBAAkB;AACjH,iBAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,gBAAgB;AAAA,UAClE;AAAA,QACF;AACA;AAAA,MACF,KAAK,kBACH;AACE,cAAM;AAAA,UACJ;AAAA,UACA;AAAA,QACF,IAAI;AACJ,YAAI,KAAK,cAAc,GAAG,GAAG;AAC3B,eAAK,WAAW,eAAe,KAAK,iBAAiB,GAAG,GAAG,IAAI,IAAI,KAAK;AAAA,QAC1E;AACA,aAAK,aAAa,OAAO,KAAK;AAC9B;AAAA,MACF;AAAA,MACF,KAAK,iBACH;AACE,cAAM,IAAI,MAAM,8HAAmI;AAAA,MACrJ;AAAA,MACF,KAAK;AACH,aAAK,OAAO;AACZ,aAAK,iBAAiB,KAAK,WAAW,eAAe,KAAK,UAAU,OAAO,SAAS,aAAa,kBAAkB,KAAK;AACxH;AAAA,MACF,KAAK;AACH,YAAI,KAAK,aAAa,KAAK;AACzB,eAAK,MAAM,OAAO,uBAAuB,KAAK,KAAK,IAAI,GAAG;AAAA,QAC5D;AACA,aAAK,OAAO;AACZ,eAAO,KAAK;AACZ,aAAK,aAAa,KAAK,MAAM,KAAK;AAClC;AAAA,MACF,KAAK;AACH,aAAK,aAAa,eAAe,KAAK;AACtC;AAAA,IACJ;AAAA,EACF;AAAA,EACA,iCAAiC,MAAM,QAAQ,OAAO;AACpD,QAAI,KAAK,SAAS,gBAAgB;AAChC,WAAK,MAAM,KAAK,SAAS,SAAS,KAAK,SAAS,QAAQ,OAAO,qBAAqB,OAAO,kBAAkB,KAAK,GAAG;AAAA,IACvH,WAAW,KAAK,SAAS,iBAAiB;AACxC,WAAK,OAAO;AACZ,YAAM,MAAM,KAAK;AACjB,WAAK,sBAAsB,KAAK,KAAK;AACrC,WAAK,aAAa,KAAK,KAAK;AAC5B,UAAI,CAAC,QAAQ;AACX,aAAK,MAAM,OAAO,mBAAmB,IAAI;AAAA,MAC3C;AAAA,IACF,OAAO;AACL,WAAK,aAAa,MAAM,KAAK;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,iBAAiB,UAAU,kBAAkB,OAAO;AAClD,UAAM,MAAM,SAAS,SAAS;AAC9B,aAAS,IAAI,GAAG,KAAK,KAAK,KAAK;AAC7B,YAAM,MAAM,SAAS,CAAC;AACtB,UAAI,CAAC;AAAK;AACV,UAAI,IAAI,SAAS,iBAAiB;AAChC,YAAI,OAAO;AACX,cAAM,MAAM,IAAI;AAChB,aAAK,sBAAsB,KAAK,IAAI;AACpC,aAAK,aAAa,KAAK,KAAK;AAAA,MAC9B,OAAO;AACL,aAAK,aAAa,KAAK,KAAK;AAAA,MAC9B;AACA,UAAI,IAAI,SAAS,eAAe;AAC9B,YAAI,IAAI,KAAK;AACX,eAAK,MAAM,OAAO,mBAAmB,GAAG;AAAA,QAC1C,WAAW,kBAAkB;AAC3B,eAAK,MAAM,OAAO,mBAAmB,gBAAgB;AAAA,QACvD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,aAAa,MAAM,WAAW;AAC5B,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK,oBACH;AACE,cAAM,OAAO,KAAK,WAAW,SAAS;AACtC,eAAO,KAAK,WAAW,MAAM,CAAC,MAAM,MAAM;AACxC,iBAAO,KAAK,SAAS,mBAAmB,MAAM,QAAQ,KAAK,SAAS,oBAAoB,KAAK,aAAa,IAAI;AAAA,QAChH,CAAC;AAAA,MACH;AAAA,MACF,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,KAAK;AAAA,MACrC,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,QAAQ;AAAA,MACxC,KAAK;AACH,eAAO,KAAK,SAAS,MAAM,aAAW,YAAY,QAAQ,KAAK,aAAa,OAAO,CAAC;AAAA,MACtF,KAAK;AACH,eAAO,KAAK,aAAa;AAAA,MAC3B,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,UAAU;AAAA,MAC1C,KAAK;AAAA,MACL,KAAK;AACH,eAAO,CAAC;AAAA,MACV;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EACA,iBAAiB,UAAU,qBAAqB;AAC9C,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB,UAAU,qBAAqB;AAClD,SAAK,iBAAiB,UAAU,mBAAmB;AACnD,eAAW,QAAQ,UAAU;AAC3B,WAAK,QAAQ,OAAO,SAAS,KAAK,UAAU,mBAAmB;AAC7D,aAAK,qBAAqB,KAAK,QAAQ;AAAA,MACzC;AAAA,IACF;AAAA,EACF;AAAA,EACA,YAAY,qBAAqB;AAC/B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,SAAK,WAAW,KAAK,wBAAwB,qBAAqB,MAAS;AAC3E,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,SAAK,WAAW,KAAK,iBAAiB;AACtC,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,mBAAmB;AACjB,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK,GACH;AACE,cAAM,OAAO,KAAK,UAAU;AAC5B,aAAK,KAAK;AACV,aAAK,WAAW,KAAK,iBAAiB,GAAG,IAAI,CAAC;AAC9C,eAAO,KAAK,WAAW,MAAM,cAAc;AAAA,MAC7C;AAAA,MACF,KAAK;AACH,eAAO,KAAK,gBAAgB,GAAG,IAAI;AAAA,IACvC;AACA,WAAO,KAAK,gBAAgB;AAAA,EAC9B;AAAA,EACA,iBAAiB,OAAO,eAAe,OAAO;AAC5C,UAAM,aAAa,QAAQ;AAC3B,UAAM,OAAO,CAAC;AACd,QAAI,QAAQ;AACZ,WAAO,CAAC,KAAK,IAAI,KAAK,GAAG;AACvB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,aAAK,OAAO,EAAE;AAAA,MAChB;AACA,UAAI,cAAc,KAAK,MAAM,EAAE,GAAG;AAChC,aAAK,KAAK,IAAI;AAAA,MAChB,WAAW,KAAK,IAAI,KAAK,GAAG;AAC1B;AAAA,MACF,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,aAAK,KAAK,KAAK,6BAA6B,KAAK,iBAAiB,GAAG,KAAK,CAAC;AAC3E,YAAI,CAAC,KAAK,oBAAoB,aAAa,GAAG;AAC5C,eAAK,OAAO,KAAK;AACjB;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM,aAAa,CAAC;AACpB,YAAI,KAAK,MAAM,EAAE,KAAK,KAAK,UAAU,YAAY,GAAG;AAClD,eAAK,MAAM,OAAO,+BAA+B,KAAK,MAAM,QAAQ;AAAA,QACtE;AACA,eAAO,KAAK,MAAM,EAAE,GAAG;AACrB,qBAAW,KAAK,KAAK,eAAe,CAAC;AAAA,QACvC;AACA,aAAK,KAAK,KAAK,wBAAwB,OAAO,UAAU,CAAC;AAAA,MAC3D;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,yBAAyB,MAAM;AAC7B,SAAK,KAAK;AACV,SAAK,WAAW,KAAK,gBAAgB;AACrC,SAAK,oBAAoB,GAAG;AAC5B,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,uBAAuB;AACrB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAAS,IAAI;AACf,aAAO,KAAK,yBAAyB,IAAI;AAAA,IAC3C,WAAW,SAAS,KAAK;AACvB,WAAK,aAAa,wBAAwB,QAAQ;AAClD,WAAK,WAAW,eAAe,KAAK,MAAM,OAAO,QAAQ;AACzD,WAAK,MAAM,KAAK,iBAAiB;AAAA,IACnC,OAAO;AACL,WAAK,kBAAkB,IAAI;AAAA,IAC7B;AACA,SAAK,SAAS;AACd,WAAO,KAAK,kBAAkB,MAAM,UAAU,OAAO,OAAO,MAAM,KAAK;AAAA,EACzE;AAAA,EACA,wBAAwB,OAAO,YAAY;AACzC,UAAM,OAAO,KAAK,kBAAkB;AACpC,SAAK,6BAA6B,MAAM,KAAK;AAC7C,UAAM,MAAM,KAAK,kBAAkB,KAAK,IAAI,OAAO,IAAI;AACvD,QAAI,WAAW,QAAQ;AACrB,WAAK,aAAa;AAAA,IACpB;AACA,WAAO;AAAA,EACT;AAAA,EACA,6BAA6B,OAAO,OAAO;AACzC,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,UAAU,MAAM;AAChC,QAAI,WAAW;AACf,KAAC,YAAY,aAAa,OAAO,YAAY,WAAW,KAAK,MAAM;AACnE,YAAQ,QAAQ,SAAS,OAAO,QAAQ,KAAK,iBAAiB;AAC9D,QAAI,CAAC,KAAK,IAAI,EAAE;AAAG,aAAO;AAC1B,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,OAAO;AACZ,SAAK,QAAQ,KAAK,wBAAwB;AAC1C,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,YAAY,MAAM,2BAA2B,SAAS;AACpD,WAAO,SAAS;AAAA,MACd,mBAAmB;AAAA,MACnB,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,yBAAyB;AAAA,MACzB,cAAc;AAAA,MACd,eAAe;AAAA,IACjB,GAAG,IAAI;AAAA,EACT;AAAA,EACA,2BAA2B,YAAY;AACrC,WAAO,WAAW,SAAS;AAAA,EAC7B;AAAA,EACA,UAAU,YAAY;AAAA,IACpB,IAAI;AAAA,IACJ,UAAU;AAAA,IACV,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB,2BAA2B;AAAA,EAC7B,GAAG;AACD,QAAI;AACJ,UAAM,OAAO,WAAW;AACxB,QAAI,KAAK,eAAe,UAAU;AAAG;AACrC,UAAM,6BAA6B,KAAK,2BAA2B,UAAU;AAC7E,QAAI,8BAA8B,SAAS,oBAAoB;AAC7D,UAAI,4BAA4B;AAC9B,aAAK,aAAa,0BAA0B,WAAW,IAAI,KAAK;AAChE,YAAI,SAAS,SAAS,wBAAwB;AAC5C,eAAK,MAAM,OAAO,4BAA4B,YAAY;AAAA,YACxD;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AACA,UAAI,YAAY,IAAI;AAClB,aAAK,MAAM,OAAO,+BAA+B,UAAU;AAAA,MAC7D;AACA;AAAA,IACF;AACA,QAAI,SAAS,cAAc;AACzB,WAAK,gBAAgB,YAAY,SAAS,iBAAiB;AAC3D,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,UAAI,cAAc;AAChB,YAAI,aAAa,IAAI,IAAI,GAAG;AAC1B,eAAK,MAAM,OAAO,WAAW,UAAU;AAAA,QACzC,OAAO;AACL,uBAAa,IAAI,IAAI;AAAA,QACvB;AAAA,MACF;AACA;AAAA,IACF;AACA,UAAM,WAAW,KAAK,YAAY,MAAM,EAAE,6BAA6B,oBAAoB,WAAW,UAAU,QAAQ,kBAAkB,kBAAkB,SAAS,SAAS,wBAAwB,OAAO;AAC7M,QAAI,aAAa;AAAM;AACvB,QAAI,aAAa,OAAO;AACtB,YAAM,kBAAkB,YAAY,KAAK,OAAO,aAAa,OAAO;AACpE,WAAK,MAAM,iBAAiB,YAAY;AAAA,QACtC;AAAA,MACF,CAAC;AACD;AAAA,IACF;AACA,UAAM,CAAC,KAAK,yBAAyB,IAAI,MAAM,QAAQ,QAAQ,IAAI,WAAW,CAAC,UAAU,SAAS,yBAAyB;AAC3H,UAAM,eAAe,SAAS,kBAAkB,SAAS,kBAAkB;AAAA,MACzE;AAAA,IACF,IAAI;AACJ,eAAW,SAAS,CAAC,EAAE,OAAO,WAAW,GAAG,CAAC,GAAG;AAC9C,UAAI,OAAO;AACT,aAAK,UAAU,OAAO;AAAA,UACpB,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA,0BAA0B;AAAA,QAC5B,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EACA,gBAAgB,IAAI,aAAa,oBAAoB,OAAO;AAC1D,QAAI,KAAK,MAAM,WAAW,oBAAoB,yBAAyB,GAAG,MAAM,KAAK,QAAQ,IAAI,6BAA6B,GAAG,IAAI,IAAI;AACvI,UAAI,gBAAgB,IAAI;AACtB,aAAK,MAAM,OAAO,qBAAqB,IAAI;AAAA,UACzC,eAAe,GAAG;AAAA,QACpB,CAAC;AAAA,MACH,OAAO;AACL,aAAK,MAAM,OAAO,4BAA4B,IAAI;AAAA,UAChD,aAAa,GAAG;AAAA,QAClB,CAAC;AAAA,MACH;AAAA,IACF;AACA,QAAI,cAAc,QAAQ,GAAG,SAAS,OAAO;AAC3C,WAAK,MAAM,OAAO,qBAAqB,EAAE;AAAA,IAC3C;AACA,QAAI,EAAE,cAAc,KAAK;AACvB,WAAK,0BAA0B,IAAI,WAAW;AAAA,IAChD;AAAA,EACF;AAAA,EACA,0BAA0B,YAAY,SAAS;AAC7C,SAAK,MAAM,YAAY,WAAW,MAAM,SAAS,WAAW,IAAI,KAAK;AAAA,EACvE;AAAA,EACA,sBAAsB,MAAM,cAAc;AACxC,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,aAAK,sBAAsB,KAAK,YAAY,YAAY;AACxD;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,YAAI;AAAc;AAAA,MACpB;AACE,aAAK,MAAM,OAAO,8BAA8B,IAAI;AAAA,IACxD;AAAA,EACF;AAAA,EACA,oBAAoB,OAAO;AACzB,QAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAO;AAAA,IACT;AACA,SAAK,MAAM,KAAK,kBAAkB,MAAM,QAAQ,OAAO,oBAAoB,OAAO,kBAAkB,KAAK,MAAM,QAAQ;AACvH,WAAO;AAAA,EACT;AACF;AACA,MAAM,SAAS,CAAC,QAAQ,QAAQ,OAAO,eAAe,KAAK,QAAQ,GAAG,KAAK,OAAO,GAAG;AACrF,SAAS,QAAQ,GAAG;AAClB,MAAI,KAAK,MAAM;AACb,UAAM,IAAI,MAAM,cAAc,CAAC,SAAS;AAAA,EAC1C;AACA,SAAO;AACT;AACA,SAAS,OAAO,GAAG;AACjB,MAAI,CAAC,GAAG;AACN,UAAM,IAAI,MAAM,aAAa;AAAA,EAC/B;AACF;AACA,MAAM,WAAW,2BAA2B;AAAA,EAC1C,iCAAiC,CAAC;AAAA,IAChC;AAAA,EACF,MAAM,WAAW,UAAU;AAAA,EAC3B,gCAAgC,CAAC;AAAA,IAC/B;AAAA,EACF,MAAM,aAAa,YAAY;AAAA,EAC/B,mCAAmC;AAAA,EACnC,iCAAiC;AAAA,EACjC,0BAA0B;AAAA,EAC1B,uBAAuB;AAAA,EACvB,wBAAwB;AAAA,EACxB,qEAAqE;AAAA,EACrE,8BAA8B;AAAA,EAC9B,iBAAiB,CAAC;AAAA,IAChB;AAAA,EACF,MAAM,+BAA+B,IAAI;AAAA,EACzC,iCAAiC;AAAA,EACjC,kCAAkC;AAAA,EAClC,gCAAgC,CAAC;AAAA,IAC/B;AAAA,EACF,MAAM;AAAA,EACN,mBAAmB,CAAC;AAAA,IAClB;AAAA,EACF,MAAM,wBAAwB,QAAQ;AAAA,EACtC,yBAAyB,CAAC;AAAA,IACxB;AAAA,EACF,MAAM,IAAI,KAAK;AAAA,EACf,oBAAoB;AAAA,EACpB,qBAAqB;AAAA,EACrB,mCAAmC;AAAA,EACnC,0BAA0B;AAAA,EAC1B,+BAA+B;AAAA,EAC/B,uBAAuB,CAAC;AAAA,IACtB;AAAA,EACF,MAAM,IAAI,UAAU,CAAC,CAAC,mCAAmC,UAAU,CAAC,CAAC;AAAA,EACrE,2BAA2B;AAAA,EAC3B,gCAAgC,CAAC;AAAA,IAC/B;AAAA,EACF,MAAM,4DAA4D,QAAQ;AAAA,EAC1E,0BAA0B;AAAA,EAC1B,2BAA2B;AAAA,EAC3B,yBAAyB;AAAA,EACzB,uCAAuC;AAAA,EACvC,6BAA6B,CAAC;AAAA,IAC5B;AAAA,EACF,MAAM,IAAI,QAAQ;AAAA,EAClB,gCAAgC,CAAC;AAAA,IAC/B;AAAA,EACF,MAAM,IAAI,QAAQ;AAAA,EAClB,yCAAyC,CAAC;AAAA,IACxC;AAAA,EACF,MAAM,IAAI,QAAQ;AAAA,EAClB,uBAAuB,CAAC;AAAA,IACtB;AAAA,EACF,MAAM,IAAI,iBAAiB,CAAC,CAAC,4BAA4B,iBAAiB,CAAC,CAAC;AAAA,EAC5E,mDAAmD;AAAA,EACnD,yBAAyB;AAAA,EACzB,sBAAsB;AAAA,EACtB,mCAAmC;AAAA,EACnC,0CAA0C;AAAA,EAC1C,4BAA4B;AAAA,EAC5B,uBAAuB;AAAA,EACvB,mBAAmB;AAAA,EACnB,2BAA2B;AAAA,EAC3B,gCAAgC,CAAC;AAAA,IAC/B;AAAA,EACF,MAAM,4DAA4D,QAAQ;AAAA,EAC1E,4BAA4B;AAAA,EAC5B,wBAAwB;AAAA,EACxB,uBAAuB;AAAA,EACvB,uCAAuC;AAAA,EACvC,mCAAmC;AAAA,EACnC,gCAAgC;AAAA,EAChC,yCAAyC,CAAC;AAAA,IACxC;AAAA,EACF,MAAM,yBAAyB,iBAAiB,kDAAkD,iBAAiB;AAAA,EACnH,+BAA+B;AAAA,EAC/B,wBAAwB;AAAA,EACxB,2BAA2B;AAAA,EAC3B,wCAAwC;AAAA,EACxC,iCAAiC;AAAA,EACjC,iCAAiC;AAAA,EACjC,6BAA6B;AAAA,EAC7B,oBAAoB;AAAA,EACpB,0BAA0B;AAAA,EAC1B,+BAA+B;AAAA,EAC/B,+BAA+B;AAAA,EAC/B,kCAAkC;AAAA,EAClC,mCAAmC,CAAC;AAAA,IAClC;AAAA,EACF,MAAM,yFAAyF,IAAI;AACrG,CAAC;AACD,SAAS,oBAAoB,OAAO;AAClC,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AACA,SAAS,mBAAmB,UAAU;AACpC,SAAO,aAAa,aAAa,aAAa,YAAY,aAAa;AACzE;AACA,SAAS,wBAAwB,UAAU;AACzC,SAAO,aAAa,QAAQ,aAAa;AAC3C;AACA,IAAI,aAAa,gBAAc,MAAM,8BAA8B,WAAW;AAAA,EAC5E,eAAe,MAAM;AACnB,UAAM,GAAG,IAAI;AACb,SAAK,wBAAwB,KAAK,iBAAiB,KAAK,MAAM;AAAA,MAC5D,kBAAkB,CAAC,MAAM,KAAK;AAAA,MAC9B,qBAAqB,CAAC,SAAS,UAAU,WAAW,aAAa,YAAY,WAAW,YAAY,UAAU;AAAA,MAC9G,eAAe,SAAS;AAAA,IAC1B,CAAC;AACD,SAAK,uBAAuB,KAAK,iBAAiB,KAAK,MAAM;AAAA,MAC3D,kBAAkB,CAAC,OAAO;AAAA,MAC1B,qBAAqB,CAAC,MAAM,KAAK;AAAA,MACjC,eAAe,SAAS;AAAA,IAC1B,CAAC;AACD,SAAK,6BAA6B,KAAK,iBAAiB,KAAK,MAAM;AAAA,MACjE,kBAAkB,CAAC,MAAM,OAAO,OAAO;AAAA,MACvC,qBAAqB,CAAC,UAAU,WAAW,aAAa,YAAY,WAAW,YAAY,UAAU;AAAA,MACrG,eAAe,SAAS;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA,EACA,kBAAkB;AAChB,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AACf,WAAO,kBAAkB,KAAK,MAAM,IAAI;AAAA,EAC1C;AAAA,EACA,2BAA2B;AACzB,YAAQ,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,GAAG,KAAK,KAAK,sBAAsB,MAAM,CAAC,KAAK,sBAAsB;AAAA,EAChK;AAAA,EACA,+BAA+B;AAC7B,SAAK,KAAK;AACV,WAAO,KAAK,yBAAyB;AAAA,EACvC;AAAA,EACA,gBAAgB,kBAAkB,+BAA+B;AAC/D,QAAI,CAAC,kBAAkB,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,SAAS,MAAM,KAAK,MAAM,SAAS,IAAI;AAC3F,aAAO;AAAA,IACT;AACA,UAAM,WAAW,KAAK,MAAM;AAC5B,QAAI,iBAAiB,QAAQ,QAAQ,MAAM,IAAI;AAC7C,UAAI,iCAAiC,KAAK,wBAAwB,GAAG;AACnE,eAAO;AAAA,MACT;AACA,UAAI,KAAK,WAAW,KAAK,6BAA6B,KAAK,IAAI,CAAC,GAAG;AACjE,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA,gBAAgB,SAAS;AAAA,EAC3B,GAAG,UAAU;AACX,UAAM,eAAe,CAAC,KAAK,UAAU,QAAQ,UAAU;AACrD,UAAI,aAAa,UAAU,SAAS,KAAK,GAAG;AAC1C,aAAK,MAAM,SAAS,uBAAuB,KAAK;AAAA,UAC9C,kBAAkB,CAAC,QAAQ,KAAK;AAAA,QAClC,CAAC;AAAA,MACH;AAAA,IACF;AACA,UAAM,eAAe,CAAC,KAAK,UAAU,MAAM,SAAS;AAClD,UAAI,SAAS,IAAI,KAAK,aAAa,QAAQ,SAAS,IAAI,KAAK,aAAa,MAAM;AAC9E,aAAK,MAAM,SAAS,uBAAuB,KAAK;AAAA,UAC9C,WAAW,CAAC,MAAM,IAAI;AAAA,QACxB,CAAC;AAAA,MACH;AAAA,IACF;AACA,eAAS;AACP,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK;AACT,YAAM,WAAW,KAAK,gBAAgB,iBAAiB,OAAO,uBAAuB,OAAO,sBAAsB,CAAC,CAAC,GAAG,6BAA6B;AACpJ,UAAI,CAAC;AAAU;AACf,UAAI,mBAAmB,QAAQ,GAAG;AAChC,YAAI,SAAS,eAAe;AAC1B,eAAK,MAAM,SAAS,gCAAgC,UAAU;AAAA,YAC5D;AAAA,UACF,CAAC;AAAA,QACH,OAAO;AACL,uBAAa,UAAU,UAAU,UAAU,UAAU;AACrD,uBAAa,UAAU,UAAU,UAAU,QAAQ;AACnD,uBAAa,UAAU,UAAU,UAAU,UAAU;AACrD,mBAAS,gBAAgB;AAAA,QAC3B;AAAA,MACF,WAAW,wBAAwB,QAAQ,GAAG;AAC5C,YAAI,SAAS,QAAQ,GAAG;AACtB,eAAK,MAAM,SAAS,mBAAmB,UAAU;AAAA,YAC/C;AAAA,UACF,CAAC;AAAA,QACH;AACA,iBAAS,QAAQ,IAAI;AACrB,qBAAa,UAAU,UAAU,MAAM,KAAK;AAAA,MAC9C,OAAO;AACL,YAAI,OAAO,eAAe,KAAK,UAAU,QAAQ,GAAG;AAClD,eAAK,MAAM,SAAS,mBAAmB,UAAU;AAAA,YAC/C;AAAA,UACF,CAAC;AAAA,QACH,OAAO;AACL,uBAAa,UAAU,UAAU,UAAU,UAAU;AACrD,uBAAa,UAAU,UAAU,UAAU,UAAU;AACrD,uBAAa,UAAU,UAAU,YAAY,UAAU;AACvD,uBAAa,UAAU,UAAU,YAAY,UAAU;AACvD,uBAAa,UAAU,UAAU,WAAW,UAAU;AACtD,uBAAa,UAAU,UAAU,UAAU,UAAU;AAAA,QACvD;AACA,iBAAS,QAAQ,IAAI;AAAA,MACvB;AACA,UAAI,uBAAuB,QAAQ,oBAAoB,SAAS,QAAQ,GAAG;AACzE,aAAK,MAAM,eAAe,UAAU;AAAA,UAClC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EACA,mBAAmB,MAAM;AACvB,YAAQ,MAAM;AAAA,MACZ,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,MAAM,CAAC;AAAA,MACrB,KAAK;AACH,eAAO,KAAK,MAAM,CAAC;AAAA,MACrB,KAAK;AACH,eAAO,KAAK,MAAM,CAAC;AAAA,MACrB,KAAK;AACH,eAAO,KAAK,MAAM,EAAE;AAAA,IACxB;AAAA,EACF;AAAA,EACA,YAAY,MAAM,cAAc;AAC9B,UAAM,SAAS,CAAC;AAChB,WAAO,CAAC,KAAK,mBAAmB,IAAI,GAAG;AACrC,aAAO,KAAK,aAAa,CAAC;AAAA,IAC5B;AACA,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB,MAAM,cAAc,qBAAqB;AAC5D,WAAO,QAAQ,KAAK,2BAA2B,MAAM,cAAc,MAAM,mBAAmB,CAAC;AAAA,EAC/F;AAAA,EACA,2BAA2B,MAAM,cAAc,eAAe,qBAAqB;AACjF,UAAM,SAAS,CAAC;AAChB,QAAI,mBAAmB;AACvB,eAAS;AACP,UAAI,KAAK,mBAAmB,IAAI,GAAG;AACjC;AAAA,MACF;AACA,yBAAmB;AACnB,YAAM,UAAU,aAAa;AAC7B,UAAI,WAAW,MAAM;AACnB,eAAO;AAAA,MACT;AACA,aAAO,KAAK,OAAO;AACnB,UAAI,KAAK,IAAI,EAAE,GAAG;AAChB,2BAAmB,KAAK,MAAM,gBAAgB;AAC9C;AAAA,MACF;AACA,UAAI,KAAK,mBAAmB,IAAI,GAAG;AACjC;AAAA,MACF;AACA,UAAI,eAAe;AACjB,aAAK,OAAO,EAAE;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AACA,QAAI,qBAAqB;AACvB,0BAAoB,QAAQ;AAAA,IAC9B;AACA,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB,MAAM,cAAc,SAAS,gBAAgB,qBAAqB;AACrF,QAAI,CAAC,gBAAgB;AACnB,UAAI,SAAS;AACX,aAAK,OAAO,CAAC;AAAA,MACf,OAAO;AACL,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AACA,UAAM,SAAS,KAAK,qBAAqB,MAAM,cAAc,mBAAmB;AAChF,QAAI,SAAS;AACX,WAAK,OAAO,CAAC;AAAA,IACf,OAAO;AACL,WAAK,OAAO,EAAE;AAAA,IAChB;AACA,WAAO;AAAA,EACT;AAAA,EACA,oBAAoB;AAClB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,EAAE;AACd,SAAK,OAAO,EAAE;AACd,QAAI,CAAC,KAAK,MAAM,GAAG,GAAG;AACpB,WAAK,MAAM,SAAS,+BAA+B,KAAK,MAAM,QAAQ;AAAA,IACxE;AACA,SAAK,WAAW,MAAM,cAAc;AACpC,SAAK,OAAO,EAAE;AACd,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,YAAY,KAAK,kBAAkB;AAAA,IAC1C;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,iBAAiB,KAAK,qBAAqB;AAAA,IAClD;AACA,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,kBAAkB,qBAAqB,MAAM;AAC3C,QAAI,SAAS,KAAK,gBAAgB,kBAAkB;AACpD,WAAO,KAAK,IAAI,EAAE,GAAG;AACnB,YAAM,OAAO,KAAK,gBAAgB,MAAM;AACxC,WAAK,OAAO;AACZ,WAAK,QAAQ,KAAK,gBAAgB,kBAAkB;AACpD,eAAS,KAAK,WAAW,MAAM,iBAAiB;AAAA,IAClD;AACA,WAAO;AAAA,EACT;AAAA,EACA,uBAAuB;AACrB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,WAAW,KAAK,kBAAkB;AACvC,QAAI,CAAC,KAAK,sBAAsB,KAAK,KAAK,MAAM,EAAE,GAAG;AACnD,WAAK,iBAAiB,KAAK,qBAAqB;AAAA,IAClD;AACA,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,yBAAyB,KAAK;AAC5B,SAAK,KAAK;AACV,UAAM,OAAO,KAAK,gBAAgB,GAAG;AACrC,SAAK,gBAAgB;AACrB,SAAK,iBAAiB,KAAK,sBAAsB,KAAK;AACtD,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,sBAAsB;AACpB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,YAAY;AAAA,EAC3C;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,EAAE;AACd,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,WAAW,KAAK,kBAAkB;AAAA,IACzC,OAAO;AACL,WAAK,WAAW,KAAK,kBAAkB;AAAA,IACzC;AACA,QAAI,CAAC,KAAK,sBAAsB,KAAK,KAAK,MAAM,EAAE,GAAG;AACnD,WAAK,iBAAiB,KAAK,qBAAqB;AAAA,IAClD;AACA,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,qBAAqB,gBAAgB;AACnC,UAAM,OAAO,KAAK,UAAU;AAC5B,mBAAe,IAAI;AACnB,SAAK,OAAO,KAAK,yBAAyB;AAC1C,SAAK,aAAa,KAAK,mBAAmB,EAAE;AAC5C,SAAK,UAAU,KAAK,mBAAmB,EAAE;AACzC,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,yBAAyB,gBAAgB;AACvC,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,KAAK,sBAAsB,cAAc;AAAA,IAClD;AAAA,EACF;AAAA,EACA,sBAAsB,gBAAgB;AACpC,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,GAAG,GAAG;AACrC,WAAK,KAAK;AAAA,IACZ,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AACA,UAAM,sBAAsB;AAAA,MAC1B,OAAO;AAAA,IACT;AACA,SAAK,SAAS,KAAK,qBAAqB,6BAA6B,KAAK,qBAAqB,KAAK,MAAM,cAAc,GAAG,OAAO,MAAM,mBAAmB;AAC3J,QAAI,KAAK,OAAO,WAAW,GAAG;AAC5B,WAAK,MAAM,SAAS,qBAAqB,IAAI;AAAA,IAC/C;AACA,QAAI,oBAAoB,UAAU,IAAI;AACpC,WAAK,SAAS,MAAM,iBAAiB,oBAAoB,KAAK;AAAA,IAChE;AACA,WAAO,KAAK,WAAW,MAAM,4BAA4B;AAAA,EAC3D;AAAA,EACA,gBAAgB,aAAa,WAAW;AACtC,UAAM,sBAAsB,gBAAgB;AAC5C,UAAM,YAAY;AAClB,UAAM,gBAAgB;AACtB,cAAU,iBAAiB,KAAK,yBAAyB,KAAK,oBAAoB;AAClF,SAAK,OAAO,EAAE;AACd,cAAU,SAAS,IAAI,KAAK,+BAA+B;AAC3D,QAAI,qBAAqB;AACvB,gBAAU,aAAa,IAAI,KAAK,qCAAqC,WAAW;AAAA,IAClF,WAAW,KAAK,MAAM,WAAW,GAAG;AAClC,gBAAU,aAAa,IAAI,KAAK,qCAAqC,WAAW;AAAA,IAClF;AAAA,EACF;AAAA,EACA,iCAAiC;AAC/B,UAAM,OAAO,MAAM,iBAAiB,IAAI,IAAI,CAAC;AAC7C,eAAW,WAAW,MAAM;AAC1B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,UAAI,SAAS,uBAAuB,SAAS,uBAAuB;AAClE,aAAK,MAAM,SAAS,mCAAmC,SAAS;AAAA,UAC9D;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,6BAA6B;AAC3B,QAAI,CAAC,KAAK,IAAI,EAAE,KAAK,CAAC,KAAK,iBAAiB,GAAG;AAC7C,WAAK,OAAO,EAAE;AAAA,IAChB;AAAA,EACF;AAAA,EACA,uBAAuB,MAAM,MAAM;AACjC,SAAK,gBAAgB,IAAI,IAAI;AAC7B,SAAK,2BAA2B;AAChC,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,kCAAkC;AAChC,SAAK,KAAK;AACV,QAAI,kBAAkB,KAAK,MAAM,IAAI,GAAG;AACtC,WAAK,KAAK;AACV,aAAO,KAAK,MAAM,EAAE;AAAA,IACtB;AACA,WAAO;AAAA,EACT;AAAA,EACA,yBAAyB,MAAM;AAC7B,QAAI,EAAE,KAAK,MAAM,CAAC,KAAK,KAAK,YAAY,KAAK,gCAAgC,KAAK,IAAI,CAAC,IAAI;AACzF;AAAA,IACF;AACA,SAAK,OAAO,CAAC;AACb,UAAM,KAAK,KAAK,gBAAgB;AAChC,OAAG,iBAAiB,KAAK,sBAAsB;AAC/C,SAAK,iBAAiB,EAAE;AACxB,SAAK,OAAO,CAAC;AACb,SAAK,aAAa,CAAC,EAAE;AACrB,UAAM,OAAO,KAAK,yBAAyB;AAC3C,QAAI;AAAM,WAAK,iBAAiB;AAChC,SAAK,2BAA2B;AAChC,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,iCAAiC,MAAM,UAAU;AAC/C,QAAI,KAAK,IAAI,EAAE;AAAG,WAAK,WAAW;AAClC,UAAM,UAAU;AAChB,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,UAAI,UAAU;AACZ,aAAK,MAAM,SAAS,4BAA4B,IAAI;AAAA,MACtD;AACA,YAAM,SAAS;AACf,UAAI,OAAO,QAAQ,KAAK,MAAM,EAAE,GAAG;AACjC,aAAK,MAAM,SAAS,iCAAiC,KAAK,MAAM,YAAY,CAAC;AAAA,MAC/E;AACA,WAAK,gBAAgB,IAAI,MAAM;AAC/B,WAAK,2BAA2B;AAChC,YAAM,YAAY;AAClB,YAAM,gBAAgB;AACtB,UAAI,OAAO,SAAS,OAAO;AACzB,YAAI,OAAO,SAAS,EAAE,SAAS,GAAG;AAChC,eAAK,MAAM,OAAO,gBAAgB,KAAK,MAAM,YAAY,CAAC;AAC1D,cAAI,KAAK,YAAY,OAAO,SAAS,EAAE,CAAC,CAAC,GAAG;AAC1C,iBAAK,MAAM,SAAS,mCAAmC,KAAK,MAAM,YAAY,CAAC;AAAA,UACjF;AAAA,QACF;AAAA,MACF,WAAW,OAAO,SAAS,OAAO;AAChC,YAAI,OAAO,SAAS,EAAE,WAAW,GAAG;AAClC,eAAK,MAAM,OAAO,gBAAgB,KAAK,MAAM,YAAY,CAAC;AAAA,QAC5D,OAAO;AACL,gBAAM,iBAAiB,OAAO,SAAS,EAAE,CAAC;AAC1C,cAAI,KAAK,YAAY,cAAc,GAAG;AACpC,iBAAK,MAAM,SAAS,mCAAmC,KAAK,MAAM,YAAY,CAAC;AAAA,UACjF;AACA,cAAI,eAAe,SAAS,gBAAgB,eAAe,UAAU;AACnE,iBAAK,MAAM,SAAS,uCAAuC,KAAK,MAAM,YAAY,CAAC;AAAA,UACrF;AACA,cAAI,eAAe,SAAS,eAAe;AACzC,iBAAK,MAAM,SAAS,mCAAmC,KAAK,MAAM,YAAY,CAAC;AAAA,UACjF;AAAA,QACF;AACA,YAAI,OAAO,aAAa,GAAG;AACzB,eAAK,MAAM,SAAS,gCAAgC,OAAO,aAAa,CAAC;AAAA,QAC3E;AAAA,MACF,OAAO;AACL,eAAO,OAAO;AAAA,MAChB;AACA,aAAO,KAAK,WAAW,QAAQ,mBAAmB;AAAA,IACpD,OAAO;AACL,YAAM,WAAW;AACjB,UAAI;AAAU,iBAAS,WAAW;AAClC,YAAM,OAAO,KAAK,yBAAyB;AAC3C,UAAI;AAAM,iBAAS,iBAAiB;AACpC,WAAK,2BAA2B;AAChC,aAAO,KAAK,WAAW,UAAU,qBAAqB;AAAA,IACxD;AAAA,EACF;AAAA,EACA,oBAAoB;AAClB,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,aAAO,KAAK,uBAAuB,8BAA8B,IAAI;AAAA,IACvE;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,KAAK,KAAK,UAAU;AAC1B,WAAK,KAAK;AACV,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,eAAO,KAAK,uBAAuB,mCAAmC,IAAI;AAAA,MAC5E,OAAO;AACL,aAAK,MAAM,KAAK,iBAAiB,IAAI,KAAK;AAC1C,eAAO,KAAK,iCAAiC,MAAM,KAAK;AAAA,MAC1D;AAAA,IACF;AACA,SAAK,iBAAiB;AAAA,MACpB,kBAAkB,CAAC,UAAU;AAAA,MAC7B,qBAAqB,CAAC,WAAW,YAAY,WAAW,aAAa,UAAU,UAAU,UAAU;AAAA,IACrG,GAAG,IAAI;AACP,UAAM,MAAM,KAAK,yBAAyB,IAAI;AAC9C,QAAI,KAAK;AACP,aAAO;AAAA,IACT;AACA,UAAM,kBAAkB,IAAI;AAC5B,QAAI,CAAC,KAAK,YAAY,KAAK,IAAI,SAAS,iBAAiB,KAAK,IAAI,SAAS,SAAS,KAAK,IAAI,SAAS,UAAU,KAAK,yBAAyB,GAAG;AAC/I,WAAK,OAAO,KAAK,IAAI;AACrB,YAAM,kBAAkB,IAAI;AAAA,IAC9B;AACA,WAAO,KAAK,iCAAiC,MAAM,CAAC,CAAC,KAAK,QAAQ;AAAA,EACpE;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,UAAU,KAAK,yBAAyB;AAC7C,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,2BAA2B;AACzB,SAAK,OAAO,CAAC;AACb,UAAM,UAAU,KAAK,YAAY,eAAe,KAAK,kBAAkB,KAAK,IAAI,CAAC;AACjF,SAAK,OAAO,CAAC;AACb,WAAO;AAAA,EACT;AAAA,EACA,wBAAwB;AACtB,SAAK,KAAK;AACV,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,aAAO,KAAK,aAAa,GAAG;AAAA,IAC9B;AACA,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,WAAK,KAAK;AAAA,IACZ;AACA,QAAI,CAAC,KAAK,MAAM,CAAC,GAAG;AAClB,aAAO;AAAA,IACT;AACA,SAAK,KAAK;AACV,QAAI,CAAC,KAAK,eAAe,GAAG;AAC1B,aAAO;AAAA,IACT;AACA,SAAK,KAAK;AACV,WAAO,KAAK,MAAM,EAAE;AAAA,EACtB;AAAA,EACA,6BAA6B;AAC3B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,KAAK,yBAAyB;AAC1C,SAAK,aAAa,KAAK,sBAAsB,EAAE;AAC/C,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,oBAAoB;AAClB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,CAAC;AACb,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,WAAW,KAAK,MAAM;AAC3B,WAAK,KAAK;AACV,WAAK,iBAAiB,GAAG;AAAA,IAC3B,WAAW,KAAK,cAAc,GAAG,GAAG;AAClC,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,OAAO,CAAC;AACb,SAAK,gBAAgB,KAAK,2BAA2B;AACrD,SAAK,WAAW,KAAK,cAAc,EAAE,IAAI,KAAK,YAAY,IAAI;AAC9D,SAAK,OAAO,CAAC;AACb,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,WAAW,KAAK,MAAM;AAC3B,WAAK,KAAK;AACV,WAAK,OAAO,EAAE;AAAA,IAChB,WAAW,KAAK,IAAI,EAAE,GAAG;AACvB,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,iBAAiB,KAAK,eAAe;AAC1C,SAAK,UAAU;AACf,SAAK,OAAO,CAAC;AACb,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,eAAe,KAAK,qBAAqB,qBAAqB,KAAK,wBAAwB,KAAK,IAAI,GAAG,MAAM,KAAK;AACvH,QAAI,sBAAsB;AAC1B,SAAK,aAAa,QAAQ,iBAAe;AACvC,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,UAAI,uBAAuB,SAAS,gBAAgB,SAAS,oBAAoB,EAAE,SAAS,wBAAwB,YAAY,WAAW;AACzI,aAAK,MAAM,SAAS,4BAA4B,WAAW;AAAA,MAC7D;AACA,8BAAwB,sBAAsB,SAAS,wBAAwB,YAAY,YAAY,SAAS;AAAA,IAClH,CAAC;AACD,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,0BAA0B;AACxB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,OAAO,KAAK,IAAI,EAAE;AACxB,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,UAAM,SAAS,2BAA2B,KAAK,MAAM,IAAI;AACzD,UAAM,cAAc,SAAS,KAAK,kBAAkB,IAAI;AACxD,QAAI,gBAAgB,IAAI;AACtB,gBAAU;AACV,iBAAW;AACX,cAAQ,KAAK,gBAAgB,IAAI;AACjC,WAAK,OAAO,EAAE;AACd,aAAO,KAAK,YAAY;AAAA,IAC1B,WAAW,gBAAgB,IAAI;AAC7B,iBAAW;AACX,YAAMQ,YAAW,KAAK,MAAM;AAC5B,YAAM,WAAW,KAAK,MAAM;AAC5B,YAAM,cAAc,KAAK,oBAAoB;AAC7C,UAAI,KAAK,kBAAkB,MAAM,IAAI;AACnC,kBAAU;AACV,gBAAQ,KAAK,iBAAiB,KAAK,YAAYA,SAAQ,GAAG,QAAQ;AAClE,aAAK,OAAO,EAAE;AACd,aAAK,OAAO,EAAE;AACd,eAAO,KAAK,YAAY;AAAA,MAC1B,OAAO;AACL,kBAAU;AACV,eAAO;AACP,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF,OAAO;AACL,aAAO,KAAK,YAAY;AACxB,iBAAW,KAAK,IAAI,EAAE;AACtB,gBAAU,KAAK,IAAI,EAAE;AAAA,IACvB;AACA,QAAI,SAAS;AACX,UAAI;AACJ,UAAI,OAAO;AACT,sBAAc,KAAK,gBAAgB,KAAK;AACxC,oBAAY,WAAW;AACvB,oBAAY,QAAQ;AACpB,oBAAY,cAAc;AAC1B,YAAI,KAAK,IAAI,EAAE,GAAG;AAChB,sBAAY,WAAW;AACvB,eAAK,MAAM,SAAS,wBAAwB,KAAK,MAAM,eAAe;AAAA,QACxE;AAAA,MACF,OAAO;AACL,sBAAc,KAAK,gBAAgB,IAAI;AACvC,oBAAY,WAAW;AACvB,aAAK,MAAM,SAAS,yBAAyB,IAAI;AACjD,oBAAY,QAAQ;AACpB,oBAAY,cAAc,KAAK,YAAY;AAAA,MAC7C;AACA,aAAO,KAAK,WAAW,aAAa,oBAAoB;AAAA,IAC1D,WAAW,UAAU;AACnB,YAAM,mBAAmB,KAAK,gBAAgB,IAAI;AAClD,uBAAiB,iBAAiB;AAClC,aAAO,KAAK,WAAW,kBAAkB,gBAAgB;AAAA,IAC3D;AACA,QAAI,MAAM;AACR,YAAM,WAAW,KAAK,YAAY,QAAQ;AAC1C,eAAS,iBAAiB;AAC1B,aAAO,KAAK,WAAW,UAAU,YAAY;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B;AACzB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,EAAE;AACd,SAAK,iBAAiB,KAAK,YAAY;AACvC,SAAK,OAAO,EAAE;AACd,WAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACpD;AAAA,EACA,iCAAiC,MAAM,UAAU;AAC/C,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,SAAS,qBAAqB;AAChC,WAAK,WAAW,CAAC,CAAC;AAClB,UAAI;AAAU,aAAK,KAAK;AACxB,WAAK,KAAK;AAAA,IACZ;AACA,SAAK,iCAAiC,MAAM,KAAK,gBAAgB,IAAI,IAAI,CAAC;AAC1E,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,yBAAyB;AACvB,UAAM,OAAO,KAAK,UAAU;AAC5B,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,aAAK,UAAU,MAAM,cAAc;AACnC;AAAA,MACF;AACE,aAAK,WAAW;AAAA,IACpB;AACA,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,6BAA6B;AAC3B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,UAAU,MAAM,cAAc,KAAK;AACxC,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,4BAA4B;AAC1B,QAAI,KAAK,MAAM;AAAQ,aAAO,KAAK,YAAY;AAC/C,WAAO,MAAM,0BAA0B;AAAA,EACzC;AAAA,EACA,qCAAqC;AACnC,UAAM,cAAc,KAAK,oBAAoB;AAC7C,QAAI,KAAK,aAAa,GAAG,KAAK,CAAC,KAAK,sBAAsB,GAAG;AAC3D,aAAO,KAAK,yBAAyB,WAAW;AAAA,IAClD,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,sBAAsB;AACpB,YAAQ,KAAK,MAAM,MAAM;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,uBAAuB;AAAA,MACrC,KAAK;AACH,YAAI,KAAK,MAAM,UAAU,KAAK;AAC5B,gBAAM,OAAO,KAAK,UAAU;AAC5B,gBAAM,YAAY,KAAK,UAAU;AACjC,cAAI,UAAU,SAAS,OAAO,UAAU,SAAS,KAAK;AACpD,iBAAK,WAAW;AAAA,UAClB;AACA,eAAK,UAAU,KAAK,gBAAgB;AACpC,iBAAO,KAAK,WAAW,MAAM,eAAe;AAAA,QAC9C;AACA;AAAA,MACF,KAAK;AACH,eAAO,KAAK,mCAAmC;AAAA,MACjD,KAAK;AACH,eAAO,KAAK,iBAAiB;AAAA,MAC/B,KAAK;AACH,eAAO,KAAK,kBAAkB;AAAA,MAChC,KAAK;AACH,eAAO,KAAK,YAAY,KAAK,sBAAsB,KAAK,IAAI,CAAC,IAAI,KAAK,kBAAkB,IAAI,KAAK,mBAAmB;AAAA,MACtH,KAAK;AACH,eAAO,KAAK,iBAAiB;AAAA,MAC/B,KAAK;AACH,eAAO,KAAK,yBAAyB;AAAA,MACvC,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,2BAA2B;AAAA,MACzC,SACE;AACE,cAAM;AAAA,UACJ;AAAA,QACF,IAAI,KAAK;AACT,YAAI,kBAAkB,IAAI,KAAK,SAAS,MAAM,SAAS,IAAI;AACzD,gBAAM,WAAW,SAAS,KAAK,kBAAkB,SAAS,KAAK,kBAAkB,oBAAoB,KAAK,MAAM,KAAK;AACrH,cAAI,aAAa,UAAa,KAAK,kBAAkB,MAAM,IAAI;AAC7D,kBAAM,OAAO,KAAK,UAAU;AAC5B,iBAAK,KAAK;AACV,mBAAO,KAAK,WAAW,MAAM,QAAQ;AAAA,UACvC;AACA,iBAAO,KAAK,qBAAqB;AAAA,QACnC;AAAA,MACF;AAAA,IACJ;AACA,SAAK,WAAW;AAAA,EAClB;AAAA,EACA,2BAA2B;AACzB,QAAI,OAAO,KAAK,oBAAoB;AACpC,WAAO,CAAC,KAAK,sBAAsB,KAAK,KAAK,IAAI,CAAC,GAAG;AACnD,UAAI,KAAK,MAAM,CAAC,GAAG;AACjB,cAAM,OAAO,KAAK,gBAAgB,IAAI;AACtC,aAAK,cAAc;AACnB,aAAK,OAAO,CAAC;AACb,eAAO,KAAK,WAAW,MAAM,aAAa;AAAA,MAC5C,OAAO;AACL,cAAM,OAAO,KAAK,gBAAgB,IAAI;AACtC,aAAK,aAAa;AAClB,aAAK,YAAY,KAAK,YAAY;AAClC,aAAK,OAAO,CAAC;AACb,eAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,MACpD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB;AACpB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,WAAW,KAAK,MAAM;AAC5B,SAAK,KAAK;AACV,SAAK,WAAW;AAChB,SAAK,iBAAiB,KAAK,4BAA4B;AACvD,QAAI,aAAa,YAAY;AAC3B,WAAK,iCAAiC,IAAI;AAAA,IAC5C;AACA,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,iCAAiC,MAAM;AACrC,YAAQ,KAAK,eAAe,MAAM;AAAA,MAChC,KAAK;AAAA,MACL,KAAK;AACH;AAAA,MACF;AACE,aAAK,MAAM,SAAS,oBAAoB,IAAI;AAAA,IAChD;AAAA,EACF;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,iBAAiB,GAAG;AACzB,UAAM,gBAAgB,KAAK,UAAU;AACrC,kBAAc,OAAO,KAAK,yBAAyB;AACnD,kBAAc,aAAa,KAAK,WAAW,MAAM,KAAK,8BAA8B,CAAC;AACrF,SAAK,gBAAgB,KAAK,WAAW,eAAe,iBAAiB;AACrE,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,gCAAgC;AAC9B,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,aAAa,KAAK,oCAAoC,MAAM,KAAK,YAAY,CAAC;AACpF,UAAI,KAAK,MAAM,qCAAqC,CAAC,KAAK,MAAM,EAAE,GAAG;AACnE,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EACA,8BAA8B;AAC5B,UAAM,iBAAiB,sBAAsB,KAAK,MAAM,IAAI,KAAK,CAAC,KAAK,MAAM;AAC7E,WAAO,iBAAiB,KAAK,oBAAoB,IAAI,KAAK,aAAa,GAAG,IAAI,KAAK,iBAAiB,IAAI,KAAK,iCAAiC,MAAM,KAAK,yBAAyB,CAAC;AAAA,EACrL;AAAA,EACA,+BAA+B,MAAM,sBAAsB,UAAU;AACnE,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,qBAAqB,KAAK,IAAI,QAAQ;AAC5C,UAAMC,SAAQ,CAAC;AACf,OAAG;AACD,MAAAA,OAAM,KAAK,qBAAqB,CAAC;AAAA,IACnC,SAAS,KAAK,IAAI,QAAQ;AAC1B,QAAIA,OAAM,WAAW,KAAK,CAAC,oBAAoB;AAC7C,aAAOA,OAAM,CAAC;AAAA,IAChB;AACA,SAAK,QAAQA;AACb,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,kCAAkC;AAChC,WAAO,KAAK,+BAA+B,sBAAsB,KAAK,4BAA4B,KAAK,IAAI,GAAG,EAAE;AAAA,EAClH;AAAA,EACA,2BAA2B;AACzB,WAAO,KAAK,+BAA+B,eAAe,KAAK,gCAAgC,KAAK,IAAI,GAAG,EAAE;AAAA,EAC/G;AAAA,EACA,0BAA0B;AACxB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO;AAAA,IACT;AACA,WAAO,KAAK,MAAM,EAAE,KAAK,KAAK,YAAY,KAAK,qCAAqC,KAAK,IAAI,CAAC;AAAA,EAChG;AAAA,EACA,uBAAuB;AACrB,QAAI,kBAAkB,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,EAAE,GAAG;AACxD,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AACA,QAAI,KAAK,MAAM,CAAC,GAAG;AACjB,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK;AACT,YAAM,qBAAqB,OAAO;AAClC,UAAI;AACF,aAAK,gBAAgB,GAAG,IAAI;AAC5B,eAAO,OAAO,WAAW;AAAA,MAC3B,SAAS,SAAS;AAChB,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI,KAAK,MAAM,CAAC,GAAG;AACjB,WAAK,KAAK;AACV,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK;AACT,YAAM,qBAAqB,OAAO;AAClC,UAAI;AACF,cAAM,iBAAiB,GAAG,IAAI,CAAC;AAC/B,eAAO,OAAO,WAAW;AAAA,MAC3B,SAAS,UAAU;AACjB,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,uCAAuC;AACrC,SAAK,KAAK;AACV,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,aAAO;AAAA,IACT;AACA,QAAI,KAAK,qBAAqB,GAAG;AAC/B,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACxE,eAAO;AAAA,MACT;AACA,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAK,KAAK;AACV,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,qCAAqC,aAAa;AAChD,WAAO,KAAK,SAAS,MAAM;AACzB,YAAM,IAAI,KAAK,UAAU;AACzB,WAAK,OAAO,WAAW;AACvB,YAAM,OAAO,KAAK,UAAU;AAC5B,YAAM,UAAU,CAAC,CAAC,KAAK,WAAW,KAAK,4BAA4B,KAAK,IAAI,CAAC;AAC7E,UAAI,WAAW,KAAK,MAAM,EAAE,GAAG;AAC7B,YAAI,oBAAoB,KAAK,mCAAmC;AAChE,YAAI,kBAAkB,SAAS,cAAc;AAC3C,eAAK,gBAAgB;AACrB,eAAK,UAAU;AACf,eAAK,iBAAiB;AACtB,8BAAoB,KAAK,WAAW,MAAM,iBAAiB;AAAA,QAC7D,OAAO;AACL,eAAK,2BAA2B,mBAAmB,IAAI;AACvD,4BAAkB,UAAU;AAAA,QAC9B;AACA,UAAE,iBAAiB;AACnB,eAAO,KAAK,WAAW,GAAG,kBAAkB;AAAA,MAC9C;AACA,YAAM,wBAAwB,KAAK,eAAe,KAAK,KAAK,WAAW,KAAK,2BAA2B,KAAK,IAAI,CAAC;AACjH,UAAI,CAAC,uBAAuB;AAC1B,YAAI,CAAC,SAAS;AACZ,iBAAO,KAAK,sBAAsB,OAAO,CAAC;AAAA,QAC5C;AACA,aAAK,gBAAgB,KAAK,gBAAgB;AAC1C,aAAK,UAAU;AACf,aAAK,iBAAiB;AACtB,UAAE,iBAAiB,KAAK,WAAW,MAAM,iBAAiB;AAC1D,eAAO,KAAK,WAAW,GAAG,kBAAkB;AAAA,MAC9C;AACA,YAAM,OAAO,KAAK,sBAAsB,KAAK;AAC7C,WAAK,gBAAgB;AACrB,WAAK,iBAAiB;AACtB,WAAK,UAAU;AACf,QAAE,iBAAiB,KAAK,WAAW,MAAM,iBAAiB;AAC1D,aAAO,KAAK,WAAW,GAAG,kBAAkB;AAAA,IAC9C,CAAC;AAAA,EACH;AAAA,EACA,0CAA0C;AACxC,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,KAAK,qCAAqC,EAAE;AAAA,IACrD;AAAA,EACF;AAAA,EACA,2BAA2B;AACzB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,KAAK,sBAAsB;AAAA,IACpC;AAAA,EACF;AAAA,EACA,iBAAiB;AACf,WAAO,KAAK,mBAAmB,EAAE;AAAA,EACnC;AAAA,EACA,6BAA6B;AAC3B,UAAM,KAAK,KAAK,gBAAgB;AAChC,QAAI,KAAK,aAAa,GAAG,KAAK,CAAC,KAAK,sBAAsB,GAAG;AAC3D,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,8BAA8B;AAC5B,QAAI,KAAK,MAAM,SAAS,KAAK;AAC3B,aAAO;AAAA,IACT;AACA,UAAM,cAAc,KAAK,MAAM;AAC/B,SAAK,KAAK;AACV,QAAI,CAAC,kBAAkB,KAAK,MAAM,IAAI,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AAC1D,aAAO;AAAA,IACT;AACA,QAAI,aAAa;AACf,WAAK,MAAM,OAAO,4BAA4B,KAAK,MAAM,iBAAiB;AAAA,QACxE,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,WAAW,MAAM,IAAI,KAAK,UAAU,GAAG;AAC3D,SAAK,SAAS,MAAM;AAClB,UAAI;AAAU,aAAK,OAAO,EAAE;AAC5B,QAAE,iBAAiB,KAAK,YAAY;AAAA,IACtC,CAAC;AACD,WAAO,KAAK,WAAW,GAAG,kBAAkB;AAAA,EAC9C;AAAA,EACA,cAAc;AACZ,WAAO,KAAK,MAAM,MAAM;AACxB,UAAM,OAAO,KAAK,0BAA0B;AAC5C,QAAI,KAAK,MAAM,qCAAqC,KAAK,sBAAsB,KAAK,CAAC,KAAK,IAAI,EAAE,GAAG;AACjG,aAAO;AAAA,IACT;AACA,UAAM,OAAO,KAAK,gBAAgB,IAAI;AACtC,SAAK,YAAY;AACjB,SAAK,cAAc,KAAK,oCAAoC,MAAM,KAAK,0BAA0B,CAAC;AAClG,SAAK,OAAO,EAAE;AACd,SAAK,WAAW,KAAK,iCAAiC,MAAM,KAAK,YAAY,CAAC;AAC9E,SAAK,OAAO,EAAE;AACd,SAAK,YAAY,KAAK,iCAAiC,MAAM,KAAK,YAAY,CAAC;AAC/E,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,iCAAiC;AAC/B,WAAO,KAAK,aAAa,GAAG,KAAK,KAAK,UAAU,EAAE,SAAS;AAAA,EAC7D;AAAA,EACA,4BAA4B;AAC1B,QAAI,KAAK,wBAAwB,GAAG;AAClC,aAAO,KAAK,iCAAiC,gBAAgB;AAAA,IAC/D;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,KAAK,iCAAiC,mBAAmB;AAAA,IAClE,WAAW,KAAK,+BAA+B,GAAG;AAChD,aAAO,KAAK,iCAAiC,qBAAqB,IAAI;AAAA,IACxE;AACA,WAAO,KAAK,yBAAyB;AAAA,EACvC;AAAA,EACA,uBAAuB;AACrB,QAAI,KAAK,gBAAgB,cAAc,0BAA0B,GAAG;AAClE,WAAK,MAAM,SAAS,uBAAuB,KAAK,MAAM,QAAQ;AAAA,IAChE;AACA,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,iBAAiB,KAAK,SAAS,MAAM;AACxC,WAAK,KAAK;AACV,aAAO,KAAK,MAAM,EAAE,IAAI,KAAK,qBAAqB,IAAI,KAAK,YAAY;AAAA,IACzE,CAAC;AACD,SAAK,OAAO,EAAE;AACd,SAAK,aAAa,KAAK,gBAAgB;AACvC,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,sBAAsB,OAAO;AAC3B,UAAM,mBAAmB,KAAK,MAAM;AACpC,UAAM,gBAAgB,KAAK,qBAAqB,yBAAyB,MAAM;AAC7E,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,aAAa,KAAK,kBAAkB;AACzC,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAK,iBAAiB,KAAK,qBAAqB;AAAA,MAClD;AACA,aAAO,KAAK,WAAW,MAAM,+BAA+B;AAAA,IAC9D,CAAC;AACD,QAAI,CAAC,cAAc,QAAQ;AACzB,WAAK,MAAM,SAAS,yBAAyB,kBAAkB;AAAA,QAC7D;AAAA,MACF,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EACA,4BAA4B,MAAM,aAAa,CAAC,GAAG;AACjD,QAAI,KAAK,sBAAsB;AAAG,aAAO;AACzC,SAAK,iBAAiB,GAAG;AACzB,QAAI,WAAW;AAAS,WAAK,UAAU;AACvC,QAAI,kBAAkB,KAAK,MAAM,IAAI,GAAG;AACtC,WAAK,KAAK,KAAK,gBAAgB;AAC/B,WAAK,gBAAgB,KAAK,IAAI,GAAG;AAAA,IACnC,OAAO;AACL,WAAK,KAAK;AACV,WAAK,MAAM,SAAS,sBAAsB,KAAK,MAAM,QAAQ;AAAA,IAC/D;AACA,SAAK,iBAAiB,KAAK,yBAAyB,KAAK,0BAA0B;AACnF,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,UAAU,KAAK,sBAAsB,SAAS;AAAA,IACrD;AACA,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,OAAO,KAAK,SAAS,KAAK,yBAAyB,KAAK,IAAI,CAAC;AAClE,SAAK,OAAO,KAAK,WAAW,MAAM,iBAAiB;AACnD,WAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,EACvD;AAAA,EACA,4BAA4B,MAAM;AAChC,SAAK,KAAK,KAAK,gBAAgB;AAC/B,SAAK,gBAAgB,KAAK,IAAI,CAAC;AAC/B,SAAK,iBAAiB,KAAK,SAAS,MAAM;AACxC,WAAK,iBAAiB,KAAK,yBAAyB,KAAK,qBAAqB;AAC9E,WAAK,OAAO,EAAE;AACd,UAAI,KAAK,aAAa,GAAG,KAAK,KAAK,UAAU,EAAE,SAAS,IAAI;AAC1D,cAAMP,QAAO,KAAK,UAAU;AAC5B,aAAK,KAAK;AACV,eAAO,KAAK,WAAWA,OAAM,oBAAoB;AAAA,MACnD;AACA,aAAO,KAAK,YAAY;AAAA,IAC1B,CAAC;AACD,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,EACvD;AAAA,EACA,cAAc,IAAI;AAChB,UAAM,aAAa,KAAK,MAAM;AAC9B,SAAK,MAAM,UAAU,CAAC,WAAW,CAAC,CAAC;AACnC,QAAI;AACF,aAAO,GAAG;AAAA,IACZ,UAAE;AACA,WAAK,MAAM,UAAU;AAAA,IACvB;AAAA,EACF;AAAA,EACA,SAAS,IAAI;AACX,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS;AACpB,QAAI;AACF,aAAO,GAAG;AAAA,IACZ,UAAE;AACA,WAAK,MAAM,SAAS;AAAA,IACtB;AAAA,EACF;AAAA,EACA,oCAAoC,IAAI;AACtC,UAAM,uCAAuC,KAAK,MAAM;AACxD,SAAK,MAAM,oCAAoC;AAC/C,QAAI;AACF,aAAO,GAAG;AAAA,IACZ,UAAE;AACA,WAAK,MAAM,oCAAoC;AAAA,IACjD;AAAA,EACF;AAAA,EACA,iCAAiC,IAAI;AACnC,UAAM,uCAAuC,KAAK,MAAM;AACxD,SAAK,MAAM,oCAAoC;AAC/C,QAAI;AACF,aAAO,GAAG;AAAA,IACZ,UAAE;AACA,WAAK,MAAM,oCAAoC;AAAA,IACjD;AAAA,EACF;AAAA,EACA,mBAAmB,OAAO;AACxB,QAAI,KAAK,MAAM,KAAK,GAAG;AACrB,aAAO,KAAK,oBAAoB;AAAA,IAClC;AAAA,EACF;AAAA,EACA,sBAAsB,OAAO;AAC3B,WAAO,KAAK,SAAS,MAAM;AACzB,WAAK,OAAO,KAAK;AACjB,aAAO,KAAK,YAAY;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA,EACA,sBAAsB;AACpB,WAAO,KAAK,SAAS,MAAM;AACzB,WAAK,KAAK;AACV,aAAO,KAAK,YAAY;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA,EACA,oBAAoB;AAClB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK,KAAK,MAAM,GAAG,IAAI,MAAM,mBAAmB,KAAK,MAAM,KAAK,IAAI,KAAK,gBAAgB,IAAI;AAClG,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,cAAc,MAAM,wBAAwB;AAAA,IACnD;AACA,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,uBAAuB,MAAM,aAAa,CAAC,GAAG;AAC5C,QAAI,WAAW;AAAO,WAAK,QAAQ;AACnC,QAAI,WAAW;AAAS,WAAK,UAAU;AACvC,SAAK,iBAAiB,GAAG;AACzB,SAAK,KAAK,KAAK,gBAAgB;AAC/B,SAAK,gBAAgB,KAAK,IAAI,KAAK,QAAQ,OAAO,IAAI;AACtD,SAAK,OAAO,CAAC;AACb,SAAK,UAAU,KAAK,qBAAqB,eAAe,KAAK,kBAAkB,KAAK,IAAI,CAAC;AACzF,SAAK,OAAO,CAAC;AACb,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,qBAAqB;AACnB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,MAAM,MAAM,CAAC;AAClB,SAAK,OAAO,CAAC;AACb,UAAM,4BAA4B,KAAK,OAAO,CAAC,GAAG,QAAW,MAAM,CAAC;AACpE,SAAK,MAAM,KAAK;AAChB,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,oCAAoC,MAAM,SAAS,OAAO;AACxD,SAAK,KAAK,KAAK,gBAAgB;AAC/B,QAAI,CAAC,QAAQ;AACX,WAAK,gBAAgB,KAAK,IAAI,IAAI;AAAA,IACpC;AACA,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,QAAQ,KAAK,UAAU;AAC7B,WAAK,oCAAoC,OAAO,IAAI;AACpD,WAAK,OAAO;AAAA,IACd,OAAO;AACL,WAAK,MAAM,MAAM,GAAG;AACpB,WAAK,UAAU,MAAM,CAAC;AACtB,WAAK,OAAO,KAAK,mBAAmB;AACpC,WAAK,UAAU,KAAK;AACpB,WAAK,MAAM,KAAK;AAAA,IAClB;AACA,WAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACpD;AAAA,EACA,wCAAwC,MAAM;AAC5C,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,WAAK,SAAS;AACd,WAAK,KAAK,KAAK,gBAAgB;AAAA,IACjC,WAAW,KAAK,MAAM,GAAG,GAAG;AAC1B,WAAK,KAAK,MAAM,mBAAmB,KAAK,MAAM,KAAK;AAAA,IACrD,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AACA,QAAI,KAAK,MAAM,CAAC,GAAG;AACjB,WAAK,MAAM,MAAM,GAAG;AACpB,WAAK,UAAU,MAAM,CAAC;AACtB,WAAK,OAAO,KAAK,mBAAmB;AACpC,WAAK,UAAU,KAAK;AACpB,WAAK,MAAM,KAAK;AAAA,IAClB,OAAO;AACL,WAAK,UAAU;AAAA,IACjB;AACA,WAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACpD;AAAA,EACA,+BAA+B,MAAM,wBAAwB,UAAU;AACrE,SAAK,WAAW,YAAY;AAC5B,SAAK,KAAK,0BAA0B,KAAK,gBAAgB;AACzD,SAAK,gBAAgB,KAAK,IAAI,IAAI;AAClC,SAAK,OAAO,EAAE;AACd,UAAM,kBAAkB,KAAK,uBAAuB;AACpD,QAAI,KAAK,eAAe,UAAU,gBAAgB,SAAS,6BAA6B;AACtF,WAAK,MAAM,SAAS,0BAA0B,eAAe;AAAA,IAC/D;AACA,SAAK,kBAAkB;AACvB,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,2BAA2B;AAAA,EAC1D;AAAA,EACA,8BAA8B;AAC5B,WAAO,KAAK,aAAa,GAAG,KAAK,KAAK,kBAAkB,MAAM;AAAA,EAChE;AAAA,EACA,yBAAyB;AACvB,WAAO,KAAK,4BAA4B,IAAI,KAAK,+BAA+B,IAAI,KAAK,kBAAkB,KAAK;AAAA,EAClH;AAAA,EACA,iCAAiC;AAC/B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,iBAAiB,GAAG;AACzB,SAAK,OAAO,EAAE;AACd,QAAI,CAAC,KAAK,MAAM,GAAG,GAAG;AACpB,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,aAAa,MAAM,cAAc;AACtC,SAAK,OAAO,EAAE;AACd,SAAK,oBAAoB;AACzB,WAAO,KAAK,WAAW,MAAM,2BAA2B;AAAA,EAC1D;AAAA,EACA,YAAY,GAAG;AACb,UAAM,QAAQ,KAAK,MAAM,MAAM;AAC/B,UAAM,MAAM,EAAE;AACd,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA,EACA,mBAAmB,GAAG;AACpB,UAAM,SAAS,KAAK,SAAS,WAAS,EAAE,KAAK,MAAM,CAAC;AACpD,QAAI,OAAO,WAAW,CAAC,OAAO;AAAM;AACpC,QAAI,OAAO;AAAO,WAAK,QAAQ,OAAO;AACtC,WAAO,OAAO;AAAA,EAChB;AAAA,EACA,WAAW,GAAG;AACZ,UAAM,QAAQ,KAAK,MAAM,MAAM;AAC/B,UAAM,SAAS,EAAE;AACjB,QAAI,WAAW,UAAa,WAAW,OAAO;AAC5C,aAAO;AAAA,IACT;AACA,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,kBAAkB,MAAM;AACtB,QAAI,KAAK,iBAAiB,GAAG;AAC3B;AAAA,IACF;AACA,QAAI,YAAY,KAAK,MAAM;AAC3B,QAAI;AACJ,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,kBAAY;AACZ,aAAO;AAAA,IACT;AACA,WAAO,KAAK,mBAAmB,MAAM;AACnC,cAAQ,WAAW;AAAA,QACjB,KAAK;AACH,eAAK,UAAU;AACf,iBAAO,MAAM,uBAAuB,MAAM,OAAO,KAAK;AAAA,QACxD,KAAK;AACH,eAAK,UAAU;AACf,iBAAO,KAAK,WAAW,MAAM,MAAM,KAAK;AAAA,QAC1C,KAAK;AACH,iBAAO,KAAK,uBAAuB,MAAM;AAAA,YACvC,SAAS;AAAA,UACX,CAAC;AAAA,QACH,KAAK;AACH,iBAAO,KAAK,wCAAwC,IAAI;AAAA,QAC1D,KAAK;AAAA,QACL,KAAK;AACH,cAAI,CAAC,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,sBAAsB,MAAM,GAAG;AAC1D,iBAAK,UAAU;AACf,mBAAO,KAAK,kBAAkB,MAAM,QAAQ,KAAK,MAAM,OAAO,IAAI;AAAA,UACpE;AACA,eAAK,OAAO,EAAE;AACd,iBAAO,KAAK,uBAAuB,MAAM;AAAA,YACvC,OAAO;AAAA,YACP,SAAS;AAAA,UACX,CAAC;AAAA,QACH,KAAK,KACH;AACE,gBAAM,SAAS,KAAK,4BAA4B,MAAM;AAAA,YACpD,SAAS;AAAA,UACX,CAAC;AACD,cAAI;AAAQ,mBAAO;AAAA,QACrB;AAAA,QACF;AACE,cAAI,kBAAkB,SAAS,GAAG;AAChC,mBAAO,KAAK,mBAAmB,MAAM,KAAK,MAAM,OAAO,MAAM,IAAI;AAAA,UACnE;AAAA,MACJ;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,8BAA8B;AAC5B,WAAO,KAAK,mBAAmB,KAAK,UAAU,GAAG,KAAK,MAAM,OAAO,MAAM,IAAI;AAAA,EAC/E;AAAA,EACA,2BAA2B,MAAM,MAAM,YAAY;AACjD,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK,WACH;AACE,cAAM,cAAc,KAAK,kBAAkB,IAAI;AAC/C,YAAI,aAAa;AACf,sBAAY,UAAU;AAAA,QACxB;AACA,eAAO;AAAA,MACT;AAAA,MACF,KAAK;AACH,YAAI,KAAK,MAAM,CAAC,GAAG;AACjB,eAAK,MAAM,MAAM,GAAG;AACpB,eAAK,UAAU,MAAM,CAAC;AACtB,gBAAM,MAAM;AACZ,cAAI,SAAS;AACb,cAAI,KAAK;AACT,cAAI,OAAO,KAAK,mBAAmB;AACnC,eAAK,MAAM,KAAK;AAChB,eAAK,UAAU,KAAK;AACpB,iBAAO,KAAK,WAAW,KAAK,qBAAqB;AAAA,QACnD;AACA;AAAA,MACF;AACE,eAAO,KAAK,mBAAmB,MAAM,KAAK,MAAM,OAAO,UAAU;AAAA,IACrE;AAAA,EACF;AAAA,EACA,mBAAmB,MAAM,OAAO,MAAM,YAAY;AAChD,YAAQ,OAAO;AAAA,MACb,KAAK;AACH,YAAI,KAAK,sBAAsB,IAAI,MAAM,KAAK,MAAM,EAAE,KAAK,kBAAkB,KAAK,MAAM,IAAI,IAAI;AAC9F,iBAAO,KAAK,2BAA2B,MAAM,UAAU;AAAA,QACzD;AACA;AAAA,MACF,KAAK;AACH,YAAI,KAAK,sBAAsB,IAAI,GAAG;AACpC,cAAI,KAAK,MAAM,GAAG,GAAG;AACnB,mBAAO,KAAK,wCAAwC,IAAI;AAAA,UAC1D,WAAW,kBAAkB,KAAK,MAAM,IAAI,GAAG;AAC7C,mBAAO,KAAK,oCAAoC,IAAI;AAAA,UACtD;AAAA,QACF;AACA;AAAA,MACF,KAAK;AACH,YAAI,KAAK,sBAAsB,IAAI,KAAK,kBAAkB,KAAK,MAAM,IAAI,GAAG;AAC1E,iBAAO,KAAK,oCAAoC,IAAI;AAAA,QACtD;AACA;AAAA,MACF,KAAK;AACH,YAAI,KAAK,sBAAsB,IAAI,KAAK,kBAAkB,KAAK,MAAM,IAAI,GAAG;AAC1E,iBAAO,KAAK,4BAA4B,IAAI;AAAA,QAC9C;AACA;AAAA,IACJ;AAAA,EACF;AAAA,EACA,sBAAsB,MAAM;AAC1B,QAAI,MAAM;AACR,UAAI,KAAK,sBAAsB;AAAG,eAAO;AACzC,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AACA,WAAO,CAAC,KAAK,iBAAiB;AAAA,EAChC;AAAA,EACA,oCAAoC,UAAU;AAC5C,QAAI,CAAC,KAAK,MAAM,EAAE;AAAG;AACrB,UAAM,4BAA4B,KAAK,MAAM;AAC7C,SAAK,MAAM,yBAAyB;AACpC,UAAM,MAAM,KAAK,mBAAmB,MAAM;AACxC,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,WAAK,iBAAiB,KAAK,sBAAsB,KAAK,oBAAoB;AAC1E,YAAM,oBAAoB,IAAI;AAC9B,WAAK,aAAa,KAAK,wCAAwC;AAC/D,WAAK,OAAO,EAAE;AACd,aAAO;AAAA,IACT,CAAC;AACD,SAAK,MAAM,yBAAyB;AACpC,QAAI,CAAC;AAAK;AACV,WAAO,MAAM,qBAAqB,KAAK,MAAM,IAAI;AAAA,EACnD;AAAA,EACA,mCAAmC;AACjC,QAAI,KAAK,UAAU,MAAM;AAAI;AAC7B,WAAO,KAAK,qBAAqB;AAAA,EACnC;AAAA,EACA,uBAAuB;AACrB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,SAAS,KAAK,SAAS,MAAM,KAAK,cAAc,MAAM;AACzD,WAAK,OAAO,EAAE;AACd,aAAO,KAAK,qBAAqB,6BAA6B,KAAK,YAAY,KAAK,IAAI,CAAC;AAAA,IAC3F,CAAC,CAAC;AACF,QAAI,KAAK,OAAO,WAAW,GAAG;AAC5B,WAAK,MAAM,SAAS,oBAAoB,IAAI;AAAA,IAC9C,WAAW,CAAC,KAAK,MAAM,UAAU,KAAK,WAAW,MAAM,MAAM,OAAO;AAClE,WAAK,aAAa;AAAA,IACpB;AACA,SAAK,OAAO,EAAE;AACd,WAAO,KAAK,WAAW,MAAM,8BAA8B;AAAA,EAC7D;AAAA,EACA,uBAAuB;AACrB,WAAO,0BAA0B,KAAK,MAAM,IAAI;AAAA,EAClD;AAAA,EACA,2BAA2B;AACzB,QAAI,KAAK,qBAAqB;AAAG,aAAO;AACxC,WAAO,MAAM,yBAAyB;AAAA,EACxC;AAAA,EACA,wBAAwB,OAAO,YAAY;AACzC,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,WAAW,CAAC;AAClB,SAAK,iBAAiB;AAAA,MACpB,kBAAkB,CAAC,UAAU,WAAW,aAAa,YAAY,UAAU;AAAA,IAC7E,GAAG,QAAQ;AACX,UAAM,gBAAgB,SAAS;AAC/B,UAAM,WAAW,SAAS;AAC1B,UAAM,WAAW,SAAS;AAC1B,QAAI,EAAE,QAAQ,OAAO,iBAAiB,YAAY,WAAW;AAC3D,WAAK,MAAM,SAAS,6BAA6B,QAAQ;AAAA,IAC3D;AACA,UAAM,OAAO,KAAK,kBAAkB;AACpC,SAAK,6BAA6B,MAAM,KAAK;AAC7C,UAAM,MAAM,KAAK,kBAAkB,KAAK,IAAI,OAAO,IAAI;AACvD,QAAI,iBAAiB,YAAY,UAAU;AACzC,YAAM,KAAK,KAAK,YAAY,QAAQ;AACpC,UAAI,WAAW,QAAQ;AACrB,WAAG,aAAa;AAAA,MAClB;AACA,UAAI;AAAe,WAAG,gBAAgB;AACtC,UAAI;AAAU,WAAG,WAAW;AAC5B,UAAI;AAAU,WAAG,WAAW;AAC5B,UAAI,IAAI,SAAS,gBAAgB,IAAI,SAAS,qBAAqB;AACjE,aAAK,MAAM,SAAS,kCAAkC,EAAE;AAAA,MAC1D;AACA,SAAG,YAAY;AACf,aAAO,KAAK,WAAW,IAAI,qBAAqB;AAAA,IAClD;AACA,QAAI,WAAW,QAAQ;AACrB,WAAK,aAAa;AAAA,IACpB;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,MAAM;AACtB,WAAO,KAAK,SAAS,yBAAyB,MAAM,kBAAkB,KAAK,SAAS,KAAK,MAAM,kBAAkB,IAAI;AAAA,EACvH;AAAA,EACA,0BAA0B,MAAM;AAC9B,eAAW,SAAS,KAAK,QAAQ;AAC/B,UAAI,MAAM,SAAS,gBAAgB,MAAM,YAAY,CAAC,KAAK,MAAM,kBAAkB;AACjF,aAAK,MAAM,SAAS,mBAAmB,KAAK;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAAA,EACA,2BAA2B,MAAM,QAAQ,kBAAkB;AACzD,UAAM,2BAA2B,MAAM,QAAQ,gBAAgB;AAC/D,SAAK,0BAA0B,IAAI;AAAA,EACrC;AAAA,EACA,2BAA2B,MAAM,MAAM,WAAW,OAAO;AACvD,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,aAAa,KAAK,qCAAqC,EAAE;AAAA,IAChE;AACA,UAAM,eAAe,SAAS,wBAAwB,sBAAsB,SAAS,iBAAiB,SAAS,uBAAuB,oBAAoB;AAC1J,QAAI,gBAAgB,CAAC,KAAK,MAAM,CAAC,KAAK,KAAK,iBAAiB,GAAG;AAC7D,aAAO,KAAK,WAAW,MAAM,YAAY;AAAA,IAC3C;AACA,QAAI,iBAAiB,uBAAuB,KAAK,MAAM,kBAAkB;AACvE,WAAK,MAAM,SAAS,kCAAkC,IAAI;AAC1D,UAAI,KAAK,SAAS;AAChB,eAAO,MAAM,2BAA2B,MAAM,cAAc,QAAQ;AAAA,MACtE;AAAA,IACF;AACA,SAAK,0BAA0B,IAAI;AACnC,WAAO,MAAM,2BAA2B,MAAM,MAAM,QAAQ;AAAA,EAC9D;AAAA,EACA,4BAA4B,MAAM;AAChC,QAAI,CAAC,KAAK,QAAQ,KAAK,IAAI;AACzB,WAAK,gBAAgB,KAAK,IAAI,IAAI;AAAA,IACpC,OAAO;AACL,YAAM,4BAA4B,IAAI;AAAA,IACxC;AAAA,EACF;AAAA,EACA,2BAA2B,OAAO;AAChC,UAAM,QAAQ,UAAQ;AACpB,WAAK,QAAQ,OAAO,SAAS,KAAK,UAAU,wBAAwB;AAClE,aAAK,MAAM,SAAS,0BAA0B,KAAK,cAAc;AAAA,MACnE;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,iBAAiB,UAAU,YAAY;AACrC,SAAK,2BAA2B,QAAQ;AACxC,WAAO;AAAA,EACT;AAAA,EACA,eAAe,OAAO,cAAc,SAAS,qBAAqB;AAChE,UAAM,OAAO,MAAM,eAAe,OAAO,cAAc,SAAS,mBAAmB;AACnF,QAAI,KAAK,SAAS,mBAAmB;AACnC,WAAK,2BAA2B,KAAK,QAAQ;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA,EACA,eAAe,MAAM,UAAU,SAAS,OAAO;AAC7C,QAAI,CAAC,KAAK,sBAAsB,KAAK,KAAK,MAAM,EAAE,GAAG;AACnD,WAAK,MAAM,qBAAqB;AAChC,WAAK,KAAK;AACV,YAAM,oBAAoB,KAAK,YAAY,QAAQ;AACnD,wBAAkB,aAAa;AAC/B,aAAO,KAAK,WAAW,mBAAmB,qBAAqB;AAAA,IACjE;AACA,QAAI,iBAAiB;AACrB,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,kBAAkB,MAAM,IAAI;AACrD,UAAI,SAAS;AACX,cAAM,OAAO;AACb,eAAO;AAAA,MACT;AACA,YAAM,sBAAsB,iBAAiB;AAC7C,WAAK,KAAK;AAAA,IACZ;AACA,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,UAAI;AACJ,YAAM,SAAS,KAAK,mBAAmB,MAAM;AAC3C,YAAI,CAAC,WAAW,KAAK,qBAAqB,IAAI,GAAG;AAC/C,gBAAM,eAAe,KAAK,oCAAoC,QAAQ;AACtE,cAAI,cAAc;AAChB,mBAAO;AAAA,UACT;AAAA,QACF;AACA,cAAM,gBAAgB,KAAK,iCAAiC;AAC5D,YAAI,CAAC;AAAe;AACpB,YAAI,kBAAkB,CAAC,KAAK,MAAM,EAAE,GAAG;AACrC,iCAAuB,KAAK,MAAM,YAAY;AAC9C;AAAA,QACF;AACA,YAAI,gBAAgB,KAAK,MAAM,IAAI,GAAG;AACpC,gBAAMQ,UAAS,MAAM,8BAA8B,MAAM,UAAU,KAAK;AACxE,UAAAA,QAAO,iBAAiB;AACxB,iBAAOA;AAAA,QACT;AACA,YAAI,CAAC,WAAW,KAAK,IAAI,EAAE,GAAG;AAC5B,gBAAMR,QAAO,KAAK,YAAY,QAAQ;AACtC,UAAAA,MAAK,SAAS;AACd,UAAAA,MAAK,YAAY,KAAK,6BAA6B,IAAI,KAAK;AAC5D,eAAK,2BAA2BA,MAAK,SAAS;AAC9C,UAAAA,MAAK,iBAAiB;AACtB,cAAI,MAAM,qBAAqB;AAC7B,YAAAA,MAAK,WAAW;AAAA,UAClB;AACA,iBAAO,KAAK,qBAAqBA,OAAM,MAAM,mBAAmB;AAAA,QAClE;AACA,cAAM,YAAY,KAAK,MAAM;AAC7B,YAAI,cAAc,MAAM,cAAc,MAAM,cAAc,MAAM,wBAAwB,SAAS,KAAK,CAAC,KAAK,sBAAsB,GAAG;AACnI;AAAA,QACF;AACA,cAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,aAAK,aAAa;AAClB,aAAK,iBAAiB;AACtB,eAAO,KAAK,WAAW,MAAM,2BAA2B;AAAA,MAC1D,CAAC;AACD,UAAI,sBAAsB;AACxB,aAAK,WAAW,sBAAsB,EAAE;AAAA,MAC1C;AACA,UAAI,QAAQ;AACV,YAAI,OAAO,SAAS,gCAAgC,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,kBAAkB,MAAM,KAAK;AACxH,eAAK,MAAM,SAAS,mDAAmD,KAAK,MAAM,QAAQ;AAAA,QAC5F;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO,MAAM,eAAe,MAAM,UAAU,SAAS,KAAK;AAAA,EAC5D;AAAA,EACA,eAAe,MAAM;AACnB,QAAI;AACJ,UAAM,eAAe,IAAI;AACzB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,OAAO,SAAS,+BAA+B,GAAG,gBAAgB,OAAO,UAAU,QAAQ,cAAc,gBAAgB;AAC3H,WAAK,iBAAiB,OAAO;AAC7B,WAAK,SAAS,OAAO;AAAA,IACvB;AAAA,EACF;AAAA,EACA,YAAY,MAAM,cAAc,SAAS;AACvC,QAAI;AACJ,QAAI,wBAAwB,EAAE,IAAI,WAAW,CAAC,KAAK,sBAAsB,MAAM,KAAK,aAAa,EAAE,MAAM,cAAc,KAAK,aAAa,GAAG,KAAK;AAC/I,YAAM,OAAO,KAAK,YAAY,YAAY;AAC1C,WAAK,aAAa;AAClB,WAAK,iBAAiB,KAAK,SAAS,MAAM;AACxC,aAAK,KAAK;AACV,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,cAAI,aAAa;AACf,iBAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,UAAU;AAAA,cACxD,SAAS;AAAA,YACX,CAAC;AAAA,UACH;AACA,iBAAO,KAAK,qBAAqB;AAAA,QACnC;AACA,eAAO,KAAK,YAAY;AAAA,MAC1B,CAAC;AACD,WAAK,WAAW,MAAM,cAAc,0BAA0B,gBAAgB;AAC9E,WAAK,aAAa;AAClB,aAAO,KAAK,YAAY,MAAM,cAAc,OAAO;AAAA,IACrD;AACA,WAAO,MAAM,YAAY,MAAM,cAAc,OAAO;AAAA,EACtD;AAAA,EACA,kBAAkB,MAAM,UAAU,eAAe,WAAW;AAC1D,QAAI,CAAC,KAAK,MAAM,kBAAkB;AAChC,YAAM,kBAAkB,MAAM,UAAU,eAAe,SAAS;AAAA,IAClE;AAAA,EACF;AAAA,EACA,sBAAsB,MAAM;AAC1B,UAAM,sBAAsB,IAAI;AAChC,QAAI,KAAK,UAAU,KAAK,eAAe,SAAS;AAC9C,WAAK,MAAM,SAAS,+BAA+B,KAAK,WAAW,CAAC,EAAE,IAAI,KAAK;AAAA,IACjF;AAAA,EACF;AAAA,EACA,wBAAwB;AAAA,EAAC;AAAA,EACzB,uBAAuB,UAAU;AAC/B,QAAI,MAAM,uBAAuB,QAAQ;AAAG,aAAO;AACnD,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,YAAM,KAAK,KAAK,kBAAkB;AAClC,aAAO,WAAW,OAAO,OAAO,OAAO,KAAK,OAAO;AAAA,IACrD;AACA,WAAO,CAAC,YAAY,KAAK,aAAa,EAAE;AAAA,EAC1C;AAAA,EACA,iBAAiB,MAAM,UAAU,OAAO,KAAK;AAC3C,UAAM,iBAAiB,MAAM,UAAU,OAAO,GAAG;AACjD,QAAI,UAAU;AACZ,WAAK,aAAa,UAAU,SAAS,SAAS;AAAA,IAChD,OAAO;AACL,WAAK,aAAa,UAAU,UAAU,UAAU,WAAW,QAAQ;AAAA,IACrE;AAAA,EACF;AAAA,EACA,YAAY,MAAM;AAChB,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,WAAK,aAAa;AAClB,aAAO,MAAM,YAAY,IAAI;AAAA,IAC/B;AACA,QAAI;AACJ,QAAI,kBAAkB,KAAK,MAAM,IAAI,KAAK,KAAK,kBAAkB,MAAM,IAAI;AACzE,WAAK,aAAa;AAClB,aAAO,KAAK,+BAA+B,IAAI;AAAA,IACjD,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,YAAM,yBAAyB,KAAK,sBAAsB,MAAM,KAAK;AACrE,UAAI,KAAK,kBAAkB,MAAM,IAAI;AACnC,eAAO,KAAK,+BAA+B,MAAM,sBAAsB;AAAA,MACzE,OAAO;AACL,qBAAa,MAAM,8BAA8B,MAAM,sBAAsB;AAAA,MAC/E;AAAA,IACF,OAAO;AACL,mBAAa,MAAM,YAAY,IAAI;AAAA,IACrC;AACA,QAAI,WAAW,eAAe,UAAU,WAAW,WAAW,SAAS,KAAK,WAAW,WAAW,CAAC,EAAE,SAAS,0BAA0B;AACtI,WAAK,MAAM,SAAS,wCAAwC,UAAU;AAAA,IACxE;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM,YAAY;AAC5B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,KAAK;AACV,UAAI,yBAAyB;AAC7B,UAAI,KAAK,aAAa,GAAG,KAAK,KAAK,uBAAuB,KAAK,GAAG;AAChE,iCAAyB,KAAK,sBAAsB,MAAM,KAAK;AAAA,MACjE,OAAO;AACL,aAAK,aAAa;AAAA,MACpB;AACA,aAAO,KAAK,+BAA+B,MAAM,wBAAwB,IAAI;AAAA,IAC/E,WAAW,KAAK,IAAI,EAAE,GAAG;AACvB,YAAM,SAAS;AACf,aAAO,aAAa,MAAM,gBAAgB;AAC1C,WAAK,UAAU;AACf,WAAK,oBAAoB;AACzB,aAAO,KAAK,WAAW,QAAQ,oBAAoB;AAAA,IACrD,WAAW,KAAK,cAAc,EAAE,GAAG;AACjC,YAAM,OAAO;AACb,WAAK,iBAAiB,GAAG;AACzB,WAAK,KAAK,KAAK,gBAAgB;AAC/B,WAAK,UAAU;AACf,aAAO,KAAK,WAAW,MAAM,8BAA8B;AAAA,IAC7D,OAAO;AACL,aAAO,MAAM,YAAY,MAAM,UAAU;AAAA,IAC3C;AAAA,EACF;AAAA,EACA,kBAAkB;AAChB,WAAO,KAAK,aAAa,GAAG,KAAK,KAAK,UAAU,EAAE,SAAS;AAAA,EAC7D;AAAA,EACA,+BAA+B;AAC7B,QAAI,KAAK,gBAAgB,GAAG;AAC1B,YAAM,MAAM,KAAK,UAAU;AAC3B,WAAK,KAAK;AACV,UAAI,WAAW;AACf,aAAO,KAAK,WAAW,KAAK,MAAM,IAAI;AAAA,IACxC;AACA,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,YAAM,SAAS,KAAK,4BAA4B,KAAK,UAAU,CAAC;AAChE,UAAI;AAAQ,eAAO;AAAA,IACrB;AACA,WAAO,MAAM,6BAA6B;AAAA,EAC5C;AAAA,EACA,kBAAkB,MAAM,MAAM,0BAA0B,OAAO;AAC7D,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,cAAc,MAAM,kBAAkB,MAAM,MAAM,2BAA2B,gBAAgB;AACnG,QAAI,CAAC;AAAkB,aAAO;AAC9B,eAAW;AAAA,MACT;AAAA,MACA;AAAA,IACF,KAAK,YAAY,cAAc;AAC7B,UAAI,CAAC;AAAM;AACX,UAAI,SAAS,WAAW,CAAC,CAAC,GAAG,gBAAgB;AAC3C,aAAK,MAAM,SAAS,uCAAuC,IAAI;AAAA,MACjE,WAAW,CAAC,+BAA+B,MAAM,KAAK,UAAU,QAAQ,CAAC,GAAG;AAC1E,aAAK,MAAM,SAAS,qEAAqE,IAAI;AAAA,MAC/F;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,OAAO,YAAY;AACvC,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,sBAAsB,MAAM,GAAG;AACxD,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,OAAO,EAAE;AACd,aAAO,KAAK,uBAAuB,MAAM;AAAA,QACvC,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,aAAO,KAAK,uBAAuB,KAAK,UAAU,CAAC;AAAA,IACrD;AACA,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,YAAM,SAAS,KAAK,4BAA4B,KAAK,UAAU,CAAC;AAChE,UAAI;AAAQ,eAAO;AAAA,IACrB;AACA,WAAO,MAAM,sBAAsB,OAAO,UAAU;AAAA,EACtD;AAAA,EACA,sBAAsB;AACpB,WAAO,KAAK,gBAAgB,CAAC,UAAU,aAAa,SAAS,CAAC;AAAA,EAChE;AAAA,EACA,mBAAmB,QAAQ,WAAW;AACpC,WAAO,UAAU,KAAK,cAAY;AAChC,UAAI,mBAAmB,QAAQ,GAAG;AAChC,eAAO,OAAO,kBAAkB;AAAA,MAClC;AACA,aAAO,CAAC,CAAC,OAAO,QAAQ;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA,EACA,0BAA0B;AACxB,WAAO,KAAK,aAAa,GAAG,KAAK,KAAK,kBAAkB,MAAM;AAAA,EAChE;AAAA,EACA,iBAAiB,WAAW,QAAQ,OAAO;AACzC,UAAM,YAAY,CAAC,WAAW,WAAW,UAAU,aAAa,YAAY,YAAY,YAAY,QAAQ;AAC5G,SAAK,iBAAiB;AAAA,MACpB,kBAAkB;AAAA,MAClB,qBAAqB,CAAC,MAAM,KAAK;AAAA,MACjC,+BAA+B;AAAA,MAC/B,eAAe,SAAS;AAAA,IAC1B,GAAG,MAAM;AACT,UAAM,mCAAmC,MAAM;AAC7C,UAAI,KAAK,wBAAwB,GAAG;AAClC,aAAK,KAAK;AACV,aAAK,KAAK;AACV,YAAI,KAAK,mBAAmB,QAAQ,SAAS,GAAG;AAC9C,eAAK,MAAM,SAAS,+BAA+B,KAAK,MAAM,YAAY,CAAC;AAAA,QAC7E;AACA,cAAM,sBAAsB,WAAW,MAAM;AAAA,MAC/C,OAAO;AACL,aAAK,6BAA6B,WAAW,QAAQ,OAAO,CAAC,CAAC,OAAO,MAAM;AAAA,MAC7E;AAAA,IACF;AACA,QAAI,OAAO,SAAS;AAClB,WAAK,mBAAmB,gCAAgC;AAAA,IAC1D,OAAO;AACL,uCAAiC;AAAA,IACnC;AAAA,EACF;AAAA,EACA,6BAA6B,WAAW,QAAQ,OAAO,UAAU;AAC/D,UAAM,MAAM,KAAK,yBAAyB,MAAM;AAChD,QAAI,KAAK;AACP,gBAAU,KAAK,KAAK,GAAG;AACvB,UAAI,OAAO,UAAU;AACnB,aAAK,MAAM,SAAS,2BAA2B,MAAM;AAAA,MACvD;AACA,UAAI,OAAO,eAAe;AACxB,aAAK,MAAM,SAAS,gCAAgC,QAAQ;AAAA,UAC1D,UAAU,OAAO;AAAA,QACnB,CAAC;AAAA,MACH;AACA,UAAI,OAAO,SAAS;AAClB,aAAK,MAAM,SAAS,0BAA0B,MAAM;AAAA,MACtD;AACA,UAAI,OAAO,UAAU;AACnB,aAAK,MAAM,SAAS,2BAA2B,MAAM;AAAA,MACvD;AACA;AAAA,IACF;AACA,QAAI,CAAC,KAAK,MAAM,mBAAmB,OAAO,UAAU;AAClD,WAAK,MAAM,SAAS,mCAAmC,MAAM;AAAA,IAC/D;AACA,QAAI,OAAO,UAAU;AACnB,UAAI,CAAC,MAAM,eAAe;AACxB,aAAK,MAAM,SAAS,uBAAuB,MAAM;AAAA,MACnD;AAAA,IACF;AACA,UAAM,6BAA6B,WAAW,QAAQ,OAAO,QAAQ;AAAA,EACvE;AAAA,EACA,6BAA6B,cAAc;AACzC,UAAM,WAAW,KAAK,IAAI,EAAE;AAC5B,QAAI;AAAU,mBAAa,WAAW;AACtC,QAAI,aAAa,YAAY,KAAK,MAAM,EAAE,GAAG;AAC3C,WAAK,MAAM,SAAS,wBAAwB,YAAY;AAAA,IAC1D;AACA,QAAI,aAAa,WAAW,KAAK,MAAM,EAAE,GAAG;AAC1C,WAAK,MAAM,SAAS,uBAAuB,YAAY;AAAA,IACzD;AAAA,EACF;AAAA,EACA,yBAAyB,MAAM,MAAM,YAAY;AAC/C,UAAM,OAAO,KAAK,SAAS,eAAe,KAAK,2BAA2B,MAAM,MAAM,UAAU,IAAI;AACpG,WAAO,QAAQ,MAAM,yBAAyB,MAAM,MAAM,UAAU;AAAA,EACtE;AAAA,EACA,+BAA+B;AAC7B,QAAI,KAAK,qBAAqB;AAAG,aAAO;AACxC,WAAO,MAAM,6BAA6B;AAAA,EAC5C;AAAA,EACA,iBAAiB,MAAM,UAAU,qBAAqB;AACpD,QAAI,CAAC,KAAK,MAAM,0BAA0B,CAAC,KAAK,MAAM,EAAE,GAAG;AACzD,aAAO,MAAM,iBAAiB,MAAM,UAAU,mBAAmB;AAAA,IACnE;AACA,UAAM,SAAS,KAAK,SAAS,MAAM,MAAM,iBAAiB,MAAM,QAAQ,CAAC;AACzE,QAAI,CAAC,OAAO,MAAM;AAChB,UAAI,OAAO,OAAO;AAChB,cAAM,2BAA2B,qBAAqB,OAAO,KAAK;AAAA,MACpE;AACA,aAAO;AAAA,IACT;AACA,QAAI,OAAO;AAAO,WAAK,QAAQ,OAAO;AACtC,WAAO,OAAO;AAAA,EAChB;AAAA,EACA,eAAe,MAAM,UAAU;AAC7B,WAAO,MAAM,eAAe,MAAM,QAAQ;AAC1C,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,WAAW;AAChB,WAAK,iBAAiB,IAAI;AAAA,IAC5B;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,eAAe,KAAK,YAAY,QAAQ;AAC9C,mBAAa,aAAa;AAC1B,mBAAa,iBAAiB,KAAK,sBAAsB;AACzD,aAAO,KAAK,WAAW,cAAc,sBAAsB;AAAA,IAC7D;AACA,WAAO;AAAA,EACT;AAAA,EACA,uBAAuB,MAAM;AAC3B,QAAI,CAAC,KAAK,MAAM,oBAAoB,KAAK,aAAa,GAAG,GAAG;AAC1D,aAAO,KAAK,mBAAmB,MAAM,KAAK,uBAAuB,IAAI,CAAC;AAAA,IACxE;AACA,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,YAAY,KAAK,cAAc,GAAG;AACxC,QAAI,cAAc,KAAK,aAAa,GAAG,KAAK,CAAC,KAAK,6BAA6B,IAAI;AACjF,YAAM,KAAK,MAAM,SAAS,mCAAmC,KAAK,MAAM,QAAQ;AAAA,IAClF;AACA,UAAM,eAAe,kBAAkB,KAAK,MAAM,IAAI;AACtD,UAAM,cAAc,gBAAgB,KAAK,4BAA4B,KAAK,MAAM,uBAAuB,IAAI;AAC3G,QAAI,CAAC;AAAa,aAAO;AACzB,QAAI,YAAY,SAAS,4BAA4B,YAAY,SAAS,4BAA4B,WAAW;AAC/G,WAAK,aAAa;AAAA,IACpB;AACA,QAAI,WAAW;AACb,WAAK,mBAAmB,aAAa,QAAQ;AAC7C,kBAAY,UAAU;AAAA,IACxB;AACA,WAAO;AAAA,EACT;AAAA,EACA,aAAa,MAAM,aAAa,YAAY,aAAa;AACvD,SAAK,CAAC,eAAe,eAAe,KAAK,aAAa,GAAG,GAAG;AAC1D;AAAA,IACF;AACA,UAAM,aAAa,MAAM,aAAa,YAAY,KAAK,UAAU,OAAO,IAAI;AAC5E,UAAM,iBAAiB,KAAK,yBAAyB,KAAK,0BAA0B;AACpF,QAAI;AAAgB,WAAK,iBAAiB;AAAA,EAC5C;AAAA,EACA,6BAA6B,MAAM;AACjC,QAAI,CAAC,KAAK,UAAU;AAClB,UAAI,KAAK,IAAI,EAAE,GAAG;AAChB,aAAK,WAAW;AAAA,MAClB,WAAW,KAAK,IAAI,EAAE,GAAG;AACvB,aAAK,WAAW;AAAA,MAClB;AAAA,IACF;AACA,UAAM,OAAO,KAAK,yBAAyB;AAC3C,QAAI;AAAM,WAAK,iBAAiB;AAAA,EAClC;AAAA,EACA,mBAAmB,MAAM;AACvB,SAAK,6BAA6B,IAAI;AACtC,QAAI,KAAK,MAAM,oBAAoB,EAAE,KAAK,YAAY,CAAC,KAAK,mBAAmB,KAAK,MAAM,EAAE,GAAG;AAC7F,WAAK,MAAM,SAAS,iCAAiC,KAAK,MAAM,QAAQ;AAAA,IAC1E;AACA,QAAI,KAAK,YAAY,KAAK,MAAM,EAAE,GAAG;AACnC,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,WAAK,MAAM,SAAS,gCAAgC,KAAK,MAAM,UAAU;AAAA,QACvE,cAAc,IAAI,SAAS,gBAAgB,CAAC,KAAK,WAAW,IAAI,OAAO,IAAI,KAAK,MAAM,MAAM,IAAI,OAAO,IAAI,GAAG,CAAC;AAAA,MACjH,CAAC;AAAA,IACH;AACA,WAAO,MAAM,mBAAmB,IAAI;AAAA,EACtC;AAAA,EACA,0BAA0B,MAAM;AAC9B,QAAI,KAAK,UAAU;AACjB,WAAK,MAAM,SAAS,2BAA2B,IAAI;AAAA,IACrD;AACA,QAAI,KAAK,eAAe;AACtB,WAAK,MAAM,SAAS,gCAAgC,MAAM;AAAA,QACxD,UAAU,KAAK;AAAA,MACjB,CAAC;AAAA,IACH;AACA,SAAK,6BAA6B,IAAI;AACtC,WAAO,MAAM,0BAA0B,IAAI;AAAA,EAC7C;AAAA,EACA,2BAA2B,MAAM;AAC/B,SAAK,6BAA6B,IAAI;AACtC,QAAI,KAAK,UAAU;AACjB,WAAK,MAAM,SAAS,0BAA0B,IAAI;AAAA,IACpD;AACA,WAAO,MAAM,2BAA2B,IAAI;AAAA,EAC9C;AAAA,EACA,gBAAgB,WAAW,QAAQ,aAAa,SAAS,eAAe,mBAAmB;AACzF,UAAM,iBAAiB,KAAK,yBAAyB,KAAK,oBAAoB;AAC9E,QAAI,kBAAkB,eAAe;AACnC,WAAK,MAAM,SAAS,8BAA8B,cAAc;AAAA,IAClE;AACA,UAAM;AAAA,MACJ,UAAU;AAAA,MACV;AAAA,IACF,IAAI;AACJ,QAAI,YAAY,SAAS,SAAS,SAAS,QAAQ;AACjD,WAAK,MAAM,SAAS,iBAAiB,QAAQ;AAAA,QAC3C;AAAA,MACF,CAAC;AAAA,IACH;AACA,QAAI;AAAgB,aAAO,iBAAiB;AAC5C,UAAM,gBAAgB,WAAW,QAAQ,aAAa,SAAS,eAAe,iBAAiB;AAAA,EACjG;AAAA,EACA,uBAAuB,WAAW,QAAQ,aAAa,SAAS;AAC9D,UAAM,iBAAiB,KAAK,yBAAyB,KAAK,oBAAoB;AAC9E,QAAI;AAAgB,aAAO,iBAAiB;AAC5C,UAAM,uBAAuB,WAAW,QAAQ,aAAa,OAAO;AAAA,EACtE;AAAA,EACA,iCAAiC,MAAM,MAAM;AAC3C,QAAI,KAAK,SAAS;AAAmB;AACrC,QAAI,KAAK,SAAS,sBAAsB,CAAC,KAAK,MAAM;AAAM;AAC1D,UAAM,iCAAiC,MAAM,IAAI;AAAA,EACnD;AAAA,EACA,gBAAgB,MAAM;AACpB,UAAM,gBAAgB,IAAI;AAC1B,QAAI,KAAK,eAAe,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,IAAI;AACzD,WAAK,sBAAsB,KAAK,iCAAiC;AAAA,IACnE;AACA,QAAI,KAAK,cAAc,GAAG,GAAG;AAC3B,WAAK,aAAa,KAAK,sBAAsB,YAAY;AAAA,IAC3D;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM,UAAU,aAAa,SAAS,WAAW,YAAY,qBAAqB;AAClG,UAAM,iBAAiB,KAAK,yBAAyB,KAAK,oBAAoB;AAC9E,QAAI;AAAgB,WAAK,iBAAiB;AAC1C,WAAO,MAAM,kBAAkB,MAAM,UAAU,aAAa,SAAS,WAAW,YAAY,mBAAmB;AAAA,EACjH;AAAA,EACA,oBAAoB,MAAM,eAAe;AACvC,UAAM,iBAAiB,KAAK,yBAAyB,KAAK,oBAAoB;AAC9E,QAAI;AAAgB,WAAK,iBAAiB;AAC1C,UAAM,oBAAoB,MAAM,aAAa;AAAA,EAC/C;AAAA,EACA,WAAW,MAAM,MAAM;AACrB,UAAM,WAAW,MAAM,IAAI;AAC3B,QAAI,KAAK,GAAG,SAAS,gBAAgB,CAAC,KAAK,sBAAsB,KAAK,KAAK,IAAI,EAAE,GAAG;AAClF,WAAK,WAAW;AAAA,IAClB;AACA,UAAM,OAAO,KAAK,yBAAyB;AAC3C,QAAI,MAAM;AACR,WAAK,GAAG,iBAAiB;AACzB,WAAK,iBAAiB,KAAK,EAAE;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,kCAAkC,MAAM,MAAM;AAC5C,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,aAAa,KAAK,sBAAsB;AAAA,IAC/C;AACA,WAAO,MAAM,kCAAkC,MAAM,IAAI;AAAA,EAC3D;AAAA,EACA,iBAAiB,qBAAqB,gBAAgB;AACpD,QAAI,MAAM,OAAO,WAAW,OAAO;AACnC,QAAI;AACJ,QAAII;AACJ,QAAI;AACJ,QAAI,KAAK,UAAU,KAAK,MAAM,KAAK,MAAM,GAAG,KAAK,KAAK,MAAM,EAAE,IAAI;AAChE,cAAQ,KAAK,MAAM,MAAM;AACzB,MAAAA,OAAM,KAAK,SAAS,MAAM,MAAM,iBAAiB,qBAAqB,cAAc,GAAG,KAAK;AAC5F,UAAI,CAACA,KAAI;AAAO,eAAOA,KAAI;AAC3B,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK;AACT,YAAM,iBAAiB,QAAQ,QAAQ,SAAS,CAAC;AACjD,UAAI,mBAAmB,MAAM,UAAU,mBAAmB,MAAM,QAAQ;AACtE,gBAAQ,IAAI;AAAA,MACd;AAAA,IACF;AACA,QAAI,GAAG,OAAOA,SAAQ,QAAQ,KAAK,UAAU,CAAC,KAAK,MAAM,EAAE,GAAG;AAC5D,aAAO,MAAM,iBAAiB,qBAAqB,cAAc;AAAA,IACnE;AACA,QAAI,CAAC,SAAS,UAAU,KAAK;AAAO,cAAQ,KAAK,MAAM,MAAM;AAC7D,QAAI;AACJ,UAAM,QAAQ,KAAK,SAAS,WAAS;AACnC,UAAI,aAAa;AACjB,uBAAiB,KAAK,sBAAsB,KAAK,oBAAoB;AACrE,YAAM,OAAO,MAAM,iBAAiB,qBAAqB,cAAc;AACvE,UAAI,KAAK,SAAS,8BAA8B,cAAc,KAAK,UAAU,QAAQ,YAAY,eAAe;AAC9G,cAAM;AAAA,MACR;AACA,YAAM,kBAAkB,mBAAmB,OAAO,SAAS,gBAAgB,OAAO,YAAY,GAAG;AAC/F,aAAK,2BAA2B,MAAM,cAAc;AAAA,MACtD;AACA,WAAK,iBAAiB;AACtB,aAAO;AAAA,IACT,GAAG,KAAK;AACR,QAAI,CAAC,MAAM,SAAS,CAAC,MAAM,SAAS;AAClC,UAAI;AAAgB,aAAK,6BAA6B,cAAc;AACpE,aAAO,MAAM;AAAA,IACf;AACA,QAAI,CAACA,MAAK;AACR,aAAO,CAAC,KAAK,UAAU,KAAK,CAAC;AAC7B,iBAAW,KAAK,SAAS,MAAM,MAAM,iBAAiB,qBAAqB,cAAc,GAAG,KAAK;AACjG,UAAI,CAAC,SAAS;AAAO,eAAO,SAAS;AAAA,IACvC;AACA,SAAK,QAAQA,SAAQ,QAAQ,MAAM,MAAM;AACvC,WAAK,QAAQA,KAAI;AACjB,aAAOA,KAAI;AAAA,IACb;AACA,QAAI,MAAM,MAAM;AACd,WAAK,QAAQ,MAAM;AACnB,UAAI;AAAgB,aAAK,6BAA6B,cAAc;AACpE,aAAO,MAAM;AAAA,IACf;AACA,SAAK,YAAY,aAAa,QAAQ,UAAU,MAAM;AACpD,WAAK,QAAQ,SAAS;AACtB,aAAO,SAAS;AAAA,IAClB;AACA,YAAQ,QAAQA,SAAQ,OAAO,SAAS,MAAM,UAAU,MAAM,WAAW,aAAa,aAAa,OAAO,SAAS,WAAW;AAAA,EAChI;AAAA,EACA,6BAA6B,MAAM;AACjC,QAAI;AACJ,QAAI,KAAK,OAAO,WAAW,KAAK,CAAC,KAAK,OAAO,CAAC,EAAE,cAAc,GAAG,cAAc,KAAK,UAAU,QAAQ,YAAY,kBAAkB,KAAK,gBAAgB,cAAc,0BAA0B,GAAG;AAClM,WAAK,MAAM,SAAS,wBAAwB,IAAI;AAAA,IAClD;AAAA,EACF;AAAA,EACA,gBAAgB,qBAAqB,UAAU;AAC7C,QAAI,CAAC,KAAK,UAAU,KAAK,KAAK,KAAK,MAAM,EAAE,GAAG;AAC5C,aAAO,KAAK,qBAAqB;AAAA,IACnC;AACA,WAAO,MAAM,gBAAgB,qBAAqB,QAAQ;AAAA,EAC5D;AAAA,EACA,WAAW,MAAM;AACf,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,SAAS,KAAK,SAAS,WAAS;AACpC,cAAM,aAAa,KAAK,qCAAqC,EAAE;AAC/D,YAAI,KAAK,mBAAmB,KAAK,CAAC,KAAK,MAAM,EAAE;AAAG,gBAAM;AACxD,eAAO;AAAA,MACT,CAAC;AACD,UAAI,OAAO;AAAS;AACpB,UAAI,CAAC,OAAO,QAAQ;AAClB,YAAI,OAAO;AAAO,eAAK,QAAQ,OAAO;AACtC,aAAK,aAAa,OAAO;AAAA,MAC3B;AAAA,IACF;AACA,WAAO,MAAM,WAAW,IAAI;AAAA,EAC9B;AAAA,EACA,6BAA6B,OAAO,OAAO;AACzC,QAAI,EAAE,QAAQ;AAAI,aAAO;AACzB,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,WAAW;AAAA,IACnB;AACA,UAAM,OAAO,KAAK,yBAAyB;AAC3C,QAAI;AAAM,YAAM,iBAAiB;AACjC,SAAK,iBAAiB,KAAK;AAC3B,WAAO;AAAA,EACT;AAAA,EACA,aAAa,MAAM,WAAW;AAC5B,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,YAAY,SAAS;AAAA,MACrD,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO,MAAM,aAAa,MAAM,SAAS;AAAA,IAC7C;AAAA,EACF;AAAA,EACA,aAAa,MAAM,QAAQ,OAAO;AAChC,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,aAAK,oCAAoC,MAAM,KAAK;AACpD;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,YAAI,OAAO;AACT,eAAK,gBAAgB,iCAAiC,SAAS,+BAA+B,IAAI;AAAA,QACpG,OAAO;AACL,eAAK,MAAM,SAAS,+BAA+B,IAAI;AAAA,QACzD;AACA,aAAK,aAAa,KAAK,YAAY,KAAK;AACxC;AAAA,MACF,KAAK;AACH,YAAI,CAAC,SAAS,KAAK,KAAK,SAAS,wBAAwB;AACvD,eAAK,OAAO,KAAK,oBAAoB,KAAK,IAAI;AAAA,QAChD;AAAA,MACF;AACE,cAAM,aAAa,MAAM,KAAK;AAAA,IAClC;AAAA,EACF;AAAA,EACA,oCAAoC,MAAM,OAAO;AAC/C,YAAQ,KAAK,WAAW,MAAM;AAAA,MAC5B,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,aAAK,aAAa,KAAK,YAAY,KAAK;AACxC;AAAA,MACF;AACE,cAAM,aAAa,MAAM,KAAK;AAAA,IAClC;AAAA,EACF;AAAA,EACA,sBAAsB,MAAM,cAAc;AACxC,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,aAAK,sBAAsB,KAAK,YAAY,KAAK;AACjD;AAAA,MACF;AACE,cAAM,sBAAsB,MAAM,YAAY;AAAA,IAClD;AAAA,EACF;AAAA,EACA,YAAY,MAAM,2BAA2B,SAAS;AACpD,WAAO,OAAO;AAAA,MACZ,sBAAsB;AAAA,MACtB,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB,iBAAiB,YAAY,MAAM,CAAC,8BAA8B,CAAC,cAAc,IAAI;AAAA,MACrF,wBAAwB,YAAY,MAAM,CAAC,8BAA8B,CAAC,cAAc,IAAI;AAAA,MAC5F,kBAAkB,YAAY,MAAM,CAAC,8BAA8B,CAAC,cAAc,IAAI;AAAA,IACxF,GAAG,IAAI,KAAK,MAAM,YAAY,MAAM,2BAA2B,OAAO;AAAA,EACxE;AAAA,EACA,mBAAmB;AACjB,QAAI,KAAK,MAAM,SAAS,IAAI;AAC1B,aAAO,KAAK,gBAAgB,IAAI;AAAA,IAClC;AACA,WAAO,MAAM,iBAAiB;AAAA,EAChC;AAAA,EACA,6BAA6B,MAAM;AACjC,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,YAAM,gBAAgB,KAAK,iCAAiC;AAC5D,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,cAAM,OAAO,MAAM,6BAA6B,IAAI;AACpD,aAAK,iBAAiB;AACtB,eAAO;AAAA,MACT;AACA,WAAK,WAAW,MAAM,EAAE;AAAA,IAC1B;AACA,WAAO,MAAM,6BAA6B,IAAI;AAAA,EAChD;AAAA,EACA,oBAAoB,OAAO;AACzB,QAAI,KAAK,MAAM,oBAAoB,KAAK,MAAM,EAAE,KAAK,KAAK,kBAAkB,MAAM,OAAO;AACvF,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AACA,WAAO,MAAM,oBAAoB,KAAK;AAAA,EACxC;AAAA,EACA,gBAAgB;AACd,WAAO,KAAK,MAAM,EAAE,KAAK,MAAM,cAAc;AAAA,EAC/C;AAAA,EACA,kBAAkB;AAChB,WAAO,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,MAAM,gBAAgB;AAAA,EACnE;AAAA,EACA,kBAAkB,UAAU,MAAM;AAChC,UAAM,OAAO,MAAM,kBAAkB,UAAU,IAAI;AACnD,QAAI,KAAK,SAAS,uBAAuB,KAAK,kBAAkB,KAAK,MAAM,QAAQ,KAAK,eAAe,OAAO;AAC5G,WAAK,MAAM,SAAS,2BAA2B,KAAK,cAAc;AAAA,IACpE;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiBN,OAAM;AACrB,QAAI,KAAK,MAAM,QAAQ;AACrB,UAAIA,UAAS,IAAI;AACf,aAAK,SAAS,IAAI,CAAC;AACnB;AAAA,MACF;AACA,UAAIA,UAAS,IAAI;AACf,aAAK,SAAS,IAAI,CAAC;AACnB;AAAA,MACF;AAAA,IACF;AACA,UAAM,iBAAiBA,KAAI;AAAA,EAC7B;AAAA,EACA,eAAe;AACb,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAAS,IAAI;AACf,WAAK,MAAM,OAAO;AAClB,WAAK,aAAa;AAAA,IACpB,WAAW,SAAS,IAAI;AACtB,WAAK,MAAM,OAAO;AAClB,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AAAA,EACA,YAAY;AACV,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAAS,IAAI;AACf,WAAK,MAAM,OAAO;AAClB,WAAK,SAAS,IAAI,CAAC;AACnB,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB,UAAU,kBAAkB,OAAO;AAClD,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,OAAO,SAAS,CAAC;AACvB,WAAK,QAAQ,OAAO,SAAS,KAAK,UAAU,wBAAwB;AAClE,iBAAS,CAAC,IAAI,KAAK,oBAAoB,IAAI;AAAA,MAC7C;AAAA,IACF;AACA,UAAM,iBAAiB,UAAU,kBAAkB,KAAK;AAAA,EAC1D;AAAA,EACA,oBAAoB,MAAM;AACxB,SAAK,WAAW,iBAAiB,KAAK;AACtC,SAAK,iBAAiB,KAAK,YAAY,KAAK,eAAe,IAAI,GAAG;AAClE,WAAO,KAAK;AAAA,EACd;AAAA,EACA,iBAAiB,QAAQ;AACvB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,OAAO,MAAM,UAAQ,KAAK,aAAa,MAAM,IAAI,CAAC;AAAA,IAC3D;AACA,WAAO,MAAM,iBAAiB,MAAM;AAAA,EACtC;AAAA,EACA,wBAAwB;AACtB,WAAO,KAAK,MAAM,EAAE,KAAK,MAAM,sBAAsB;AAAA,EACvD;AAAA,EACA,0BAA0B;AACxB,WAAO,MAAM,wBAAwB,KAAK,KAAK,gBAAgB;AAAA,EACjE;AAAA,EACA,gCAAgC,MAAM;AACpC,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,YAAM,gBAAgB,KAAK,mBAAmB,MAAM,KAAK,iCAAiC,CAAC;AAC3F,UAAI;AAAe,aAAK,iBAAiB;AAAA,IAC3C;AACA,WAAO,MAAM,gCAAgC,IAAI;AAAA,EACnD;AAAA,EACA,kCAAkC,QAAQ;AACxC,UAAM,YAAY,MAAM,kCAAkC,MAAM;AAChE,UAAM,SAAS,KAAK,6BAA6B,MAAM;AACvD,UAAM,aAAa,OAAO,CAAC;AAC3B,UAAM,kBAAkB,cAAc,KAAK,YAAY,UAAU;AACjE,WAAO,kBAAkB,YAAY,IAAI;AAAA,EAC3C;AAAA,EACA,wBAAwB;AACtB,UAAM,QAAQ,MAAM,sBAAsB;AAC1C,UAAM,OAAO,KAAK,yBAAyB;AAC3C,QAAI,MAAM;AACR,YAAM,iBAAiB;AACvB,WAAK,iBAAiB,KAAK;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA,EACA,mBAAmB,IAAI;AACrB,UAAM,sBAAsB,KAAK,MAAM;AACvC,SAAK,MAAM,mBAAmB;AAC9B,QAAI;AACF,aAAO,GAAG;AAAA,IACZ,UAAE;AACA,WAAK,MAAM,mBAAmB;AAAA,IAChC;AAAA,EACF;AAAA,EACA,WAAW,MAAM,aAAa,YAAY;AACxC,UAAM,qBAAqB,KAAK,MAAM;AACtC,SAAK,MAAM,kBAAkB,CAAC,CAAC,KAAK;AACpC,QAAI;AACF,aAAO,MAAM,WAAW,MAAM,aAAa,UAAU;AAAA,IACvD,UAAE;AACA,WAAK,MAAM,kBAAkB;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,2BAA2B,MAAM,YAAY;AAC3C,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,WAAW;AAChB,aAAO,KAAK,oBAAoB,YAAY,KAAK,WAAW,MAAM,MAAM,KAAK,CAAC;AAAA,IAChF,WAAW,KAAK,aAAa,GAAG,GAAG;AACjC,UAAI,CAAC,KAAK,sBAAsB,GAAG;AACjC,aAAK,WAAW;AAChB,aAAK,MAAM,SAAS,0CAA0C,IAAI;AAClE,eAAO,KAAK,4BAA4B,IAAI;AAAA,MAC9C;AAAA,IACF,OAAO;AACL,WAAK,WAAW,MAAM,EAAE;AAAA,IAC1B;AAAA,EACF;AAAA,EACA,YAAY,MAAM,aAAa,SAAS,eAAe,kBAAkB,MAAM,cAAc;AAC3F,UAAM,SAAS,MAAM,YAAY,MAAM,aAAa,SAAS,eAAe,kBAAkB,MAAM,YAAY;AAChH,QAAI,OAAO,UAAU;AACnB,YAAM,UAAU,KAAK,UAAU,QAAQ,IAAI,CAAC,CAAC,OAAO,MAAM,OAAO,CAAC,CAAC,OAAO;AAC1E,UAAI,SAAS;AACX,cAAM;AAAA,UACJ;AAAA,QACF,IAAI;AACJ,aAAK,MAAM,SAAS,iCAAiC,QAAQ;AAAA,UAC3D,YAAY,IAAI,SAAS,gBAAgB,CAAC,OAAO,WAAW,IAAI,OAAO,IAAI,KAAK,MAAM,MAAM,IAAI,OAAO,IAAI,GAAG,CAAC;AAAA,QACjH,CAAC;AAAA,MACH;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B;AACzB,UAAM,WAAW,KAAK,gBAAgB;AACtC,WAAO,SAAS;AAAA,EAClB;AAAA,EACA,8BAA8B;AAC5B,WAAO,CAAC,CAAC,KAAK,gBAAgB,cAAc,KAAK;AAAA,EACnD;AAAA,EACA,QAAQ;AACN,QAAI,KAAK,4BAA4B,GAAG;AACtC,WAAK,MAAM,mBAAmB;AAAA,IAChC;AACA,WAAO,MAAM,MAAM;AAAA,EACrB;AAAA,EACA,gBAAgB;AACd,QAAI,KAAK,4BAA4B,GAAG;AACtC,WAAK,MAAM,mBAAmB;AAAA,IAChC;AACA,WAAO,MAAM,cAAc;AAAA,EAC7B;AAAA,EACA,qBAAqB,MAAM,UAAU,gBAAgB,iBAAiB;AACpE,QAAI,CAAC,YAAY,iBAAiB;AAChC,WAAK,mCAAmC,MAAM,OAAO,cAAc;AACnE,aAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,IAChD;AACA,SAAK,aAAa;AAClB,WAAO,MAAM,qBAAqB,MAAM,UAAU,gBAAgB,eAAe;AAAA,EACnF;AAAA,EACA,qBAAqB,WAAW,kBAAkB,oBAAoB,iBAAiB,aAAa;AAClG,QAAI,CAAC,oBAAoB,iBAAiB;AACxC,WAAK,mCAAmC,WAAW,MAAM,kBAAkB;AAC3E,aAAO,KAAK,WAAW,WAAW,iBAAiB;AAAA,IACrD;AACA,cAAU,aAAa;AACvB,WAAO,MAAM,qBAAqB,WAAW,kBAAkB,oBAAoB,iBAAiB,qBAAqB,OAAO,IAAI;AAAA,EACtI;AAAA,EACA,mCAAmC,MAAM,UAAU,0BAA0B;AAC3E,UAAM,cAAc,WAAW,aAAa;AAC5C,UAAM,eAAe,WAAW,UAAU;AAC1C,QAAI,WAAW,KAAK,WAAW;AAC/B,QAAI;AACJ,QAAI,mBAAmB;AACvB,QAAI,oBAAoB;AACxB,UAAM,MAAM,SAAS,IAAI;AACzB,QAAI,KAAK,aAAa,EAAE,GAAG;AACzB,YAAM,UAAU,KAAK,gBAAgB;AACrC,UAAI,KAAK,aAAa,EAAE,GAAG;AACzB,cAAM,WAAW,KAAK,gBAAgB;AACtC,YAAI,2BAA2B,KAAK,MAAM,IAAI,GAAG;AAC/C,6BAAmB;AACnB,qBAAW;AACX,sBAAY,WAAW,KAAK,gBAAgB,IAAI,KAAK,sBAAsB;AAC3E,8BAAoB;AAAA,QACtB,OAAO;AACL,sBAAY;AACZ,8BAAoB;AAAA,QACtB;AAAA,MACF,WAAW,2BAA2B,KAAK,MAAM,IAAI,GAAG;AACtD,4BAAoB;AACpB,oBAAY,WAAW,KAAK,gBAAgB,IAAI,KAAK,sBAAsB;AAAA,MAC7E,OAAO;AACL,2BAAmB;AACnB,mBAAW;AAAA,MACb;AAAA,IACF,WAAW,2BAA2B,KAAK,MAAM,IAAI,GAAG;AACtD,yBAAmB;AACnB,UAAI,UAAU;AACZ,mBAAW,KAAK,gBAAgB,IAAI;AACpC,YAAI,CAAC,KAAK,aAAa,EAAE,GAAG;AAC1B,eAAK,kBAAkB,SAAS,MAAM,SAAS,IAAI,OAAO,MAAM,IAAI;AAAA,QACtE;AAAA,MACF,OAAO;AACL,mBAAW,KAAK,sBAAsB;AAAA,MACxC;AAAA,IACF;AACA,QAAI,oBAAoB,0BAA0B;AAChD,WAAK,MAAM,WAAW,SAAS,kCAAkC,SAAS,iCAAiC,GAAG;AAAA,IAChH;AACA,SAAK,WAAW,IAAI;AACpB,SAAK,YAAY,IAAI;AACrB,UAAM,UAAU,WAAW,eAAe;AAC1C,SAAK,OAAO,IAAI,mBAAmB,SAAS;AAC5C,QAAI,qBAAqB,KAAK,cAAc,EAAE,GAAG;AAC/C,WAAK,YAAY,IAAI,WAAW,KAAK,gBAAgB,IAAI,KAAK,sBAAsB;AAAA,IACtF;AACA,QAAI,CAAC,KAAK,YAAY,GAAG;AACvB,WAAK,YAAY,IAAI,gBAAgB,KAAK,WAAW,CAAC;AAAA,IACxD;AACA,QAAI,UAAU;AACZ,WAAK,gBAAgB,KAAK,YAAY,GAAG,mBAAmB,OAAO,IAAI;AAAA,IACzE;AAAA,EACF;AACF;AACA,SAAS,sBAAsB,YAAY;AACzC,MAAI,WAAW,SAAS;AAAoB,WAAO;AACnD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI;AACJ,MAAI,YAAY,SAAS,SAAS,oBAAoB,SAAS,SAAS,qBAAqB,SAAS,YAAY,SAAS,IAAI;AAC7H,WAAO;AAAA,EACT;AACA,SAAO,kCAAkC,WAAW,MAAM;AAC5D;AACA,SAAS,+BAA+B,YAAYW,SAAQ;AAC1D,MAAI;AACJ,QAAM;AAAA,IACJ;AAAA,EACF,IAAI;AACJ,OAAK,oBAAoB,WAAW,UAAU,QAAQ,kBAAkB,eAAe;AACrF,WAAO;AAAA,EACT;AACA,MAAIA,SAAQ;AACV,QAAI,SAAS,WAAW;AACtB,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,UAAI,OAAO,UAAU,YAAY,OAAO,UAAU,WAAW;AAC3D,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,OAAO;AACL,QAAI,SAAS,mBAAmB,SAAS,kBAAkB;AACzD,aAAO;AAAA,IACT;AAAA,EACF;AACA,MAAI,SAAS,YAAYA,OAAM,KAAK,iBAAiB,YAAYA,OAAM,GAAG;AACxE,WAAO;AAAA,EACT;AACA,MAAI,SAAS,qBAAqB,WAAW,YAAY,WAAW,GAAG;AACrE,WAAO;AAAA,EACT;AACA,MAAI,sBAAsB,UAAU,GAAG;AACrC,WAAO;AAAA,EACT;AACA,SAAO;AACT;AACA,SAAS,SAAS,YAAYA,SAAQ;AACpC,MAAIA,SAAQ;AACV,WAAO,WAAW,SAAS,cAAc,OAAO,WAAW,UAAU,YAAY,YAAY;AAAA,EAC/F;AACA,SAAO,WAAW,SAAS,oBAAoB,WAAW,SAAS;AACrE;AACA,SAAS,iBAAiB,YAAYA,SAAQ;AAC5C,MAAI,WAAW,SAAS,mBAAmB;AACzC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI;AACJ,QAAI,aAAa,OAAO,SAAS,UAAUA,OAAM,GAAG;AAClD,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,kCAAkC,YAAY;AACrD,MAAI,WAAW,SAAS;AAAc,WAAO;AAC7C,MAAI,WAAW,SAAS,sBAAsB,WAAW,UAAU;AACjE,WAAO;AAAA,EACT;AACA,SAAO,kCAAkC,WAAW,MAAM;AAC5D;AACA,MAAM,oBAAoB,6BAA6B;AAAA,EACrD,qBAAqB;AAAA,EACrB,iBAAiB;AACnB,CAAC;AACD,IAAI,eAAe,gBAAc,MAAM,gCAAgC,WAAW;AAAA,EAChF,iBAAiB,cAAc;AAC7B,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,KAAK;AACV,WAAK,cAAc;AACnB,WAAK,OAAO,MAAM,gBAAgB,IAAI;AACtC,WAAK,cAAc;AACnB,WAAK,OAAO,GAAG;AACf,aAAO,KAAK,kBAAkB,MAAM,YAAY;AAAA,IAClD;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM,cAAc;AACpC,UAAM,aAAa,CAAC,EAAE,KAAK,gBAAgB,KAAK,SAAS;AACzD,SAAK,eAAe;AACpB,WAAO,aAAa,OAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAChE;AAAA,EACA,iBAAiBX,OAAM;AACrB,QAAIA,UAAS,MAAM,KAAK,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,IAAI;AACnE,WAAK,SAAS,KAAK,CAAC;AAAA,IACtB,OAAO;AACL,YAAM,iBAAiBA,KAAI;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,cAAc,qBAAqB;AACjC,WAAO,KAAK,iBAAiB,YAAY,KAAK,MAAM,cAAc,mBAAmB;AAAA,EACvF;AAAA,EACA,gBAAgB,SAAS;AACvB,WAAO,KAAK,iBAAiB,YAAY,KAAK,MAAM,gBAAgB,OAAO;AAAA,EAC7E;AAAA,EACA,kBAAkB,MAAM,UAAU,eAAe,WAAW;AAC1D,QAAI,SAAS,QAAW;AACtB,YAAM,kBAAkB,MAAM,UAAU,eAAe,SAAS;AAAA,IAClE;AAAA,EACF;AAAA,EACA,mBAAmB;AACjB,WAAO,KAAK,iBAAiB,SAAS,KAAK,MAAM,iBAAiB;AAAA,EACpE;AAAA,EACA,YAAY,MAAM,iBAAiB,SAAS;AAC1C,WAAO,SAAS,iBAAiB,MAAM,YAAY,MAAM,iBAAiB,OAAO;AAAA,EACnF;AAAA,EACA,aAAa,MAAM,OAAO;AACxB,QAAI,QAAQ,KAAK,SAAS,iBAAiB,KAAK,iBAAiB,cAAc;AAC7E,WAAK,eAAe;AAAA,IACtB,OAAO;AACL,YAAM,aAAa,MAAM,KAAK;AAAA,IAChC;AAAA,EACF;AAAA,EACA,0BAA0B,IAAI,KAAK;AACjC,QAAI,MAAM,0BAA0B,IAAI,GAAG,GAAG;AAC5C,aAAO;AAAA,IACT;AACA,UAAM,YAAY,KAAK,UAAU;AACjC,QAAI,UAAU,SAAS,KAAK;AAC1B,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,oBAAoB,MAAM,SAAS;AACjC,QAAI,KAAK,SAAS,KAAK,MAAM,SAAS;AAAe;AACrD,UAAM,oBAAoB,MAAM,OAAO;AAAA,EACzC;AAAA,EACA,yBAAyB,MAAM,MAAM;AACnC,QAAI;AACJ,QAAI,KAAK,SAAS,kBAAkB,cAAc,KAAK,UAAU,QAAQ,YAAY,eAAe;AAClG,aAAO,MAAM,yBAAyB,MAAM,IAAI;AAAA,IAClD;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,OAAO;AACb,WAAK,QAAQ,KAAK,kBAAkB,MAAM,YAAY;AACtD,WAAK,KAAK;AACV,WAAK,OAAO,MAAM,gDAAgD;AAClE,aAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,IACjD;AACA,SAAK,UAAU;AACf,SAAK,OAAO,KAAK;AACjB,WAAO,KAAK,kBAAkB,MAAM,WAAW;AAAA,EACjD;AAAA,EACA,WAAW,iBAAiB,uBAAuB,iBAAiB;AAClE,WAAO,KAAK,iBAAiB,gBAAgB,KAAK,MAAM,WAAW,iBAAiB,uBAAuB,eAAe;AAAA,EAC5H;AAAA,EACA,gBAAgB,WAAW;AACzB,WAAO,KAAK,iBAAiB,YAAY,KAAK,MAAM,gBAAgB,SAAS;AAAA,EAC/E;AAAA,EACA,WAAW,MAAM,aAAa,YAAY;AACxC,UAAM,OAAO,cAAc,qBAAqB;AAChD,SAAK,KAAK;AACV,UAAM,YAAY,KAAK,MAAM;AAC7B,UAAM,cAAc,KAAK,iBAAiB,YAAY;AACtD,QAAI,aAAa;AACf,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,GAAG,KAAK,KAAK,MAAM,CAAC,GAAG;AACtD,aAAK,KAAK;AAAA,MACZ,WAAW,cAAc,CAAC,aAAa;AACrC,aAAK,KAAK;AACV,aAAK,OAAO,KAAK,kBAAkB,aAAa,WAAW;AAC3D,eAAO,KAAK,WAAW,MAAM,IAAI;AAAA,MACnC,OAAO;AACL,cAAM,KAAK,MAAM,kBAAkB,qBAAqB,KAAK,MAAM,QAAQ;AAAA,MAC7E;AAAA,IACF,OAAO;AACL,WAAK,aAAa,MAAM,aAAa,UAAU;AAAA,IACjD;AACA,UAAM,gBAAgB,IAAI;AAC1B,SAAK,OAAO,KAAK,iBAAiB,WAAW,KAAK,MAAM,eAAe,CAAC,CAAC,KAAK,YAAY,SAAS;AACnG,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,YAAY,MAAM,YAAY;AAC5B,UAAM,cAAc,KAAK,iBAAiB,YAAY;AACtD,QAAI,CAAC;AAAa,aAAO,MAAM,YAAY,MAAM,UAAU;AAC3D,QAAI,CAAC,KAAK,aAAa,EAAE,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AAC7C,WAAK,aAAa,CAAC;AACnB,WAAK,SAAS;AACd,WAAK,cAAc,KAAK,kBAAkB,aAAa,aAAa;AACpE,aAAO,KAAK,WAAW,MAAM,wBAAwB;AAAA,IACvD;AACA,SAAK,aAAa,mBAAmB;AACrC,UAAM,YAAY,KAAK,UAAU;AACjC,cAAU,WAAW;AACrB,SAAK,aAAa,CAAC,KAAK,WAAW,WAAW,wBAAwB,CAAC;AACvE,WAAO,MAAM,YAAY,MAAM,UAAU;AAAA,EAC3C;AAAA,EACA,2BAA2B;AACzB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,OAAO,KAAK,eAAe;AACjC,UAAI,KAAK,qBAAqB,MAAM,MAAM,GAAG;AAC3C,YAAI,KAAK,MAAM,WAAW,eAAe,GAAG,GAAG,KAAK,oBAAoB,OAAO,CAAC,CAAC,GAAG;AAClF,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,WAAO,MAAM,yBAAyB;AAAA,EACxC;AAAA,EACA,iCAAiC,MAAM,wBAAwB;AAC7D,QAAI;AACJ,SAAK,cAAc,KAAK,eAAe,QAAQ,YAAY,QAAQ;AACjE,aAAO;AAAA,IACT;AACA,WAAO,MAAM,iCAAiC,MAAM,sBAAsB;AAAA,EAC5E;AAAA,EACA,YAAY,MAAM;AAChB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,cAAc,QAAQ,WAAW,QAAQ;AAC3C,WAAK,aAAa,WAAW,OAAO,CAAAE,UAAQA,MAAK,SAAS,SAAS,aAAa;AAAA,IAClF;AACA,UAAM,YAAY,IAAI;AACtB,SAAK,aAAa;AAAA,EACpB;AAAA,EACA,YAAY,MAAM;AAChB,UAAM,cAAc,KAAK,iBAAiB,YAAY;AACtD,QAAI,CAAC;AAAa,aAAO,MAAM,YAAY,IAAI;AAC/C,SAAK,aAAa,CAAC;AACnB,QAAI,CAAC,KAAK,aAAa,EAAE,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AAC7C,WAAK,SAAS,KAAK,kBAAkB,aAAa,eAAe;AACjE,WAAK,UAAU;AACf,aAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,IAClD;AACA,UAAM,YAAY,KAAK,gBAAgB,WAAW;AAClD,cAAU,QAAQ;AAClB,SAAK,WAAW,KAAK,KAAK,WAAW,WAAW,wBAAwB,CAAC;AACzE,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,gBAAgB,KAAK,8BAA8B,IAAI;AAC7D,UAAI,CAAC;AAAe,aAAK,2BAA2B,IAAI;AAAA,IAC1D;AACA,SAAK,iBAAiB,EAAE;AACxB,SAAK,SAAS,KAAK,kBAAkB;AACrC,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,oBAAoB;AAClB,WAAO,KAAK,iBAAiB,eAAe,KAAK,MAAM,kBAAkB;AAAA,EAC3E;AAAA,EACA,gBAAgB;AACd,QAAI,KAAK,MAAM,QAAQ,KAAK,MAAM,cAAc,OAAO;AACrD,WAAK,MAAM,kBAAkB,iBAAiB,KAAK,MAAM,aAAa;AAAA,IACxE;AAAA,EACF;AACF;AACA,IAAI,cAAc,gBAAc,MAAM,yBAAyB,WAAW;AAAA,EACxE,mBAAmB;AACjB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,sBAAsB,KAAK,MAAM;AACvC,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,KAAK;AACV,UAAI,kBAAkB,KAAK,MAAM,IAAI,GAAG;AACtC,cAAM,OAAO,KAAK,oBAAoB;AACtC,cAAM,aAAa,KAAK,iBAAiB,MAAM,IAAI;AACnD,mBAAW,OAAO;AAClB,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,iBAAO;AAAA,QACT;AAAA,MACF;AACA,WAAK,WAAW,mBAAmB;AAAA,IACrC;AAAA,EACF;AAAA,EACA,cAAc,qBAAqB;AACjC,WAAO,KAAK,iBAAiB,KAAK,MAAM,cAAc,mBAAmB;AAAA,EAC3E;AACF;AACA,SAAS,UAAU,SAAS,gBAAgB;AAC1C,QAAM,CAAC,cAAc,eAAe,IAAI,OAAO,mBAAmB,WAAW,CAAC,gBAAgB,CAAC,CAAC,IAAI;AACpG,QAAM,eAAe,OAAO,KAAK,eAAe;AAChD,QAAM,yBAAyB,aAAa,WAAW;AACvD,SAAO,QAAQ,KAAK,OAAK;AACvB,QAAI,OAAO,MAAM,UAAU;AACzB,aAAO,0BAA0B,MAAM;AAAA,IACzC,OAAO;AACL,YAAM,CAAC,YAAY,aAAa,IAAI;AACpC,UAAI,eAAe,cAAc;AAC/B,eAAO;AAAA,MACT;AACA,iBAAW,OAAO,cAAc;AAC9B,YAAI,cAAc,GAAG,MAAM,gBAAgB,GAAG,GAAG;AAC/C,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH;AACA,SAAS,gBAAgB,SAAS,MAAM,QAAQ;AAC9C,QAAM,SAAS,QAAQ,KAAK,CAAAU,YAAU;AACpC,QAAI,MAAM,QAAQA,OAAM,GAAG;AACzB,aAAOA,QAAO,CAAC,MAAM;AAAA,IACvB,OAAO;AACL,aAAOA,YAAW;AAAA,IACpB;AAAA,EACF,CAAC;AACD,MAAI,UAAU,MAAM,QAAQ,MAAM,KAAK,OAAO,SAAS,GAAG;AACxD,WAAO,OAAO,CAAC,EAAE,MAAM;AAAA,EACzB;AACA,SAAO;AACT;AACA,MAAM,qBAAqB,CAAC,WAAW,UAAU,QAAQ,OAAO;AAChE,MAAM,eAAe,CAAC,MAAM,MAAM,KAAK,KAAK,GAAG;AAC/C,MAAM,gCAAgC,CAAC,QAAQ,KAAK;AACpD,SAAS,gBAAgB,SAAS;AAChC,MAAI,UAAU,SAAS,YAAY,GAAG;AACpC,QAAI,UAAU,SAAS,mBAAmB,GAAG;AAC3C,YAAM,IAAI,MAAM,iEAAiE;AAAA,IACnF;AACA,UAAM,yBAAyB,gBAAgB,SAAS,cAAc,wBAAwB;AAC9F,QAAI,0BAA0B,QAAQ,OAAO,2BAA2B,WAAW;AACjF,YAAM,IAAI,MAAM,2DAA2D;AAAA,IAC7E;AACA,UAAM,yBAAyB,gBAAgB,SAAS,cAAc,wBAAwB;AAC9F,QAAI,0BAA0B,QAAQ,OAAO,2BAA2B,WAAW;AACjF,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAAA,EACF;AACA,MAAI,UAAU,SAAS,MAAM,KAAK,UAAU,SAAS,YAAY,GAAG;AAClE,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC/D;AACA,MAAI,UAAU,SAAS,cAAc,KAAK,UAAU,SAAS,aAAa,GAAG;AAC3E,UAAM,IAAI,MAAM,sDAAsD;AAAA,EACxE;AACA,MAAI,UAAU,SAAS,kBAAkB,GAAG;AAC1C,UAAM,WAAW,gBAAgB,SAAS,oBAAoB,UAAU;AACxE,QAAI,CAAC,mBAAmB,SAAS,QAAQ,GAAG;AAC1C,YAAM,eAAe,mBAAmB,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI;AACpE,YAAM,IAAI,MAAM,6EAA6E,YAAY,GAAG;AAAA,IAC9G;AACA,UAAM,oBAAoB,UAAU,SAAS,CAAC,kBAAkB;AAAA,MAC9D,YAAY;AAAA,IACd,CAAC,CAAC;AACF,QAAI,aAAa,QAAQ;AACvB,UAAI,UAAU,SAAS,cAAc,GAAG;AACtC,cAAM,IAAI,MAAM,0DAA0D;AAAA,MAC5E;AACA,UAAI,UAAU,SAAS,aAAa,GAAG;AACrC,cAAM,IAAI,MAAM,yDAAyD;AAAA,MAC3E;AACA,YAAM,aAAa,gBAAgB,SAAS,oBAAoB,YAAY;AAC5E,UAAI,CAAC,aAAa,SAAS,UAAU,GAAG;AACtC,cAAM,YAAY,aAAa,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI;AAC3D,cAAM,IAAI,MAAM,iHAAiH,SAAS,GAAG;AAAA,MAC/I;AACA,UAAI,eAAe,OAAO,mBAAmB;AAC3C,cAAM,IAAI,MAAM,wIAAwI;AAAA,MAC1J;AAAA,IACF,WAAW,aAAa,WAAW,mBAAmB;AACpD,YAAM,IAAI,MAAM,wHAAwH;AAAA,IAC1I;AAAA,EACF;AACA,MAAI,UAAU,SAAS,kBAAkB,GAAG;AAC1C;AACE,UAAI,UAAU,SAAS,kBAAkB,KAAK,UAAU,SAAS,kBAAkB,GAAG;AACpF,cAAM,IAAI,MAAM,iFAAiF;AAAA,MACnG;AACA,YAAM,sCAAsC,gBAAgB,SAAS,oBAAoB,SAAS;AAClG,UAAI,wCAAwC,YAAY;AACtD,cAAM,IAAI,MAAM,sJAAgK;AAAA,MAClL;AAAA,IACF;AAAA,EACF;AACA,MAAI,UAAU,SAAS,kBAAkB,KAAK,UAAU,SAAS,kBAAkB,GAAG;AACpF,UAAM,IAAI,MAAM,+DAA+D;AAAA,EACjF;AACA,MAAI,UAAU,SAAS,gBAAgB,KAAK,gBAAgB,SAAS,kBAAkB,YAAY,KAAK,QAAQ,CAAC,8BAA8B,SAAS,gBAAgB,SAAS,kBAAkB,YAAY,CAAC,GAAG;AACjN,UAAM,IAAI,MAAM,4EAA4E,8BAA8B,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,CAAC;AAAA,EACzJ;AACA,MAAI,UAAU,SAAS,oBAAoB,KAAK,CAAC,UAAU,SAAS,eAAe,GAAG;AACpF,UAAM,QAAQ,IAAI,MAAM,8FAA8F;AACtH,UAAM,iBAAiB;AACvB,UAAM;AAAA,EACR;AACA,MAAI,UAAU,SAAS,wBAAwB,KAAK,gBAAgB,SAAS,0BAA0B,SAAS,MAAM,WAAW;AAC/H,UAAM,IAAI,MAAM,2JAAqK;AAAA,EACvL;AACF;AACA,MAAM,eAAe;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,MAAM,mBAAmB,OAAO,KAAK,YAAY;AACjD,MAAM,iBAAiB;AAAA,EACrB,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,aAAa;AAAA,EACb,WAAW;AAAA,EACX,2BAA2B;AAAA,EAC3B,4BAA4B;AAAA,EAC5B,+BAA+B;AAAA,EAC/B,6BAA6B;AAAA,EAC7B,yBAAyB;AAAA,EACzB,wBAAwB;AAAA,EACxB,SAAS,CAAC;AAAA,EACV,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,yBAAyB;AAAA,EACzB,gCAAgC;AAAA,EAChC,eAAe;AAAA,EACf,eAAe;AAAA,EACf,QAAQ;AACV;AACA,SAAS,WAAW,MAAM;AACxB,MAAI,QAAQ,MAAM;AAChB,WAAO,OAAO,OAAO,CAAC,GAAG,cAAc;AAAA,EACzC;AACA,MAAI,KAAK,UAAU,QAAQ,KAAK,WAAW,OAAO;AAChD,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACnE;AACA,QAAM,UAAU,CAAC;AACjB,aAAW,OAAO,OAAO,KAAK,cAAc,GAAG;AAC7C,QAAI;AACJ,YAAQ,GAAG,KAAK,YAAY,KAAK,GAAG,MAAM,OAAO,YAAY,eAAe,GAAG;AAAA,EACjF;AACA,SAAO;AACT;AACA,MAAM,yBAAyB,WAAW;AAAA,EACxC,WAAW,MAAM,UAAU,UAAU,qBAAqB;AACxD,QAAI,KAAK,SAAS,mBAAmB,KAAK,eAAe,IAAI,KAAK,KAAK,YAAY,KAAK,WAAW;AACjG;AAAA,IACF;AACA,UAAM,MAAM,KAAK;AACjB,UAAM,OAAO,IAAI,SAAS,eAAe,IAAI,OAAO,IAAI;AACxD,QAAI,SAAS,aAAa;AACxB,UAAI,UAAU;AACZ,aAAK,MAAM,OAAO,eAAe,GAAG;AACpC;AAAA,MACF;AACA,UAAI,SAAS,MAAM;AACjB,YAAI,qBAAqB;AACvB,cAAI,oBAAoB,mBAAmB,MAAM;AAC/C,gCAAoB,iBAAiB,IAAI,IAAI;AAAA,UAC/C;AAAA,QACF,OAAO;AACL,eAAK,MAAM,OAAO,gBAAgB,GAAG;AAAA,QACvC;AAAA,MACF;AACA,eAAS,OAAO;AAAA,IAClB;AAAA,EACF;AAAA,EACA,qBAAqB,MAAM,kBAAkB;AAC3C,WAAO,KAAK,SAAS,6BAA6B,KAAK,UAAU;AAAA,EACnE;AAAA,EACA,gBAAgB;AACd,SAAK,mBAAmB;AACxB,SAAK,UAAU;AACf,UAAM,OAAO,KAAK,gBAAgB;AAClC,QAAI,CAAC,KAAK,MAAM,GAAG,GAAG;AACpB,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,0BAA0B;AAC/B,SAAK,WAAW,KAAK;AACrB,SAAK,SAAS,KAAK,MAAM;AACzB,QAAI,KAAK,QAAQ,QAAQ;AACvB,WAAK,SAAS,KAAK;AAAA,IACrB;AACA,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,YAAY,qBAAqB;AAC/C,QAAI,YAAY;AACd,aAAO,KAAK,cAAc,MAAM,KAAK,oBAAoB,mBAAmB,CAAC;AAAA,IAC/E;AACA,WAAO,KAAK,WAAW,MAAM,KAAK,oBAAoB,mBAAmB,CAAC;AAAA,EAC5E;AAAA,EACA,oBAAoB,qBAAqB;AACvC,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,OAAO,KAAK,iBAAiB,mBAAmB;AACtD,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,WAAK,cAAc,CAAC,IAAI;AACxB,aAAO,KAAK,IAAI,EAAE,GAAG;AACnB,aAAK,YAAY,KAAK,KAAK,iBAAiB,mBAAmB,CAAC;AAAA,MAClE;AACA,WAAK,iBAAiB,KAAK,WAAW;AACtC,aAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,IACnD;AACA,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B,qBAAqB,gBAAgB;AAC9D,WAAO,KAAK,cAAc,MAAM,KAAK,iBAAiB,qBAAqB,cAAc,CAAC;AAAA,EAC5F;AAAA,EACA,wBAAwB,qBAAqB,gBAAgB;AAC3D,WAAO,KAAK,WAAW,MAAM,KAAK,iBAAiB,qBAAqB,cAAc,CAAC;AAAA,EACzF;AAAA,EACA,2BAA2B,qBAAqB,aAAa;AAC3D,QAAI;AACJ,wBAAoB,yBAAyB,mBAAmB,eAAe,OAAO,SAAS,YAAY,QAAQ,OAAO,mBAAmB,KAAK,MAAM;AAAA,EAC1J;AAAA,EACA,iBAAiB,qBAAqB,gBAAgB;AACpD,UAAM,WAAW,KAAK,MAAM;AAC5B,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,UAAI,KAAK,UAAU,UAAU;AAC3B,YAAIC,QAAO,KAAK,WAAW;AAC3B,YAAI,gBAAgB;AAClB,UAAAA,QAAO,eAAe,KAAK,MAAMA,OAAM,QAAQ;AAAA,QACjD;AACA,eAAOA;AAAA,MACT;AAAA,IACF;AACA,QAAI;AACJ,QAAI,qBAAqB;AACvB,4BAAsB;AAAA,IACxB,OAAO;AACL,4BAAsB,IAAI,iBAAiB;AAC3C,4BAAsB;AAAA,IACxB;AACA,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAAS,MAAM,kBAAkB,IAAI,GAAG;AAC1C,WAAK,MAAM,mBAAmB,KAAK,MAAM;AAAA,IAC3C;AACA,QAAI,OAAO,KAAK,sBAAsB,mBAAmB;AACzD,QAAI,gBAAgB;AAClB,aAAO,eAAe,KAAK,MAAM,MAAM,QAAQ;AAAA,IACjD;AACA,QAAI,kBAAkB,KAAK,MAAM,IAAI,GAAG;AACtC,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,YAAM,WAAW,KAAK,MAAM;AAC5B,WAAK,WAAW;AAChB,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAK,aAAa,MAAM,IAAI;AAC5B,aAAK,OAAO;AACZ,cAAM,aAAa,SAAS;AAC5B,YAAI,oBAAoB,kBAAkB,QAAQ,oBAAoB,eAAe,SAAS,YAAY;AACxG,8BAAoB,iBAAiB;AAAA,QACvC;AACA,YAAI,oBAAoB,sBAAsB,QAAQ,oBAAoB,mBAAmB,SAAS,YAAY;AAChH,8BAAoB,qBAAqB;AAAA,QAC3C;AACA,YAAI,oBAAoB,iBAAiB,QAAQ,oBAAoB,cAAc,SAAS,YAAY;AACtG,eAAK,0BAA0B,mBAAmB;AAClD,8BAAoB,gBAAgB;AAAA,QACtC;AAAA,MACF,OAAO;AACL,aAAK,OAAO;AAAA,MACd;AACA,WAAK,KAAK;AACV,WAAK,QAAQ,KAAK,iBAAiB;AACnC,WAAK,UAAU,MAAM;AAAA,QACnB,IAAI,KAAK,WAAW,MAAM,sBAAsB;AAAA,MAClD,CAAC;AACD,aAAO;AAAA,IACT,WAAW,qBAAqB;AAC9B,WAAK,sBAAsB,qBAAqB,IAAI;AAAA,IACtD;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,qBAAqB;AACzC,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,mBAAmB,KAAK,MAAM;AACpC,UAAM,OAAO,KAAK,aAAa,mBAAmB;AAClD,QAAI,KAAK,qBAAqB,MAAM,gBAAgB,GAAG;AACrD,aAAO;AAAA,IACT;AACA,WAAO,KAAK,iBAAiB,MAAM,UAAU,mBAAmB;AAAA,EAClE;AAAA,EACA,iBAAiB,MAAM,UAAU,qBAAqB;AACpD,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,WAAK,OAAO;AACZ,WAAK,aAAa,KAAK,wBAAwB;AAC/C,WAAK,OAAO,EAAE;AACd,WAAK,YAAY,KAAK,iBAAiB;AACvC,aAAO,KAAK,WAAW,MAAM,uBAAuB;AAAA,IACtD;AACA,WAAO;AAAA,EACT;AAAA,EACA,yBAAyB,qBAAqB;AAC5C,WAAO,KAAK,MAAM,GAAG,IAAI,KAAK,iBAAiB,IAAI,KAAK,gBAAgB,mBAAmB;AAAA,EAC7F;AAAA,EACA,aAAa,qBAAqB;AAChC,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,mBAAmB,KAAK,MAAM;AACpC,UAAM,OAAO,KAAK,yBAAyB,mBAAmB;AAC9D,QAAI,KAAK,qBAAqB,MAAM,gBAAgB,GAAG;AACrD,aAAO;AAAA,IACT;AACA,WAAO,KAAK,YAAY,MAAM,UAAU,EAAE;AAAA,EAC5C;AAAA,EACA,YAAY,MAAM,cAAc,SAAS;AACvC,QAAI,KAAK,cAAc,IAAI,GAAG;AAC5B,YAAM,QAAQ,KAAK,iBAAiB,IAAI;AACxC,UAAI,WAAW,wBAAwB,EAAE,KAAK,CAAC,KAAK,UAAU,SAAS,CAAC,KAAK,MAAM,EAAE,GAAG;AACtF,aAAK,MAAM,OAAO,qBAAqB,MAAM;AAAA,UAC3C,gBAAgB;AAAA,QAClB,CAAC;AAAA,MACH;AACA,WAAK,WAAW,eAAe,OAAO,KAAK,IAAI,KAAK;AAAA,IACtD;AACA,UAAM,KAAK,KAAK,MAAM;AACtB,QAAI,gBAAgB,EAAE,MAAM,KAAK,UAAU,SAAS,CAAC,KAAK,MAAM,EAAE,IAAI;AACpE,UAAI,OAAO,wBAAwB,EAAE;AACrC,UAAI,OAAO,SAAS;AAClB,YAAI,OAAO,IAAI;AACb,eAAK,aAAa,kBAAkB;AACpC,cAAI,KAAK,MAAM,4BAA4B;AACzC,mBAAO;AAAA,UACT;AACA,eAAK,6BAA6B,MAAM,YAAY;AAAA,QACtD;AACA,cAAM,OAAO,KAAK,YAAY,YAAY;AAC1C,aAAK,OAAO;AACZ,aAAK,WAAW,KAAK,MAAM;AAC3B,cAAM,UAAU,OAAO,MAAM,OAAO;AACpC,cAAM,WAAW,OAAO;AACxB,YAAI,UAAU;AACZ,iBAAO,wBAAwB,EAAE;AAAA,QACnC;AACA,aAAK,KAAK;AACV,YAAI,OAAO,MAAM,KAAK,UAAU,CAAC,oBAAoB;AAAA,UACnD,UAAU;AAAA,QACZ,CAAC,CAAC,GAAG;AACH,cAAI,KAAK,MAAM,SAAS,MAAM,KAAK,UAAU,UAAU;AACrD,kBAAM,KAAK,MAAM,OAAO,kCAAkC,KAAK,MAAM,QAAQ;AAAA,UAC/E;AAAA,QACF;AACA,aAAK,QAAQ,KAAK,qBAAqB,IAAI,IAAI;AAC/C,cAAM,eAAe,KAAK,WAAW,MAAM,WAAW,WAAW,sBAAsB,kBAAkB;AACzG,cAAM,SAAS,KAAK,MAAM;AAC1B,YAAI,aAAa,WAAW,MAAM,WAAW,OAAO,WAAW,WAAW,IAAI;AAC5E,gBAAM,KAAK,MAAM,OAAO,2BAA2B,KAAK,MAAM,QAAQ;AAAA,QACxE;AACA,eAAO,KAAK,YAAY,cAAc,cAAc,OAAO;AAAA,MAC7D;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB,IAAI,MAAM;AAC7B,UAAM,WAAW,KAAK,MAAM;AAC5B,YAAQ,IAAI;AAAA,MACV,KAAK;AACH,gBAAQ,KAAK,gBAAgB,oBAAoB,UAAU,GAAG;AAAA,UAC5D,KAAK;AACH,mBAAO,KAAK,wBAAwB,MAAM;AACxC,qBAAO,KAAK,kBAAkB;AAAA,YAChC,CAAC;AAAA,UACH,KAAK;AACH,mBAAO,KAAK,wBAAwB,MAAM;AACxC,kBAAI,KAAK,UAAU,YAAY,KAAK,aAAa,GAAG,GAAG;AACrD,sBAAM,KAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,QAAQ;AAAA,cAChE;AACA,qBAAO,KAAK,8BAA8B,KAAK,yBAAyB,IAAI,IAAI,GAAG,QAAQ;AAAA,YAC7F,CAAC;AAAA,UACH,KAAK;AACH,mBAAO,KAAK,+BAA+B,MAAM;AAC/C,qBAAO,KAAK,wBAAwB,IAAI;AAAA,YAC1C,CAAC;AAAA,QACL;AAAA,MACF;AACE,eAAO,KAAK,yBAAyB,IAAI,IAAI;AAAA,IACjD;AAAA,EACF;AAAA,EACA,yBAAyB,IAAI,MAAM;AACjC,UAAM,WAAW,KAAK,MAAM;AAC5B,WAAO,KAAK,YAAY,KAAK,yBAAyB,GAAG,UAAU,wBAAwB,EAAE,IAAI,OAAO,IAAI,IAAI;AAAA,EAClH;AAAA,EACA,oBAAoB;AAClB,QAAI;AACJ,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,OAAO,KAAK,iBAAiB;AACnC,UAAM,sBAAsB,oCAAoC,IAAI,KAAK,IAAI;AAC7E,QAAI,uBAAuB,GAAG,cAAc,KAAK,UAAU,QAAQ,YAAY,gBAAgB;AAC7F,WAAK,MAAM,OAAO,yBAAyB,UAAU;AAAA,QACnD,MAAM,KAAK;AAAA,MACb,CAAC;AAAA,IACH;AACA,QAAI,CAAC,KAAK,sCAAsC,GAAG;AACjD,WAAK,MAAM,OAAO,iBAAiB,QAAQ;AAAA,IAC7C;AACA,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B,MAAM;AAC/B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,MAAM,OAAO,oCAAoC,KAAK,QAAQ;AAAA,IACrE;AAAA,EACF;AAAA,EACA,gBAAgB,qBAAqB,UAAU;AAC7C,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,UAAU,KAAK,aAAa,EAAE;AACpC,QAAI,WAAW,KAAK,eAAe,GAAG;AACpC,WAAK,KAAK;AACV,YAAMC,QAAO,KAAK,WAAW,QAAQ;AACrC,UAAI,CAAC;AAAU,aAAK,2BAA2BA,KAAI;AACnD,aAAOA;AAAA,IACT;AACA,UAAM,SAAS,KAAK,MAAM,EAAE;AAC5B,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,cAAc,KAAK,MAAM,IAAI,GAAG;AAClC,WAAK,WAAW,KAAK,MAAM;AAC3B,WAAK,SAAS;AACd,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAK,aAAa,kBAAkB;AAAA,MACtC;AACA,YAAM,WAAW,KAAK,MAAM,EAAE;AAC9B,WAAK,KAAK;AACV,WAAK,WAAW,KAAK,gBAAgB,MAAM,IAAI;AAC/C,WAAK,sBAAsB,qBAAqB,IAAI;AACpD,UAAI,KAAK,MAAM,UAAU,UAAU;AACjC,cAAM,MAAM,KAAK;AACjB,YAAI,IAAI,SAAS,cAAc;AAC7B,eAAK,MAAM,OAAO,cAAc,IAAI;AAAA,QACtC,WAAW,KAAK,yBAAyB,GAAG,GAAG;AAC7C,eAAK,MAAM,OAAO,oBAAoB,IAAI;AAAA,QAC5C;AAAA,MACF;AACA,UAAI,CAAC,QAAQ;AACX,YAAI,CAAC,UAAU;AACb,eAAK,2BAA2B,IAAI;AAAA,QACtC;AACA,eAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,MAChD;AAAA,IACF;AACA,UAAM,OAAO,KAAK,YAAY,MAAM,QAAQ,mBAAmB;AAC/D,QAAI,SAAS;AACX,YAAM;AAAA,QACJ;AAAA,MACF,IAAI,KAAK;AACT,YAAMC,cAAa,KAAK,UAAU,aAAa,IAAI,wBAAwB,IAAI,IAAI,wBAAwB,IAAI,KAAK,CAAC,KAAK,MAAM,EAAE;AAClI,UAAIA,eAAc,CAAC,KAAK,iBAAiB,GAAG;AAC1C,aAAK,eAAe,OAAO,wBAAwB,QAAQ;AAC3D,eAAO,KAAK,WAAW,QAAQ;AAAA,MACjC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM,QAAQ,qBAAqB;AAC7C,QAAI,QAAQ;AACV,YAAM,uBAAuB;AAC7B,WAAK,UAAU,qBAAqB,UAAU;AAAA,QAC5C,IAAI,KAAK,WAAW,sBAAsB,kBAAkB;AAAA,MAC9D,CAAC;AACD,aAAO;AAAA,IACT;AACA,UAAM,WAAW,KAAK,MAAM;AAC5B,QAAI,OAAO,KAAK,oBAAoB,mBAAmB;AACvD,QAAI,KAAK,sBAAsB,qBAAqB,KAAK;AAAG,aAAO;AACnE,WAAO,eAAe,KAAK,MAAM,IAAI,KAAK,CAAC,KAAK,mBAAmB,GAAG;AACpE,YAAMb,QAAO,KAAK,YAAY,QAAQ;AACtC,MAAAA,MAAK,WAAW,KAAK,MAAM;AAC3B,MAAAA,MAAK,SAAS;AACd,MAAAA,MAAK,WAAW;AAChB,WAAK,KAAK;AACV,WAAK,UAAU,MAAM;AAAA,QACnB,IAAI,OAAO,KAAK,WAAWA,OAAM,kBAAkB;AAAA,MACrD,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EACA,oBAAoB,qBAAqB;AACvC,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,mBAAmB,KAAK,MAAM;AACpC,UAAM,OAAO,KAAK,cAAc,mBAAmB;AACnD,QAAI,KAAK,qBAAqB,MAAM,gBAAgB,GAAG;AACrD,aAAO;AAAA,IACT;AACA,WAAO,KAAK,gBAAgB,MAAM,QAAQ;AAAA,EAC5C;AAAA,EACA,gBAAgB,MAAM,UAAU,SAAS;AACvC,UAAM,QAAQ;AAAA,MACZ,qBAAqB;AAAA,MACrB,iBAAiB,KAAK,qBAAqB,IAAI;AAAA,MAC/C,MAAM;AAAA,IACR;AACA,OAAG;AACD,aAAO,KAAK,eAAe,MAAM,UAAU,SAAS,KAAK;AACzD,YAAM,kBAAkB;AAAA,IAC1B,SAAS,CAAC,MAAM;AAChB,WAAO;AAAA,EACT;AAAA,EACA,eAAe,MAAM,UAAU,SAAS,OAAO;AAC7C,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,CAAC,WAAW,SAAS,IAAI;AAC3B,aAAO,KAAK,UAAU,MAAM,UAAU,SAAS,KAAK;AAAA,IACtD,WAAW,gBAAgB,IAAI,GAAG;AAChC,aAAO,KAAK,8BAA8B,MAAM,UAAU,KAAK;AAAA,IACjE;AACA,QAAI,WAAW;AACf,QAAI,SAAS,IAAI;AACf,UAAI,SAAS;AACX,aAAK,MAAM,OAAO,uBAAuB,KAAK,MAAM,QAAQ;AAC5D,YAAI,KAAK,kBAAkB,MAAM,IAAI;AACnC,gBAAM,OAAO;AACb,iBAAO;AAAA,QACT;AAAA,MACF;AACA,YAAM,sBAAsB,WAAW;AACvC,WAAK,KAAK;AAAA,IACZ;AACA,QAAI,CAAC,WAAW,KAAK,MAAM,EAAE,GAAG;AAC9B,aAAO,KAAK,gCAAgC,MAAM,UAAU,OAAO,QAAQ;AAAA,IAC7E,OAAO;AACL,YAAM,WAAW,KAAK,IAAI,CAAC;AAC3B,UAAI,YAAY,YAAY,KAAK,IAAI,EAAE,GAAG;AACxC,eAAO,KAAK,YAAY,MAAM,UAAU,OAAO,UAAU,QAAQ;AAAA,MACnE,OAAO;AACL,cAAM,OAAO;AACb,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EACA,YAAY,MAAM,UAAU,OAAO,UAAU,UAAU;AACrD,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,SAAS;AACd,SAAK,WAAW;AAChB,QAAI,UAAU;AACZ,WAAK,WAAW,KAAK,gBAAgB;AACrC,WAAK,OAAO,CAAC;AAAA,IACf,WAAW,KAAK,MAAM,GAAG,GAAG;AAC1B,UAAI,KAAK,SAAS,SAAS;AACzB,aAAK,MAAM,OAAO,mBAAmB,QAAQ;AAAA,MAC/C;AACA,WAAK,WAAW,eAAe,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQ;AACpE,WAAK,WAAW,KAAK,iBAAiB;AAAA,IACxC,OAAO;AACL,WAAK,WAAW,KAAK,gBAAgB,IAAI;AAAA,IAC3C;AACA,QAAI,MAAM,qBAAqB;AAC7B,WAAK,WAAW;AAChB,aAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,IACzD,OAAO;AACL,aAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,IACjD;AAAA,EACF;AAAA,EACA,UAAU,MAAM,UAAU,SAAS,OAAO;AACxC,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,SAAS;AACd,SAAK,KAAK;AACV,SAAK,SAAS,KAAK,gBAAgB;AACnC,UAAM,OAAO;AACb,WAAO,KAAK,gBAAgB,KAAK,WAAW,MAAM,gBAAgB,GAAG,UAAU,OAAO;AAAA,EACxF;AAAA,EACA,gCAAgC,MAAM,UAAU,OAAO,UAAU;AAC/D,UAAM,4BAA4B,KAAK,MAAM;AAC7C,QAAI,sBAAsB;AAC1B,SAAK,MAAM,yBAAyB;AACpC,SAAK,KAAK;AACV,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,SAAS;AACd,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI;AACJ,QAAI,iBAAiB;AACnB,WAAK,gBAAgB,MAAM,mBAAmB,CAAC;AAC/C,4BAAsB,IAAI,iBAAiB;AAAA,IAC7C;AACA,QAAI,qBAAqB;AACvB,WAAK,WAAW;AAAA,IAClB;AACA,QAAI,UAAU;AACZ,WAAK,YAAY,KAAK,6BAA6B,EAAE;AAAA,IACvD,OAAO;AACL,WAAK,YAAY,KAAK,6BAA6B,IAAI,KAAK,SAAS,UAAU,KAAK,SAAS,SAAS,MAAM,mBAAmB;AAAA,IACjI;AACA,QAAI,eAAe,KAAK,qBAAqB,MAAM,mBAAmB;AACtE,QAAI,mBAAmB,KAAK,sBAAsB,KAAK,CAAC,UAAU;AAChE,YAAM,OAAO;AACb,WAAK,0BAA0B,mBAAmB;AAClD,WAAK,gBAAgB,kBAAkB;AACvC,WAAK,gBAAgB,KAAK;AAC1B,qBAAe,KAAK,kCAAkC,KAAK,YAAY,QAAQ,GAAG,YAAY;AAAA,IAChG,OAAO;AACL,UAAI,iBAAiB;AACnB,aAAK,sBAAsB,qBAAqB,IAAI;AACpD,aAAK,gBAAgB,KAAK;AAAA,MAC5B;AACA,WAAK,sBAAsB,YAAY;AAAA,IACzC;AACA,SAAK,MAAM,yBAAyB;AACpC,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,MAAM,qBAAqB;AAC/C,SAAK,qBAAqB,KAAK,WAAW,mBAAmB;AAAA,EAC/D;AAAA,EACA,8BAA8B,MAAM,UAAU,OAAO;AACnD,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,MAAM;AACX,SAAK,QAAQ,KAAK,cAAc,IAAI;AACpC,QAAI,MAAM,qBAAqB;AAC7B,WAAK,MAAM,OAAO,4BAA4B,QAAQ;AAAA,IACxD;AACA,WAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,EACzD;AAAA,EACA,qBAAqB,MAAM;AACzB,WAAO,KAAK,SAAS,gBAAgB,KAAK,SAAS,WAAW,KAAK,MAAM,cAAc,UAAU,KAAK,OAAO,CAAC,KAAK,mBAAmB,KAAK,KAAK,MAAM,KAAK,UAAU,KAAK,KAAK,UAAU,KAAK,MAAM;AAAA,EACtM;AAAA,EACA,+BAA+B;AAC7B,QAAI,CAAC,KAAK,UAAU,kBAAkB,GAAG;AACvC,WAAK,aAAa,kBAAkB;AAAA,IACtC;AAAA,EACF;AAAA,EACA,qBAAqB,MAAM,UAAU;AACnC,QAAI,KAAK,OAAO,SAAS,UAAU;AACjC,UAAI,KAAK,UAAU,WAAW,GAAG;AAC/B;AACE,cAAI,CAAC,KAAK,UAAU,kBAAkB,GAAG;AACvC,iBAAK,6BAA6B;AAAA,UACpC;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,UAAU,WAAW,KAAK,KAAK,UAAU,SAAS,GAAG;AAC5D,aAAK,MAAM,OAAO,iBAAiB,MAAM;AAAA,UACvC,kBAAkB,KAAK,UAAU,kBAAkB,KAAK,KAAK,UAAU,kBAAkB,KAAK,KAAK,UAAU,kBAAkB,IAAI,IAAI;AAAA,QACzI,CAAC;AAAA,MACH,OAAO;AACL,mBAAW,OAAO,KAAK,WAAW;AAChC,cAAI,IAAI,SAAS,iBAAiB;AAChC,iBAAK,MAAM,OAAO,0BAA0B,GAAG;AAAA,UACjD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK,WAAW,MAAM,WAAW,2BAA2B,gBAAgB;AAAA,EACrF;AAAA,EACA,6BAA6B,OAAO,eAAe,kBAAkB,cAAc,qBAAqB;AACtG,UAAM,OAAO,CAAC;AACd,QAAI,QAAQ;AACZ,UAAM,gCAAgC,KAAK,MAAM;AACjD,SAAK,MAAM,6BAA6B;AACxC,WAAO,CAAC,KAAK,IAAI,KAAK,GAAG;AACvB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,aAAK,OAAO,EAAE;AACd,YAAI,KAAK,MAAM,KAAK,GAAG;AACrB,cAAI,iBAAiB,CAAC,KAAK,UAAU,kBAAkB,KAAK,CAAC,KAAK,UAAU,kBAAkB,KAAK,CAAC,KAAK,UAAU,kBAAkB,GAAG;AACtI,iBAAK,MAAM,OAAO,iCAAiC,KAAK,MAAM,eAAe;AAAA,UAC/E;AACA,cAAI,cAAc;AAChB,iBAAK,4BAA4B,YAAY;AAAA,UAC/C;AACA,eAAK,KAAK;AACV;AAAA,QACF;AAAA,MACF;AACA,WAAK,KAAK,KAAK,kBAAkB,OAAO,qBAAqB,gBAAgB,CAAC;AAAA,IAChF;AACA,SAAK,MAAM,6BAA6B;AACxC,WAAO;AAAA,EACT;AAAA,EACA,wBAAwB;AACtB,WAAO,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,mBAAmB;AAAA,EACpD;AAAA,EACA,kCAAkC,MAAM,MAAM;AAC5C,QAAI;AACJ,SAAK,kCAAkC,IAAI;AAC3C,SAAK,OAAO,EAAE;AACd,SAAK,qBAAqB,MAAM,KAAK,WAAW,OAAO,cAAc,KAAK,UAAU,OAAO,SAAS,YAAY,gBAAgB;AAChI,QAAI,KAAK,eAAe;AACtB,uBAAiB,MAAM,KAAK,aAAa;AAAA,IAC3C;AACA,QAAI,KAAK,OAAO,kBAAkB;AAChC,uBAAiB,MAAM,KAAK,OAAO,gBAAgB;AAAA,IACrD;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB;AAChB,UAAM,WAAW,KAAK,MAAM;AAC5B,WAAO,KAAK,gBAAgB,KAAK,cAAc,GAAG,UAAU,IAAI;AAAA,EAClE;AAAA,EACA,cAAc,qBAAqB;AACjC,QAAI;AACJ,QAAI,aAAa;AACjB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,eAAO,KAAK,WAAW;AAAA,MACzB,KAAK;AACH,eAAO,KAAK,UAAU;AACtB,aAAK,KAAK;AACV,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,iBAAO,KAAK,wBAAwB,IAAI;AAAA,QAC1C;AACA,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,cAAI,KAAK,QAAQ,yBAAyB;AACxC,mBAAO,KAAK,gBAAgB,IAAI;AAAA,UAClC,OAAO;AACL,mBAAO,KAAK,WAAW,MAAM,QAAQ;AAAA,UACvC;AAAA,QACF,OAAO;AACL,eAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,eAAe;AAC/D,iBAAO,KAAK,WAAW,MAAM,QAAQ;AAAA,QACvC;AAAA,MACF,KAAK;AACH,eAAO,KAAK,UAAU;AACtB,aAAK,KAAK;AACV,eAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,MAC/C,KAAK,IACH;AACE,eAAO,KAAK,QAAQ,KAAK,UAAU,GAAG,KAAK;AAAA,MAC7C;AAAA,MACF,KAAK;AAAA,MACL,KAAK,IACH;AACE,aAAK,WAAW;AAChB,eAAO,KAAK,mBAAmB,KAAK,MAAM,KAAK;AAAA,MACjD;AAAA,MACF,KAAK;AACH,eAAO,KAAK,oBAAoB,KAAK,MAAM,KAAK;AAAA,MAClD,KAAK;AACH,eAAO,KAAK,mBAAmB,KAAK,MAAM,KAAK;AAAA,MACjD,KAAK;AACH,eAAO,KAAK,oBAAoB,KAAK,MAAM,KAAK;AAAA,MAClD,KAAK;AACH,eAAO,KAAK,mBAAmB,KAAK,MAAM,KAAK;AAAA,MACjD,KAAK;AACH,eAAO,KAAK,iBAAiB;AAAA,MAC/B,KAAK;AACH,eAAO,KAAK,oBAAoB,IAAI;AAAA,MACtC,KAAK;AACH,eAAO,KAAK,oBAAoB,KAAK;AAAA,MACvC,KAAK,IACH;AACE,cAAM,aAAa,KAAK,MAAM,qBAAqB,KAAK,MAAM;AAC9D,eAAO,KAAK,mCAAmC,UAAU;AAAA,MAC3D;AAAA,MACF,KAAK;AAAA,MACL,KAAK,GACH;AACE,eAAO,KAAK,eAAe,KAAK,MAAM,SAAS,IAAI,IAAI,GAAG,OAAO,IAAI;AAAA,MACvE;AAAA,MACF,KAAK,GACH;AACE,eAAO,KAAK,eAAe,GAAG,MAAM,OAAO,mBAAmB;AAAA,MAChE;AAAA,MACF,KAAK;AAAA,MACL,KAAK,GACH;AACE,eAAO,KAAK,gBAAgB,KAAK,MAAM,SAAS,IAAI,IAAI,GAAG,OAAO,IAAI;AAAA,MACxE;AAAA,MACF,KAAK,GACH;AACE,eAAO,KAAK,gBAAgB,GAAG,OAAO,OAAO,mBAAmB;AAAA,MAClE;AAAA,MACF,KAAK;AACH,eAAO,KAAK,4BAA4B;AAAA,MAC1C,KAAK;AACH,qBAAa,KAAK,gBAAgB;AAAA,MACpC,KAAK;AACH,eAAO,KAAK,WAAW,KAAK,oBAAoB,YAAY,KAAK,UAAU,CAAC,GAAG,KAAK;AAAA,MACtF,KAAK;AACH,eAAO,KAAK,oBAAoB;AAAA,MAClC,KAAK;AAAA,MACL,KAAK;AACH,eAAO,KAAK,cAAc,KAAK;AAAA,MACjC,KAAK,IACH;AACE,eAAO,KAAK,UAAU;AACtB,aAAK,KAAK;AACV,aAAK,SAAS;AACd,cAAM,SAAS,KAAK,SAAS,KAAK,gBAAgB;AAClD,YAAI,OAAO,SAAS,oBAAoB;AACtC,iBAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,QAC/C,OAAO;AACL,gBAAM,KAAK,MAAM,OAAO,iBAAiB,MAAM;AAAA,QACjD;AAAA,MACF;AAAA,MACF,KAAK,KACH;AACE,aAAK,MAAM,OAAO,qBAAqB,KAAK,MAAM,UAAU;AAAA,UAC1D,gBAAgB,KAAK,MAAM;AAAA,QAC7B,CAAC;AACD,eAAO,KAAK,iBAAiB;AAAA,MAC/B;AAAA,MACF,KAAK,IACH;AACE,eAAO,KAAK,kCAAkC,IAAI,GAAG;AAAA,MACvD;AAAA,MACF,KAAK,IACH;AACE,eAAO,KAAK,kCAAkC,IAAI,GAAG;AAAA,MACvD;AAAA,MACF,KAAK;AAAA,MACL,KAAK,IACH;AACE,eAAO,KAAK,oBAAoB,MAAM;AAAA,MACxC;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,IACH;AACE,cAAM,eAAe,KAAK,gBAAgB,oBAAoB,UAAU;AACxE,YAAI,cAAc;AAChB,iBAAO,KAAK,oBAAoB,YAAY;AAAA,QAC9C;AACA,aAAK,WAAW;AAChB;AAAA,MACF;AAAA,MACF,KAAK,IACH;AACE,cAAM,cAAc,KAAK,MAAM,YAAY,KAAK,eAAe,CAAC;AAChE,YAAI,kBAAkB,WAAW,KAAK,gBAAgB,IAAI;AACxD,eAAK,gBAAgB,CAAC,OAAO,QAAQ,YAAY,CAAC;AAAA,QACpD,OAAO;AACL,eAAK,WAAW;AAAA,QAClB;AACA;AAAA,MACF;AAAA,MACF;AACE,YAAI,kBAAkB,IAAI,GAAG;AAC3B,cAAI,KAAK,aAAa,GAAG,KAAK,KAAK,wBAAwB,MAAM,KAAK;AACpE,mBAAO,KAAK,sBAAsB;AAAA,UACpC;AACA,gBAAM,aAAa,KAAK,MAAM,qBAAqB,KAAK,MAAM;AAC9D,gBAAM,cAAc,KAAK,MAAM;AAC/B,gBAAM,KAAK,KAAK,gBAAgB;AAChC,cAAI,CAAC,eAAe,GAAG,SAAS,WAAW,CAAC,KAAK,mBAAmB,GAAG;AACrE,kBAAM;AAAA,cACJ,MAAAc;AAAA,YACF,IAAI,KAAK;AACT,gBAAIA,UAAS,IAAI;AACf,mBAAK,kCAAkC,EAAE;AACzC,mBAAK,KAAK;AACV,qBAAO,KAAK,6BAA6B,KAAK,gBAAgB,EAAE,CAAC;AAAA,YACnE,WAAW,kBAAkBA,KAAI,GAAG;AAClC,kBAAI,KAAK,kBAAkB,MAAM,IAAI;AACnC,uBAAO,KAAK,6BAA6B,KAAK,gBAAgB,EAAE,CAAC;AAAA,cACnE,OAAO;AACL,uBAAO;AAAA,cACT;AAAA,YACF,WAAWA,UAAS,IAAI;AACtB,mBAAK,kCAAkC,EAAE;AACzC,qBAAO,KAAK,QAAQ,KAAK,gBAAgB,EAAE,GAAG,IAAI;AAAA,YACpD;AAAA,UACF;AACA,cAAI,cAAc,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,mBAAmB,GAAG;AAC9D,iBAAK,KAAK;AACV,mBAAO,KAAK,qBAAqB,KAAK,gBAAgB,EAAE,GAAG,CAAC,EAAE,GAAG,KAAK;AAAA,UACxE;AACA,iBAAO;AAAA,QACT,OAAO;AACL,eAAK,WAAW;AAAA,QAClB;AAAA,IACJ;AAAA,EACF;AAAA,EACA,kCAAkC,gBAAgB,iBAAiB;AACjE,UAAM,eAAe,KAAK,gBAAgB,oBAAoB,UAAU;AACxE,QAAI,cAAc;AAChB,WAAK,MAAM,OAAO;AAClB,WAAK,MAAM,QAAQ;AACnB,WAAK,MAAM;AACX,WAAK,MAAM;AACX,WAAK,MAAM,SAAS,+BAA+B,KAAK,MAAM,QAAQ,EAAE;AACxE,aAAO,KAAK,oBAAoB,YAAY;AAAA,IAC9C,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,oBAAoB,cAAc;AAChC,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,WAAW,KAAK,MAAM;AAC5B,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,KAAK;AACV,WAAO,KAAK,qBAAqB,MAAM,UAAU,cAAc,SAAS;AAAA,EAC1E;AAAA,EACA,qBAAqB,MAAM,UAAU,cAAc,WAAW;AAC5D,QAAI,KAAK,gCAAgC,cAAc,UAAU,SAAS,GAAG;AAC3E,YAAM,WAAW,iBAAiB,UAAU,kCAAkC;AAC9E,UAAI,CAAC,KAAK,wCAAwC,GAAG;AACnD,aAAK,MAAM,iBAAiB,UAAU,OAAO,yBAAyB,OAAO,kBAAkB,QAAQ;AAAA,MACzG;AACA,WAAK,uBAAuB;AAC5B,aAAO,KAAK,WAAW,MAAM,QAAQ;AAAA,IACvC,OAAO;AACL,YAAM,KAAK,MAAM,OAAO,4BAA4B,UAAU;AAAA,QAC5D,OAAO,eAAe,SAAS;AAAA,MACjC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,gCAAgC,cAAc,UAAU,WAAW;AACjE,YAAQ,cAAc;AAAA,MACpB,KAAK,QACH;AACE,eAAO,KAAK,UAAU,CAAC,oBAAoB;AAAA,UACzC,YAAY,eAAe,SAAS;AAAA,QACtC,CAAC,CAAC;AAAA,MACJ;AAAA,MACF,KAAK;AACH,eAAO,cAAc;AAAA,MACvB;AACE,cAAM,KAAK,MAAM,OAAO,4BAA4B,QAAQ;AAAA,IAChE;AAAA,EACF;AAAA,EACA,6BAA6B,MAAM;AACjC,SAAK,UAAU,MAAM,cAAc,MAAM,KAAK,UAAU,QAAQ,CAAC;AACjE,UAAM,SAAS,CAAC,KAAK,gBAAgB,CAAC;AACtC,SAAK,UAAU,KAAK;AACpB,QAAI,KAAK,sBAAsB,GAAG;AAChC,WAAK,MAAM,OAAO,2BAA2B,KAAK,MAAM,YAAY,CAAC;AAAA,IACvE;AACA,SAAK,OAAO,EAAE;AACd,WAAO,KAAK,qBAAqB,MAAM,QAAQ,IAAI;AAAA,EACrD;AAAA,EACA,QAAQ,MAAM,SAAS;AACrB,SAAK,aAAa,eAAe;AACjC,QAAI,SAAS;AACX,WAAK,aAAa,oBAAoB;AAAA,IACxC;AACA,SAAK,QAAQ;AACb,SAAK,KAAK;AACV,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS,CAAC;AACrB,QAAI,SAAS;AACX,WAAK,UAAU,MAAM,CAAC;AACtB,WAAK,OAAO,KAAK,WAAW;AAC5B,WAAK,UAAU,KAAK;AAAA,IACtB,OAAO;AACL,WAAK,OAAO,KAAK,WAAW;AAAA,IAC9B;AACA,SAAK,MAAM,SAAS;AACpB,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,aAAa;AACX,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,QAAI,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,oBAAoB,CAAC,KAAK,QAAQ,yBAAyB;AAC3F,WAAK,MAAM,OAAO,iBAAiB,IAAI;AAAA,IACzC,WAAW,CAAC,KAAK,MAAM,cAAc,CAAC,KAAK,QAAQ,yBAAyB;AAC1E,WAAK,MAAM,OAAO,iBAAiB,IAAI;AAAA,IACzC;AACA,QAAI,CAAC,KAAK,MAAM,EAAE,KAAK,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AACxD,WAAK,MAAM,OAAO,kBAAkB,IAAI;AAAA,IAC1C;AACA,WAAO,KAAK,WAAW,MAAM,OAAO;AAAA,EACtC;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,KAAK,KAAK,YAAY,+BAA+B,KAAK,MAAM,UAAU,CAAC,CAAC;AAClF,UAAM,OAAO,KAAK,MAAM;AACxB,SAAK,KAAK;AACV,SAAK,KAAK,KAAK,iBAAiB,IAAI,IAAI;AACxC,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,8BAA8B;AAC5B,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,QAAI,KAAK,UAAU,YAAY,KAAK,MAAM,EAAE,GAAG;AAC7C,YAAM,OAAO,KAAK,iBAAiB,KAAK,gBAAgB,IAAI,GAAG,UAAU;AACzE,WAAK,KAAK;AACV,UAAI,KAAK,MAAM,GAAG,GAAG;AACnB,aAAK,aAAa,cAAc;AAAA,MAClC,WAAW,CAAC,KAAK,UAAU,cAAc,GAAG;AAC1C,aAAK,WAAW;AAAA,MAClB;AACA,aAAO,KAAK,kBAAkB,MAAM,MAAM,MAAM;AAAA,IAClD;AACA,WAAO,KAAK,cAAc,IAAI;AAAA,EAChC;AAAA,EACA,kBAAkB,MAAM,MAAM,cAAc;AAC1C,SAAK,OAAO;AACZ,UAAM,cAAc,KAAK,MAAM;AAC/B,SAAK,WAAW,KAAK,gBAAgB,IAAI;AACzC,QAAI,KAAK,SAAS,SAAS,gBAAgB,aAAa;AACtD,WAAK,MAAM,OAAO,yBAAyB,KAAK,UAAU;AAAA,QACxD,QAAQ,KAAK;AAAA,QACb,uBAAuB;AAAA,MACzB,CAAC;AAAA,IACH;AACA,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,wBAAwB,MAAM;AAC5B,UAAM,KAAK,KAAK,iBAAiB,KAAK,gBAAgB,IAAI,GAAG,QAAQ;AACrE,SAAK,KAAK;AACV,QAAI,KAAK,aAAa,GAAG,GAAG;AAC1B,UAAI,CAAC,KAAK,UAAU;AAClB,aAAK,MAAM,OAAO,yBAAyB,EAAE;AAAA,MAC/C;AACA,WAAK,oBAAoB;AAAA,IAC3B,WAAW,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,EAAE,GAAG;AAC1D,YAAM,WAAW,KAAK,aAAa,GAAG;AACtC,UAAI,CAAC;AAAU,aAAK,WAAW;AAC/B,WAAK,aAAa,WAAW,uBAAuB,0BAA0B;AAC9E,UAAI,CAAC,KAAK,QAAQ,yBAAyB;AACzC,cAAM,KAAK,MAAM,OAAO,6CAA6C,KAAK,MAAM,UAAU;AAAA,UACxF,OAAO,KAAK,MAAM;AAAA,QACpB,CAAC;AAAA,MACH;AACA,WAAK,KAAK;AACV,WAAK,QAAQ,WAAW,WAAW;AACnC,aAAO,KAAK,gBAAgB,IAAI;AAAA,IAClC;AACA,WAAO,KAAK,kBAAkB,MAAM,IAAI,MAAM;AAAA,EAChD;AAAA,EACA,mBAAmB,OAAO,MAAM,MAAM;AACpC,SAAK,SAAS,MAAM,YAAY,KAAK;AACrC,SAAK,SAAS,MAAM,OAAO,KAAK,MAAM,MAAM,KAAK,OAAO,KAAK,MAAM,GAAG,CAAC;AACvE,SAAK,QAAQ;AACb,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,aAAa,OAAO,MAAM;AACxB,UAAM,OAAO,KAAK,UAAU;AAC5B,WAAO,KAAK,mBAAmB,OAAO,MAAM,IAAI;AAAA,EAClD;AAAA,EACA,mBAAmB,OAAO;AACxB,WAAO,KAAK,aAAa,OAAO,eAAe;AAAA,EACjD;AAAA,EACA,oBAAoB,OAAO;AACzB,WAAO,KAAK,aAAa,OAAO,gBAAgB;AAAA,EAClD;AAAA,EACA,mBAAmB,OAAO;AACxB,WAAO,KAAK,aAAa,OAAO,eAAe;AAAA,EACjD;AAAA,EACA,oBAAoB,OAAO;AACzB,WAAO,KAAK,aAAa,OAAO,gBAAgB;AAAA,EAClD;AAAA,EACA,mBAAmB,OAAO;AACxB,UAAM,OAAO,KAAK,aAAa,MAAM,OAAO,eAAe;AAC3D,SAAK,UAAU,MAAM;AACrB,SAAK,QAAQ,MAAM;AACnB,WAAO;AAAA,EACT;AAAA,EACA,oBAAoB,OAAO;AACzB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,QAAQ;AACb,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,mBAAmB;AACjB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,mCAAmC,YAAY;AAC7C,UAAM,WAAW,KAAK,MAAM;AAC5B,QAAI;AACJ,SAAK,KAAK;AACV,SAAK,gBAAgB,MAAM,kBAAkB,CAAC;AAC9C,UAAM,4BAA4B,KAAK,MAAM;AAC7C,UAAM,gCAAgC,KAAK,MAAM;AACjD,SAAK,MAAM,yBAAyB;AACpC,SAAK,MAAM,6BAA6B;AACxC,UAAM,gBAAgB,KAAK,MAAM;AACjC,UAAM,WAAW,CAAC;AAClB,UAAM,sBAAsB,IAAI,iBAAiB;AACjD,QAAI,QAAQ;AACZ,QAAI;AACJ,QAAI;AACJ,WAAO,CAAC,KAAK,MAAM,EAAE,GAAG;AACtB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,aAAK,OAAO,IAAI,oBAAoB,0BAA0B,OAAO,OAAO,oBAAoB,qBAAqB;AACrH,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,kCAAwB,KAAK,MAAM;AACnC;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,cAAM,qBAAqB,KAAK,MAAM;AACtC,yBAAiB,KAAK,MAAM;AAC5B,iBAAS,KAAK,KAAK,eAAe,KAAK,iBAAiB,GAAG,kBAAkB,CAAC;AAC9E,YAAI,CAAC,KAAK,oBAAoB,EAAE,GAAG;AACjC;AAAA,QACF;AAAA,MACF,OAAO;AACL,iBAAS,KAAK,KAAK,wBAAwB,qBAAqB,KAAK,cAAc,CAAC;AAAA,MACtF;AAAA,IACF;AACA,UAAM,cAAc,KAAK,MAAM;AAC/B,SAAK,OAAO,EAAE;AACd,SAAK,MAAM,yBAAyB;AACpC,SAAK,MAAM,6BAA6B;AACxC,QAAI,YAAY,KAAK,YAAY,QAAQ;AACzC,QAAI,cAAc,KAAK,iBAAiB,QAAQ,MAAM,YAAY,KAAK,WAAW,SAAS,IAAI;AAC7F,WAAK,0BAA0B,mBAAmB;AAClD,WAAK,gBAAgB,kBAAkB;AACvC,WAAK,gBAAgB,KAAK;AAC1B,WAAK,qBAAqB,WAAW,UAAU,KAAK;AACpD,aAAO;AAAA,IACT;AACA,SAAK,gBAAgB,KAAK;AAC1B,QAAI,CAAC,SAAS,QAAQ;AACpB,WAAK,WAAW,KAAK,MAAM,eAAe;AAAA,IAC5C;AACA,QAAI;AAAuB,WAAK,WAAW,qBAAqB;AAChE,QAAI;AAAgB,WAAK,WAAW,cAAc;AAClD,SAAK,sBAAsB,qBAAqB,IAAI;AACpD,SAAK,qBAAqB,UAAU,IAAI;AACxC,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,KAAK,YAAY,aAAa;AACpC,UAAI,cAAc;AAClB,WAAK,WAAW,KAAK,oBAAoB;AACzC,WAAK,iBAAiB,KAAK,WAAW;AAAA,IACxC,OAAO;AACL,YAAM,SAAS,CAAC;AAAA,IAClB;AACA,WAAO,KAAK,gBAAgB,UAAU,GAAG;AAAA,EAC3C;AAAA,EACA,gBAAgB,UAAU,YAAY;AACpC,QAAI,CAAC,KAAK,QAAQ,gCAAgC;AAChD,WAAK,SAAS,YAAY,iBAAiB,IAAI;AAC/C,WAAK,SAAS,YAAY,cAAc,SAAS,KAAK;AACtD,WAAK,wBAAwB,YAAY,SAAS,OAAO,KAAK,MAAM,cAAc,KAAK;AACvF,aAAO;AAAA,IACT;AACA,UAAM,kBAAkB,KAAK,YAAY,QAAQ;AACjD,oBAAgB,aAAa;AAC7B,WAAO,KAAK,WAAW,iBAAiB,yBAAyB;AAAA,EACnE;AAAA,EACA,iBAAiB,QAAQ;AACvB,WAAO,CAAC,KAAK,mBAAmB;AAAA,EAClC;AAAA,EACA,WAAW,MAAM;AACf,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,eAAe,MAAM,UAAU;AAC7B,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB;AACpB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,OAAO,KAAK,iBAAiB,KAAK,gBAAgB,IAAI,GAAG,KAAK;AACpE,WAAK,KAAK;AACV,YAAM,WAAW,KAAK,kBAAkB,MAAM,MAAM,QAAQ;AAC5D,UAAI,CAAC,KAAK,MAAM,sBAAsB,CAAC,KAAK,MAAM,WAAW,CAAC,KAAK,QAAQ,+BAA+B;AACxG,aAAK,MAAM,OAAO,qBAAqB,QAAQ;AAAA,MACjD;AACA,aAAO;AAAA,IACT;AACA,WAAO,KAAK,SAAS,IAAI;AAAA,EAC3B;AAAA,EACA,SAAS,MAAM;AACb,SAAK,eAAe,IAAI;AACxB,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,OAAO,KAAK,cAAc,EAAE;AAClC,WAAK,iBAAiB,IAAI;AAC1B,WAAK,YAAY;AAAA,IACnB,OAAO;AACL,WAAK,YAAY,CAAC;AAAA,IACpB;AACA,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,eAAe,MAAM;AACnB,UAAM,WAAW,KAAK,MAAM,EAAE;AAC9B,UAAM,SAAS,KAAK,gBAAgB;AACpC,SAAK,SAAS;AACd,QAAI,aAAa,OAAO,SAAS,YAAY,OAAO,SAAS,qBAAqB;AAChF,WAAK,MAAM,OAAO,4BAA4B,MAAM;AAAA,IACtD;AAAA,EACF;AAAA,EACA,qBAAqB,UAAU;AAC7B,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AACT,UAAM,YAAY,QAAQ;AAC1B,UAAM,OAAO,KAAK,YAAY,+BAA+B,UAAU,CAAC,CAAC;AACzE,QAAI,UAAU,MAAM;AAClB,UAAI,CAAC,UAAU;AACb,aAAK,MAAM,OAAO,+BAA+B,+BAA+B,KAAK,MAAM,+BAA+B,CAAC,CAAC;AAAA,MAC9H;AAAA,IACF;AACA,UAAM,SAAS,KAAK,MAAM,EAAE;AAC5B,UAAM,YAAY,SAAS,KAAK;AAChC,UAAM,UAAU,MAAM;AACtB,SAAK,QAAQ;AAAA,MACX,KAAK,KAAK,MAAM,MAAM,WAAW,OAAO,EAAE,QAAQ,UAAU,IAAI;AAAA,MAChE,QAAQ,UAAU,OAAO,OAAO,MAAM,MAAM,GAAG,SAAS;AAAA,IAC1D;AACA,SAAK,OAAO;AACZ,SAAK,KAAK;AACV,UAAM,eAAe,KAAK,WAAW,MAAM,iBAAiB;AAC5D,SAAK,iBAAiB,cAAc,+BAA+B,KAAK,MAAM,eAAe,SAAS,CAAC;AACvG,WAAO;AAAA,EACT;AAAA,EACA,cAAc,UAAU;AACtB,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,cAAc,CAAC;AACpB,QAAI,SAAS,KAAK,qBAAqB,QAAQ;AAC/C,SAAK,SAAS,CAAC,MAAM;AACrB,WAAO,CAAC,OAAO,MAAM;AACnB,WAAK,YAAY,KAAK,KAAK,0BAA0B,CAAC;AACtD,WAAK,yBAAyB;AAC9B,WAAK,OAAO,KAAK,SAAS,KAAK,qBAAqB,QAAQ,CAAC;AAAA,IAC/D;AACA,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,4BAA4B;AAC1B,WAAO,KAAK,gBAAgB;AAAA,EAC9B;AAAA,EACA,gBAAgB,OAAO,WAAW,UAAU,qBAAqB;AAC/D,QAAI,UAAU;AACZ,WAAK,aAAa,gBAAgB;AAAA,IACpC;AACA,UAAM,gCAAgC,KAAK,MAAM;AACjD,SAAK,MAAM,6BAA6B;AACxC,UAAM,WAAW,uBAAO,OAAO,IAAI;AACnC,QAAI,QAAQ;AACZ,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,aAAa,CAAC;AACnB,SAAK,KAAK;AACV,WAAO,CAAC,KAAK,MAAM,KAAK,GAAG;AACzB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,aAAK,OAAO,EAAE;AACd,YAAI,KAAK,MAAM,KAAK,GAAG;AACrB,eAAK,4BAA4B,IAAI;AACrC;AAAA,QACF;AAAA,MACF;AACA,UAAI;AACJ,UAAI,WAAW;AACb,eAAO,KAAK,qBAAqB;AAAA,MACnC,OAAO;AACL,eAAO,KAAK,wBAAwB,mBAAmB;AACvD,aAAK,WAAW,MAAM,UAAU,UAAU,mBAAmB;AAAA,MAC/D;AACA,UAAI,YAAY,CAAC,KAAK,iBAAiB,IAAI,KAAK,KAAK,SAAS,iBAAiB;AAC7E,aAAK,MAAM,OAAO,uBAAuB,IAAI;AAAA,MAC/C;AACA,UAAI,KAAK,WAAW;AAClB,aAAK,SAAS,MAAM,aAAa,IAAI;AAAA,MACvC;AACA,WAAK,WAAW,KAAK,IAAI;AAAA,IAC3B;AACA,SAAK,KAAK;AACV,SAAK,MAAM,6BAA6B;AACxC,QAAI,OAAO;AACX,QAAI,WAAW;AACb,aAAO;AAAA,IACT,WAAW,UAAU;AACnB,aAAO;AAAA,IACT;AACA,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,4BAA4B,MAAM;AAChC,SAAK,SAAS,MAAM,iBAAiB,KAAK,MAAM,gBAAgB,KAAK;AACrE,SAAK,SAAS,MAAM,oBAAoB,KAAK,MAAM,iBAAiB,KAAK;AAAA,EAC3E;AAAA,EACA,yBAAyB,MAAM;AAC7B,WAAO,CAAC,KAAK,YAAY,KAAK,IAAI,SAAS,iBAAiB,KAAK,sBAAsB,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,EAAE;AAAA,EAC5H;AAAA,EACA,wBAAwB,qBAAqB;AAC3C,QAAI,aAAa,CAAC;AAClB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,KAAK,UAAU,YAAY,GAAG;AAChC,aAAK,MAAM,OAAO,8BAA8B,KAAK,MAAM,QAAQ;AAAA,MACrE;AACA,aAAO,KAAK,MAAM,EAAE,GAAG;AACrB,mBAAW,KAAK,KAAK,eAAe,CAAC;AAAA,MACvC;AAAA,IACF;AACA,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,UAAU;AACd,QAAI,aAAa;AACjB,QAAI;AACJ,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,WAAW;AAAQ,aAAK,WAAW;AACvC,aAAO,KAAK,YAAY;AAAA,IAC1B;AACA,QAAI,WAAW,QAAQ;AACrB,WAAK,aAAa;AAClB,mBAAa,CAAC;AAAA,IAChB;AACA,SAAK,SAAS;AACd,QAAI,qBAAqB;AACvB,iBAAW,KAAK,MAAM;AAAA,IACxB;AACA,QAAI,cAAc,KAAK,IAAI,EAAE;AAC7B,SAAK,gCAAgC,IAAI;AACzC,UAAM,cAAc,KAAK,MAAM;AAC/B,UAAM,MAAM,KAAK,kBAAkB,MAAM,mBAAmB;AAC5D,QAAI,CAAC,eAAe,CAAC,eAAe,KAAK,yBAAyB,IAAI,GAAG;AACvE,YAAM,UAAU,IAAI;AACpB,UAAI,YAAY,WAAW,CAAC,KAAK,sBAAsB,GAAG;AACxD,kBAAU;AACV,aAAK,kCAAkC,GAAG;AAC1C,sBAAc,KAAK,IAAI,EAAE;AACzB,aAAK,kBAAkB,IAAI;AAAA,MAC7B;AACA,UAAI,YAAY,SAAS,YAAY,OAAO;AAC1C,qBAAa;AACb,aAAK,kCAAkC,GAAG;AAC1C,aAAK,OAAO;AACZ,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,wBAAc;AACd,eAAK,MAAM,OAAO,qBAAqB,KAAK,MAAM,YAAY,GAAG;AAAA,YAC/D,MAAM;AAAA,UACR,CAAC;AACD,eAAK,KAAK;AAAA,QACZ;AACA,aAAK,kBAAkB,IAAI;AAAA,MAC7B;AAAA,IACF;AACA,WAAO,KAAK,kBAAkB,MAAM,UAAU,aAAa,SAAS,OAAO,YAAY,mBAAmB;AAAA,EAC5G;AAAA,EACA,kCAAkC,QAAQ;AACxC,WAAO,OAAO,SAAS,QAAQ,IAAI;AAAA,EACrC;AAAA,EACA,6BAA6B,QAAQ;AACnC,WAAO,OAAO;AAAA,EAChB;AAAA,EACA,wBAAwB,QAAQ;AAC9B,QAAI;AACJ,UAAM,aAAa,KAAK,kCAAkC,MAAM;AAChE,UAAM,SAAS,KAAK,6BAA6B,MAAM;AACvD,QAAI,OAAO,WAAW,YAAY;AAChC,WAAK,MAAM,OAAO,SAAS,QAAQ,OAAO,iBAAiB,OAAO,gBAAgB,MAAM;AAAA,IAC1F;AACA,QAAI,OAAO,SAAS,WAAW,UAAU,OAAO,OAAO,SAAS,CAAC,MAAM,OAAO,SAAS,QAAQ,UAAU,eAAe;AACtH,WAAK,MAAM,OAAO,wBAAwB,MAAM;AAAA,IAClD;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM,aAAa,SAAS,WAAW,YAAY;AACnE,QAAI,YAAY;AACd,YAAM,eAAe,KAAK,YAAY,MAAM,aAAa,OAAO,OAAO,OAAO,cAAc;AAC5F,WAAK,wBAAwB,YAAY;AACzC,aAAO;AAAA,IACT;AACA,QAAI,WAAW,eAAe,KAAK,MAAM,EAAE,GAAG;AAC5C,UAAI;AAAW,aAAK,WAAW;AAC/B,WAAK,OAAO;AACZ,WAAK,SAAS;AACd,aAAO,KAAK,YAAY,MAAM,aAAa,SAAS,OAAO,OAAO,cAAc;AAAA,IAClF;AAAA,EACF;AAAA,EACA,oBAAoB,MAAM,UAAU,WAAW,qBAAqB;AAClE,SAAK,YAAY;AACjB,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,QAAQ,YAAY,KAAK,kBAAkB,KAAK,MAAM,QAAQ,IAAI,KAAK,wBAAwB,mBAAmB;AACvH,aAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,IAC/C;AACA,QAAI,CAAC,KAAK,YAAY,KAAK,IAAI,SAAS,cAAc;AACpD,WAAK,kBAAkB,KAAK,IAAI,MAAM,KAAK,IAAI,IAAI,OAAO,MAAM,KAAK;AACrE,UAAI,WAAW;AACb,aAAK,QAAQ,KAAK,kBAAkB,UAAU,gBAAgB,KAAK,GAAG,CAAC;AAAA,MACzE,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,cAAM,qBAAqB,KAAK,MAAM;AACtC,YAAI,uBAAuB,MAAM;AAC/B,cAAI,oBAAoB,uBAAuB,MAAM;AACnD,gCAAoB,qBAAqB;AAAA,UAC3C;AAAA,QACF,OAAO;AACL,eAAK,MAAM,OAAO,6BAA6B,kBAAkB;AAAA,QACnE;AACA,aAAK,QAAQ,KAAK,kBAAkB,UAAU,gBAAgB,KAAK,GAAG,CAAC;AAAA,MACzE,OAAO;AACL,aAAK,QAAQ,gBAAgB,KAAK,GAAG;AAAA,MACvC;AACA,WAAK,YAAY;AACjB,aAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,IAC/C;AAAA,EACF;AAAA,EACA,kBAAkB,MAAM,UAAU,aAAa,SAAS,WAAW,YAAY,qBAAqB;AAClG,UAAM,OAAO,KAAK,kBAAkB,MAAM,aAAa,SAAS,WAAW,UAAU,KAAK,KAAK,oBAAoB,MAAM,UAAU,WAAW,mBAAmB;AACjK,QAAI,CAAC;AAAM,WAAK,WAAW;AAC3B,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,MAAM,qBAAqB;AAC3C,QAAI,KAAK,IAAI,CAAC,GAAG;AACf,WAAK,WAAW;AAChB,WAAK,MAAM,KAAK,wBAAwB;AACxC,WAAK,OAAO,CAAC;AAAA,IACf,OAAO;AACL,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,MACF,IAAI,KAAK;AACT,UAAI;AACJ,UAAI,2BAA2B,IAAI,GAAG;AACpC,cAAM,KAAK,gBAAgB,IAAI;AAAA,MACjC,OAAO;AACL,gBAAQ,MAAM;AAAA,UACZ,KAAK;AACH,kBAAM,KAAK,oBAAoB,KAAK;AACpC;AAAA,UACF,KAAK;AACH,kBAAM,KAAK,mBAAmB,KAAK;AACnC;AAAA,UACF,KAAK;AACH,kBAAM,KAAK,mBAAmB,KAAK;AACnC;AAAA,UACF,KAAK;AACH,kBAAM,KAAK,oBAAoB,KAAK;AACpC;AAAA,UACF,KAAK,KACH;AACE,kBAAM,gBAAgB,KAAK,MAAM;AACjC,gBAAI,uBAAuB,MAAM;AAC/B,kBAAI,oBAAoB,kBAAkB,MAAM;AAC9C,oCAAoB,gBAAgB;AAAA,cACtC;AAAA,YACF,OAAO;AACL,mBAAK,MAAM,OAAO,wBAAwB,aAAa;AAAA,YACzD;AACA,kBAAM,KAAK,iBAAiB;AAC5B;AAAA,UACF;AAAA,UACF;AACE,iBAAK,WAAW;AAAA,QACpB;AAAA,MACF;AACA,WAAK,MAAM;AACX,UAAI,SAAS,KAAK;AAChB,aAAK,WAAW;AAAA,MAClB;AAAA,IACF;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EACA,aAAa,MAAM,SAAS;AAC1B,SAAK,KAAK;AACV,SAAK,YAAY;AACjB,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,YAAY,MAAM,aAAa,SAAS,eAAe,kBAAkB,MAAM,eAAe,OAAO;AACnG,SAAK,aAAa,MAAM,OAAO;AAC/B,SAAK,YAAY;AACjB,SAAK,MAAM,MAAM,IAAI,MAAM,eAAe,KAAK,MAAM,mBAAmB,KAAK,EAAE;AAC/E,SAAK,UAAU,MAAM,cAAc,SAAS,KAAK,SAAS,CAAC;AAC3D,SAAK,oBAAoB,MAAM,aAAa;AAC5C,UAAM,eAAe,KAAK,2BAA2B,MAAM,MAAM,IAAI;AACrE,SAAK,UAAU,KAAK;AACpB,SAAK,MAAM,KAAK;AAChB,WAAO;AAAA,EACT;AAAA,EACA,eAAe,OAAO,cAAc,SAAS,qBAAqB;AAChE,QAAI,SAAS;AACX,WAAK,aAAa,gBAAgB;AAAA,IACpC;AACA,UAAM,gCAAgC,KAAK,MAAM;AACjD,SAAK,MAAM,6BAA6B;AACxC,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,SAAK,WAAW,KAAK,cAAc,OAAO,CAAC,SAAS,qBAAqB,IAAI;AAC7E,SAAK,MAAM,6BAA6B;AACxC,WAAO,KAAK,WAAW,MAAM,UAAU,oBAAoB,iBAAiB;AAAA,EAC9E;AAAA,EACA,qBAAqB,MAAM,QAAQ,SAAS,kBAAkB;AAC5D,SAAK,MAAM,MAAM,IAAI,CAAC;AACtB,QAAI,QAAQ,cAAc,SAAS,KAAK;AACxC,QAAI,CAAC,KAAK,MAAM,CAAC,KAAK,KAAK,UAAU,OAAO;AAC1C,eAAS;AAAA,IACX;AACA,SAAK,UAAU,MAAM,KAAK;AAC1B,SAAK,aAAa,MAAM,OAAO;AAC/B,UAAM,4BAA4B,KAAK,MAAM;AAC7C,QAAI,QAAQ;AACV,WAAK,MAAM,yBAAyB;AACpC,WAAK,2BAA2B,MAAM,QAAQ,gBAAgB;AAAA,IAChE;AACA,SAAK,MAAM,yBAAyB;AACpC,SAAK,kBAAkB,MAAM,IAAI;AACjC,SAAK,UAAU,KAAK;AACpB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,yBAAyB;AACpC,WAAO,KAAK,WAAW,MAAM,yBAAyB;AAAA,EACxD;AAAA,EACA,2BAA2B,MAAM,QAAQ,kBAAkB;AACzD,SAAK,iBAAiB,QAAQ,kBAAkB,KAAK;AACrD,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,2BAA2B,MAAM,MAAM,WAAW,OAAO;AACvD,SAAK,kBAAkB,MAAM,OAAO,QAAQ;AAC5C,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AAAA,EACA,kBAAkB,MAAM,iBAAiB,WAAW,OAAO;AACzD,UAAM,eAAe,mBAAmB,CAAC,KAAK,MAAM,CAAC;AACrD,SAAK,gBAAgB,MAAM,mBAAmB,CAAC;AAC/C,QAAI,cAAc;AAChB,WAAK,OAAO,KAAK,iBAAiB;AAClC,WAAK,YAAY,MAAM,OAAO,iBAAiB,KAAK;AAAA,IACtD,OAAO;AACL,YAAM,YAAY,KAAK,MAAM;AAC7B,YAAM,YAAY,KAAK,MAAM;AAC7B,WAAK,MAAM,SAAS,CAAC;AACrB,WAAK,UAAU,MAAM,KAAK,UAAU,aAAa,IAAI,CAAC;AACtD,WAAK,OAAO,KAAK,WAAW,MAAM,OAAO,4BAA0B;AACjE,cAAM,YAAY,CAAC,KAAK,kBAAkB,KAAK,MAAM;AACrD,YAAI,0BAA0B,WAAW;AACvC,eAAK,MAAM,OAAO,+BAA+B,KAAK,SAAS,YAAY,KAAK,SAAS,kBAAkB,CAAC,CAAC,KAAK,MAAM,KAAK,IAAI,IAAI,MAAM,IAAI;AAAA,QACjJ;AACA,cAAM,oBAAoB,CAAC,aAAa,KAAK,MAAM;AACnD,aAAK,YAAY,MAAM,CAAC,KAAK,MAAM,UAAU,CAAC,mBAAmB,CAAC,YAAY,CAAC,WAAW,iBAAiB,iBAAiB;AAC5H,YAAI,KAAK,MAAM,UAAU,KAAK,IAAI;AAChC,eAAK,gBAAgB,KAAK,IAAI,IAAI,iBAAiB;AAAA,QACrD;AAAA,MACF,CAAC;AACD,WAAK,UAAU,KAAK;AACpB,WAAK,MAAM,SAAS;AAAA,IACtB;AACA,SAAK,gBAAgB,KAAK;AAAA,EAC5B;AAAA,EACA,kBAAkB,MAAM;AACtB,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EACA,kBAAkB,QAAQ;AACxB,aAAS,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,KAAK;AACjD,UAAI,CAAC,KAAK,kBAAkB,OAAO,CAAC,CAAC;AAAG,eAAO;AAAA,IACjD;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM,iBAAiB,iBAAiB,oBAAoB,MAAM;AAC5E,UAAM,eAAe,CAAC,mBAAmB,oBAAI,IAAI;AACjD,UAAM,mBAAmB;AAAA,MACvB,MAAM;AAAA,IACR;AACA,eAAW,SAAS,KAAK,QAAQ;AAC/B,WAAK,UAAU,OAAO;AAAA,QACpB,IAAI;AAAA,QACJ,SAAS;AAAA,QACT;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,cAAc,OAAO,YAAY,qBAAqB,cAAc;AAClE,UAAM,OAAO,CAAC;AACd,QAAI,QAAQ;AACZ,WAAO,CAAC,KAAK,IAAI,KAAK,GAAG;AACvB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,aAAK,OAAO,EAAE;AACd,YAAI,KAAK,MAAM,KAAK,GAAG;AACrB,cAAI,cAAc;AAChB,iBAAK,4BAA4B,YAAY;AAAA,UAC/C;AACA,eAAK,KAAK;AACV;AAAA,QACF;AAAA,MACF;AACA,WAAK,KAAK,KAAK,kBAAkB,YAAY,mBAAmB,CAAC;AAAA,IACnE;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,YAAY,qBAAqB,kBAAkB;AACnE,QAAI;AACJ,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,CAAC,YAAY;AACf,aAAK,MAAM,OAAO,iBAAiB,KAAK,MAAM,YAAY,GAAG;AAAA,UAC3D,YAAY;AAAA,QACd,CAAC;AAAA,MACH;AACA,YAAM;AAAA,IACR,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,YAAM,qBAAqB,KAAK,MAAM;AACtC,YAAM,KAAK,eAAe,KAAK,YAAY,mBAAmB,GAAG,kBAAkB;AAAA,IACrF,WAAW,KAAK,MAAM,EAAE,GAAG;AACzB,WAAK,aAAa,oBAAoB;AACtC,UAAI,CAAC,kBAAkB;AACrB,aAAK,MAAM,OAAO,+BAA+B,KAAK,MAAM,QAAQ;AAAA,MACtE;AACA,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,KAAK;AACV,YAAM,KAAK,WAAW,MAAM,qBAAqB;AAAA,IACnD,OAAO;AACL,YAAM,KAAK,wBAAwB,qBAAqB,KAAK,cAAc;AAAA,IAC7E;AACA,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,SAAS;AACvB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,OAAO,KAAK,oBAAoB,OAAO;AAC7C,WAAO,KAAK,iBAAiB,MAAM,IAAI;AAAA,EACzC;AAAA,EACA,iBAAiB,MAAM,MAAM;AAC3B,SAAK,OAAO;AACZ,SAAK,IAAI,iBAAiB;AAC1B,WAAO,KAAK,WAAW,MAAM,YAAY;AAAA,EAC3C;AAAA,EACA,oBAAoB,SAAS;AAC3B,QAAI;AACJ,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AACT,QAAI,2BAA2B,IAAI,GAAG;AACpC,aAAO,KAAK,MAAM;AAAA,IACpB,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AACA,UAAMC,kBAAiB,kCAAkC,IAAI;AAC7D,QAAI,SAAS;AACX,UAAIA,iBAAgB;AAClB,aAAK,aAAa,GAAG;AAAA,MACvB;AAAA,IACF,OAAO;AACL,WAAK,kBAAkB,MAAM,UAAUA,iBAAgB,KAAK;AAAA,IAC9D;AACA,SAAK,KAAK;AACV,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,MAAM,UAAU,eAAe,WAAW;AAC1D,QAAI,KAAK,SAAS,IAAI;AACpB;AAAA,IACF;AACA,QAAI,CAAC,kBAAkB,IAAI,GAAG;AAC5B;AAAA,IACF;AACA,QAAI,iBAAiB,UAAU,IAAI,GAAG;AACpC,WAAK,MAAM,OAAO,mBAAmB,UAAU;AAAA,QAC7C,SAAS;AAAA,MACX,CAAC;AACD;AAAA,IACF;AACA,UAAM,eAAe,CAAC,KAAK,MAAM,SAAS,iBAAiB,YAAY,2BAA2B;AAClG,QAAI,aAAa,MAAM,KAAK,QAAQ,GAAG;AACrC,WAAK,MAAM,OAAO,wBAAwB,UAAU;AAAA,QAClD,cAAc;AAAA,MAChB,CAAC;AACD;AAAA,IACF,WAAW,SAAS,SAAS;AAC3B,UAAI,KAAK,UAAU,UAAU;AAC3B,aAAK,MAAM,OAAO,wBAAwB,QAAQ;AAClD;AAAA,MACF;AAAA,IACF,WAAW,SAAS,SAAS;AAC3B,UAAI,KAAK,UAAU,UAAU;AAC3B,aAAK,MAAM,OAAO,wBAAwB,QAAQ;AAClD;AAAA,MACF;AACA,UAAI,KAAK,MAAM,eAAe;AAC5B,aAAK,MAAM,OAAO,qCAAqC,QAAQ;AAC/D;AAAA,MACF;AACA,WAAK,gBAAgB,gCAAgC,QAAQ;AAAA,IAC/D,WAAW,SAAS,aAAa;AAC/B,UAAI,KAAK,MAAM,iCAAiC;AAC9C,aAAK,MAAM,OAAO,kBAAkB,QAAQ;AAC5C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,iBAAiB;AACf,QAAI,KAAK,UAAU;AAAU,aAAO;AACpC,QAAI,KAAK,QAAQ,6BAA6B,CAAC,KAAK,MAAM,YAAY;AACpE,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,WAAW,UAAU;AACnB,UAAM,OAAO,KAAK,YAAY,QAAQ;AACtC,SAAK,gBAAgB,gCAAgC,OAAO,gCAAgC,IAAI;AAChG,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,MAAM,OAAO,mBAAmB,IAAI;AAAA,IAC3C;AACA,QAAI,CAAC,KAAK,MAAM,cAAc,CAAC,KAAK,QAAQ,2BAA2B;AACrE,UAAI,KAAK,iBAAiB,GAAG;AAC3B,aAAK,8BAA8B;AAAA,MACrC,OAAO;AACL,aAAK,oBAAoB;AAAA,MAC3B;AAAA,IACF;AACA,QAAI,CAAC,KAAK,MAAM,WAAW;AACzB,WAAK,WAAW,KAAK,gBAAgB,MAAM,IAAI;AAAA,IACjD;AACA,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,mBAAmB;AACjB,QAAI,KAAK,sBAAsB;AAAG,aAAO;AACzC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,WAAO,SAAS,MAAM,SAAS,MAAM,SAAS,KAAK,gBAAgB,IAAI,KAAK,SAAS,OAAO,CAAC,KAAK,MAAM,eAAe,SAAS,OAAO,SAAS,MAAM,KAAK,UAAU,aAAa,KAAK,SAAS;AAAA,EAClM;AAAA,EACA,aAAa;AACX,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,gBAAgB,gCAAgC,OAAO,kBAAkB,IAAI;AAClF,SAAK,KAAK;AACV,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,CAAC,KAAK,sBAAsB,GAAG;AACjC,mBAAa,KAAK,IAAI,EAAE;AACxB,cAAQ,KAAK,MAAM,MAAM;AAAA,QACvB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACH,cAAI,CAAC;AAAY;AAAA,QACnB;AACE,qBAAW,KAAK,iBAAiB;AAAA,MACrC;AAAA,IACF;AACA,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,gBAAgB,MAAM;AACpB,SAAK,KAAK;AACV,SAAK,SAAS,KAAK,wBAAwB;AAC3C,QAAI,KAAK,UAAU,kBAAkB,KAAK,KAAK,UAAU,kBAAkB,GAAG;AAC5E,WAAK,UAAU;AAAA,IACjB;AACA,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,WAAK,6BAA6B;AAClC,UAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAK,UAAU,KAAK,wBAAwB;AAC5C,aAAK,IAAI,EAAE;AAAA,MACb;AAAA,IACF;AACA,SAAK,OAAO,EAAE;AACd,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,6BAA6B,MAAM,cAAc;AAC/C,QAAI,KAAK,UAAU,CAAC,oBAAoB;AAAA,MACtC,UAAU;AAAA,IACZ,CAAC,CAAC,GAAG;AACH,UAAI,KAAK,SAAS,sBAAsB;AACtC,aAAK,MAAM,OAAO,gCAAgC,YAAY;AAAA,MAChE;AAAA,IACF;AAAA,EACF;AAAA,EACA,8BAA8B,WAAW,UAAU;AACjD,QAAI,KAAK,kBAAkB,SAAS,GAAG;AACrC,YAAM,WAAW,KAAK,YAAY,QAAQ;AAC1C,eAAS,SAAS;AAClB,aAAO,KAAK,WAAW,UAAU,sBAAsB;AAAA,IACzD,OAAO;AACL,YAAM,WAAW,KAAK,YAAY,QAAQ;AAC1C,WAAK,mCAAmC,QAAQ;AAChD,eAAS,aAAa;AACtB,aAAO,KAAK,WAAW,UAAU,yBAAyB;AAAA,IAC5D;AAAA,EACF;AAAA,EACA,kBAAkB,YAAY;AAC5B,YAAQ,WAAW,MAAM;AAAA,MACvB,KAAK;AACH,eAAO,CAAC,WAAW,YAAY,KAAK,kBAAkB,WAAW,MAAM;AAAA,MACzE,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EACA,mCAAmC,UAAU;AAC3C,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,KAAK,MAAM,OAAO,qBAAqB,KAAK,MAAM,QAAQ;AAAA,IAClE;AACA,QAAI,CAAC,KAAK,sCAAsC,GAAG;AACjD,WAAK,MAAM,OAAO,qBAAqB,QAAQ;AAAA,IACjD;AAAA,EACF;AAAA,EACA,wBAAwB,UAAU;AAChC,UAAM,yBAAyB,KAAK,MAAM;AAC1C,SAAK,MAAM,eAAe;AAAA,MACxB,0BAA0B;AAAA,MAC1B,eAAe;AAAA,IACjB;AACA,QAAI;AACF,aAAO,SAAS;AAAA,IAClB,UAAE;AACA,WAAK,MAAM,eAAe;AAAA,IAC5B;AAAA,EACF;AAAA,EACA,mCAAmC,UAAU;AAC3C,QAAI,KAAK,UAAU,CAAC,oBAAoB;AAAA,MACtC,UAAU;AAAA,IACZ,CAAC,CAAC,GAAG;AACH,YAAM,yBAAyB,KAAK,MAAM;AAC1C,WAAK,MAAM,eAAe;AAAA,QACxB,0BAA0B;AAAA,QAC1B,eAAe;AAAA,MACjB;AACA,UAAI;AACF,eAAO,SAAS;AAAA,MAClB,UAAE;AACA,aAAK,MAAM,eAAe;AAAA,MAC5B;AAAA,IACF,OAAO;AACL,aAAO,SAAS;AAAA,IAClB;AAAA,EACF;AAAA,EACA,+BAA+B,UAAU;AACvC,UAAM,6BAA6B,KAAK,MAAM;AAC9C,SAAK,MAAM,YAAY;AACvB,QAAI;AACF,aAAO,SAAS;AAAA,IAClB,UAAE;AACA,WAAK,MAAM,YAAY;AAAA,IACzB;AAAA,EACF;AAAA,EACA,WAAW,UAAU;AACnB,UAAM,QAAQ,KAAK,UAAU,aAAa;AAC1C,UAAM,iBAAiB,IAAI,CAAC;AAC5B,QAAI,gBAAgB;AAClB,WAAK,UAAU,MAAM,QAAQ,CAAC;AAC9B,UAAI;AACF,eAAO,SAAS;AAAA,MAClB,UAAE;AACA,aAAK,UAAU,KAAK;AAAA,MACtB;AAAA,IACF;AACA,WAAO,SAAS;AAAA,EAClB;AAAA,EACA,cAAc,UAAU;AACtB,UAAM,QAAQ,KAAK,UAAU,aAAa;AAC1C,UAAM,mBAAmB,IAAI;AAC7B,QAAI,kBAAkB;AACpB,WAAK,UAAU,MAAM,QAAQ,CAAC,CAAC;AAC/B,UAAI;AACF,eAAO,SAAS;AAAA,MAClB,UAAE;AACA,aAAK,UAAU,KAAK;AAAA,MACtB;AAAA,IACF;AACA,WAAO,SAAS;AAAA,EAClB;AAAA,EACA,yBAAyB;AACvB,SAAK,MAAM,aAAa,gBAAgB;AAAA,EAC1C;AAAA,EACA,0CAA0C;AACxC,WAAO,KAAK,MAAM,aAAa,4BAA4B;AAAA,EAC7D;AAAA,EACA,wCAAwC;AACtC,WAAO,KAAK,MAAM,aAAa,iBAAiB,QAAQ,KAAK,MAAM,aAAa,iBAAiB;AAAA,EACnG;AAAA,EACA,wBAAwB,MAAM;AAC5B,UAAM,WAAW,KAAK,MAAM;AAC5B,SAAK,MAAM,mBAAmB,KAAK,MAAM;AACzC,UAAM,gCAAgC,KAAK,MAAM;AACjD,SAAK,MAAM,6BAA6B;AACxC,UAAM,MAAM,KAAK,YAAY,KAAK,yBAAyB,GAAG,UAAU,IAAI;AAC5E,SAAK,MAAM,6BAA6B;AACxC,WAAO;AAAA,EACT;AAAA,EACA,wBAAwB;AACtB,SAAK,aAAa,cAAc;AAChC,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,QAAI,CAAC,KAAK,MAAM,CAAC,GAAG;AAClB,WAAK,WAAW,MAAM,CAAC;AAAA,IACzB;AACA,UAAM,UAAU,KAAK,YAAY,KAAK,MAAM,MAAM;AAClD,SAAK,KAAK;AACV,UAAM,eAAe,KAAK,iBAAiB,IAAI;AAC/C,SAAK,mBAAmB;AACxB,QAAI;AACF,WAAK,OAAO,KAAK,aAAa,SAAS,GAAG,QAAQ;AAAA,IACpD,UAAE;AACA,mBAAa;AAAA,IACf;AACA,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,gCAAgC,MAAM;AAAA,EAAC;AACzC;AACA,MAAM,YAAY;AAAA,EACd,MAAM;AACR,GACA,cAAc;AAAA,EACZ,MAAM;AACR;AACF,MAAM,gBAAgB;AACtB,MAAM,4BAA4B;AAClC,SAAS,mBAAmB,QAAQ,OAAO;AACzC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,QAAQ,OAAO,CAAC;AACtB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,OAAO,SAAS,UAAU;AAC5B;AACE,YAAI,SAAS,KAAK;AAChB,gBAAM;AAAA,YACJ;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,IAAI;AACJ,gBAAM,aAAa,QAAQ;AAC3B,gBAAM,aAAa,+BAA+B,IAAI,OAAO,CAAC;AAC9D,iBAAO,OAAO,GAAG,GAAG,IAAI,MAAM;AAAA,YAC5B,MAAM,iBAAiB,EAAE;AAAA,YACzB,OAAO;AAAA,YACP;AAAA,YACA,KAAK;AAAA,YACL,UAAU,IAAI;AAAA,YACd,QAAQ;AAAA,UACV,CAAC,GAAG,IAAI,MAAM;AAAA,YACZ,MAAM,iBAAiB,GAAG;AAAA,YAC1B;AAAA,YACA,OAAO;AAAA,YACP;AAAA,YACA,UAAU;AAAA,YACV,QAAQ,IAAI;AAAA,UACd,CAAC,CAAC;AACF;AACA;AAAA,QACF;AACA,YAAI,gBAAgB,IAAI,GAAG;AACzB,gBAAM;AAAA,YACJ;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,IAAI;AACJ,gBAAM,eAAe,QAAQ;AAC7B,gBAAM,kBAAkB,+BAA+B,IAAI,OAAO,CAAC;AACnE,cAAI;AACJ,cAAI,MAAM,WAAW,KAAK,MAAM,IAAI;AAClC,yBAAa,IAAI,MAAM;AAAA,cACrB,MAAM,iBAAiB,EAAE;AAAA,cACzB,OAAO;AAAA,cACP;AAAA,cACA,KAAK;AAAA,cACL,UAAU,IAAI;AAAA,cACd,QAAQ;AAAA,YACV,CAAC;AAAA,UACH,OAAO;AACL,yBAAa,IAAI,MAAM;AAAA,cACrB,MAAM,iBAAiB,CAAC;AAAA,cACxB,OAAO;AAAA,cACP;AAAA,cACA,KAAK;AAAA,cACL,UAAU,IAAI;AAAA,cACd,QAAQ;AAAA,YACV,CAAC;AAAA,UACH;AACA,cAAI,eAAe,oBAAoB,uBAAuB;AAC9D,cAAI,SAAS,IAAI;AACf,iCAAqB,MAAM;AAC3B,oCAAwB,+BAA+B,IAAI,KAAK,EAAE;AAClE,4BAAgB,UAAU,OAAO,OAAO,MAAM,MAAM,GAAG,EAAE;AACzD,uBAAW,IAAI,MAAM;AAAA,cACnB,MAAM,iBAAiB,EAAE;AAAA,cACzB,OAAO;AAAA,cACP,OAAO;AAAA,cACP;AAAA,cACA,UAAU;AAAA,cACV,QAAQ,IAAI;AAAA,YACd,CAAC;AAAA,UACH,OAAO;AACL,iCAAqB,MAAM;AAC3B,oCAAwB,+BAA+B,IAAI,KAAK,EAAE;AAClE,4BAAgB,UAAU,OAAO,OAAO,MAAM,MAAM,GAAG,EAAE;AACzD,uBAAW,IAAI,MAAM;AAAA,cACnB,MAAM,iBAAiB,EAAE;AAAA,cACzB,OAAO;AAAA,cACP,OAAO;AAAA,cACP;AAAA,cACA,UAAU;AAAA,cACV,QAAQ,IAAI;AAAA,YACd,CAAC;AAAA,UACH;AACA,iBAAO,OAAO,GAAG,GAAG,YAAY,IAAI,MAAM;AAAA,YACxC,MAAM,iBAAiB,EAAE;AAAA,YACzB,OAAO;AAAA,YACP,OAAO;AAAA,YACP,KAAK;AAAA,YACL,UAAU;AAAA,YACV,QAAQ;AAAA,UACV,CAAC,GAAG,QAAQ;AACZ,eAAK;AACL;AAAA,QACF;AAAA,MACF;AACA,YAAM,OAAO,iBAAiB,IAAI;AAAA,IACpC;AAAA,EACF;AACA,SAAO;AACT;AACA,MAAM,wBAAwB,iBAAiB;AAAA,EAC7C,cAAc,MAAM,SAAS;AAC3B,SAAK,UAAU,KAAK,aAAa,OAAO;AACxC,SAAK,WAAW,KAAK;AACrB,QAAI,KAAK,QAAQ,QAAQ;AACvB,WAAK,SAAS,mBAAmB,KAAK,QAAQ,KAAK,KAAK;AAAA,IAC1D;AACA,WAAO,KAAK,WAAW,MAAM,MAAM;AAAA,EACrC;AAAA,EACA,aAAa,SAAS,MAAM,KAAK,aAAa,KAAK,QAAQ,YAAY;AACrE,YAAQ,aAAa;AACrB,YAAQ,cAAc,KAAK,0BAA0B;AACrD,SAAK,eAAe,SAAS,MAAM,MAAM,GAAG;AAC5C,QAAI,KAAK,YAAY,CAAC,KAAK,QAAQ,0BAA0B,KAAK,MAAM,iBAAiB,OAAO,GAAG;AACjG,iBAAW,CAAC,WAAW,EAAE,KAAK,MAAM,KAAK,KAAK,MAAM,gBAAgB,GAAG;AACrE,aAAK,MAAM,OAAO,uBAAuB,IAAI;AAAA,UAC3C;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,QAAI;AACJ,QAAI,QAAQ,KAAK;AACf,wBAAkB,KAAK,WAAW,SAAS,SAAS;AAAA,IACtD,OAAO;AACL,wBAAkB,KAAK,aAAa,SAAS,WAAW,+BAA+B,KAAK,MAAM,UAAU,EAAE,CAAC;AAAA,IACjH;AACA,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,MAAM;AACpB,UAAM,YAAY;AAClB,cAAU,OAAO;AACjB,cAAU,QAAQ,UAAU;AAC5B,WAAO,UAAU;AACjB,UAAM,mBAAmB,UAAU;AACnC,UAAM,kBAAkB,iBAAiB;AACzC,UAAM,MAAM,KAAK,MAAM,MAAM,iBAAiB,OAAO,iBAAiB,GAAG;AACzE,UAAM,MAAM,iBAAiB,QAAQ,IAAI,MAAM,GAAG,EAAE;AACpD,SAAK,SAAS,kBAAkB,OAAO,GAAG;AAC1C,SAAK,SAAS,kBAAkB,YAAY,GAAG;AAC/C,SAAK,SAAS,kBAAkB,mBAAmB,eAAe;AAClE,qBAAiB,OAAO;AACxB,WAAO;AAAA,EACT;AAAA,EACA,4BAA4B;AAC1B,QAAI,CAAC,KAAK,MAAM,EAAE,GAAG;AACnB,aAAO;AAAA,IACT;AACA,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,QAAQ,KAAK,MAAM;AACxB,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,EACrD;AAAA,EACA,QAAQ;AACN,QAAI,CAAC,KAAK,aAAa,GAAG,GAAG;AAC3B,aAAO;AAAA,IACT;AACA,WAAO,KAAK,wBAAwB;AAAA,EACtC;AAAA,EACA,0BAA0B,IAAI,KAAK;AACjC,QAAI,kBAAkB,EAAE,GAAG;AACzB,gCAA0B,YAAY;AACtC,UAAI,0BAA0B,KAAK,KAAK,KAAK,GAAG;AAC9C,cAAM,QAAQ,KAAK,eAAe,0BAA0B,SAAS;AACrE,YAAI,CAAC,iBAAiB,KAAK,KAAK,UAAU,IAAI;AAC5C,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT,WAAW,OAAO,IAAI;AACpB,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,uBAAuB,IAAI;AACzB,WAAO,OAAO,MAAM,OAAO;AAAA,EAC7B;AAAA,EACA,0BAA0B;AACxB,UAAM,OAAO,KAAK,eAAe;AACjC,UAAM,SAAS,KAAK,eAAe,IAAI;AACvC,WAAO,KAAK,uBAAuB,MAAM,KAAK,KAAK,0BAA0B,QAAQ,IAAI;AAAA,EAC3F;AAAA,EACA,sCAAsC;AACpC,UAAM,OAAO,KAAK,qBAAqB;AACvC,UAAM,SAAS,KAAK,eAAe,IAAI;AACvC,WAAO,KAAK,0BAA0B,QAAQ,IAAI;AAAA,EACpD;AAAA,EACA,mBAAmB;AACjB,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,KAAK,UAAU;AACnB,QAAI,SAAS,OAAO,CAAC,aAAa;AAChC,aAAO;AAAA,IACT,WAAW,kBAAkB,IAAI,KAAK,CAAC,KAAK,sBAAsB,GAAG;AACnE,WAAK,aAAa,4BAA4B;AAC9C,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,mBAAmB;AACjB,QAAI,OAAO,KAAK,qBAAqB;AACrC,QAAI,KAAK,qBAAqB,MAAM,OAAO,GAAG;AAC5C,aAAO,KAAK,0BAA0B,OAAO,CAAC;AAC9C,YAAM,SAAS,KAAK,eAAe,IAAI;AACvC,UAAI,KAAK,0BAA0B,QAAQ,IAAI,GAAG;AAChD,aAAK,aAAa,4BAA4B;AAC9C,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB;AAChB,WAAO,KAAK,mBAAmB,IAAI,IAAI,IAAI,CAAC;AAAA,EAC9C;AAAA,EACA,yBAAyB;AACvB,WAAO,KAAK,mBAAmB,IAAI,KAAK,CAAC,KAAK,QAAQ,UAAU,KAAK,MAAM,SAAS,IAAI,EAAE;AAAA,EAC5F;AAAA,EACA,gDAAgD,uBAAuB,OAAO;AAC5E,QAAI,QAAQ;AACZ,QAAI,KAAK,QAAQ,UAAU,CAAC,KAAK,MAAM,QAAQ;AAC7C,eAAS;AACT,UAAI,sBAAsB;AACxB,iBAAS;AAAA,MACX;AAAA,IACF;AACA,WAAO,KAAK,mBAAmB,KAAK;AAAA,EACtC;AAAA,EACA,iBAAiB;AACf,WAAO,KAAK,mBAAmB,CAAC;AAAA,EAClC;AAAA,EACA,mBAAmB,OAAO;AACxB,QAAI,aAAa;AACjB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,mBAAa,KAAK,gBAAgB,IAAI;AAAA,IACxC;AACA,WAAO,KAAK,sBAAsB,OAAO,UAAU;AAAA,EACrD;AAAA,EACA,sBAAsB,OAAO,YAAY;AACvC,UAAM,YAAY,KAAK,MAAM;AAC7B,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,mBAAmB,CAAC,EAAE,QAAQ;AACpC,UAAM,2BAA2B,CAAC,EAAE,QAAQ;AAC5C,UAAM,WAAW,QAAQ;AACzB,YAAQ,WAAW;AAAA,MACjB,KAAK;AACH,eAAO,KAAK,4BAA4B,MAAM,IAAI;AAAA,MACpD,KAAK;AACH,eAAO,KAAK,4BAA4B,MAAM,KAAK;AAAA,MACrD,KAAK;AACH,eAAO,KAAK,uBAAuB,IAAI;AAAA,MACzC,KAAK;AACH,eAAO,KAAK,sBAAsB,IAAI;AAAA,MACxC,KAAK;AACH,eAAO,KAAK,kBAAkB,IAAI;AAAA,MACpC,KAAK;AACH,YAAI,KAAK,kBAAkB,MAAM;AAAI;AACrC,YAAI,CAAC,0BAA0B;AAC7B,eAAK,MAAM,KAAK,MAAM,SAAS,OAAO,iBAAiB,KAAK,QAAQ,SAAS,OAAO,uBAAuB,OAAO,gBAAgB,KAAK,MAAM,QAAQ;AAAA,QACvJ;AACA,eAAO,KAAK,uBAAuB,MAAM,OAAO,CAAC,oBAAoB,wBAAwB;AAAA,MAC/F,KAAK;AACH,YAAI,CAAC;AAAkB,eAAK,WAAW;AACvC,eAAO,KAAK,WAAW,KAAK,oBAAoB,YAAY,IAAI,GAAG,IAAI;AAAA,MACzE,KAAK;AACH,eAAO,KAAK,iBAAiB,IAAI;AAAA,MACnC,KAAK;AACH,eAAO,KAAK,qBAAqB,IAAI;AAAA,MACvC,KAAK;AACH,eAAO,KAAK,qBAAqB,IAAI;AAAA,MACvC,KAAK;AACH,eAAO,KAAK,oBAAoB,IAAI;AAAA,MACtC,KAAK;AACH,eAAO,KAAK,kBAAkB,IAAI;AAAA,MACpC,KAAK;AACH,YAAI,CAAC,KAAK,MAAM,eAAe,KAAK,iBAAiB,GAAG;AACtD,cAAI,CAAC,KAAK,eAAe,GAAG;AAC1B,iBAAK,MAAM,OAAO,6BAA6B,IAAI;AAAA,UACrD,WAAW,CAAC,kBAAkB;AAC5B,iBAAK,MAAM,OAAO,8BAA8B,IAAI;AAAA,UACtD;AACA,eAAK,KAAK;AACV,iBAAO,KAAK,kBAAkB,MAAM,aAAa;AAAA,QACnD;AACA;AAAA,MACF,KAAK;AACH,YAAI,KAAK,MAAM,eAAe,CAAC,KAAK,oCAAoC,GAAG;AACzE;AAAA,QACF;AACA,aAAK,aAAa,4BAA4B;AAC9C,YAAI,CAAC,KAAK,MAAM,YAAY,KAAK,MAAM,YAAY;AACjD,eAAK,MAAM,OAAO,4BAA4B,KAAK,MAAM,QAAQ;AAAA,QACnE,WAAW,CAAC,kBAAkB;AAC5B,eAAK,MAAM,OAAO,8BAA8B,KAAK,MAAM,QAAQ;AAAA,QACrE;AACA,eAAO,KAAK,kBAAkB,MAAM,OAAO;AAAA,MAC7C,KAAK,KACH;AACE,YAAI,KAAK,MAAM,aAAa;AAC1B;AAAA,QACF;AACA,cAAM,OAAO,KAAK,eAAe;AACjC,cAAM,SAAS,KAAK,eAAe,IAAI;AACvC,YAAI,WAAW,IAAI;AACjB,cAAI,CAAC,oBAAoB,KAAK,sBAAsB;AAAG;AACvD,cAAI,CAAC,KAAK,0BAA0B,QAAQ,IAAI,KAAK,WAAW,KAAK;AACnE;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACF,KAAK,IACH;AACE,YAAI,CAAC,kBAAkB;AACrB,eAAK,MAAM,OAAO,8BAA8B,KAAK,MAAM,QAAQ;AAAA,QACrE;AAAA,MACF;AAAA,MACF,KAAK,IACH;AACE,cAAM,OAAO,KAAK,MAAM;AACxB,eAAO,KAAK,kBAAkB,MAAM,IAAI;AAAA,MAC1C;AAAA,MACF,KAAK;AACH,eAAO,KAAK,oBAAoB,IAAI;AAAA,MACtC,KAAK;AACH,eAAO,KAAK,mBAAmB,IAAI;AAAA,MACrC,KAAK;AACH,eAAO,KAAK,WAAW;AAAA,MACzB,KAAK;AACH,eAAO,KAAK,oBAAoB,IAAI;AAAA,MACtC,KAAK,IACH;AACE,cAAM,oBAAoB,KAAK,kBAAkB;AACjD,YAAI,sBAAsB,MAAM,sBAAsB,IAAI;AACxD;AAAA,QACF;AAAA,MACF;AAAA,MACF,KAAK,IACH;AACE,YAAI,CAAC,KAAK,QAAQ,+BAA+B,CAAC,UAAU;AAC1D,eAAK,MAAM,OAAO,wBAAwB,KAAK,MAAM,QAAQ;AAAA,QAC/D;AACA,aAAK,KAAK;AACV,YAAI;AACJ,YAAI,cAAc,IAAI;AACpB,mBAAS,KAAK,YAAY,IAAI;AAC9B,cAAI,OAAO,SAAS,wBAAwB,CAAC,OAAO,cAAc,OAAO,eAAe,UAAU;AAChG,iBAAK,oBAAoB;AAAA,UAC3B;AAAA,QACF,OAAO;AACL,mBAAS,KAAK,YAAY,MAAM,UAAU;AAC1C,cAAI,OAAO,SAAS,6BAA6B,CAAC,OAAO,cAAc,OAAO,eAAe,YAAY,OAAO,SAAS,2BAA2B,CAAC,OAAO,cAAc,OAAO,eAAe,YAAY,OAAO,SAAS,4BAA4B;AACtP,iBAAK,oBAAoB;AAAA,UAC3B;AAAA,QACF;AACA,aAAK,wBAAwB,MAAM;AACnC,eAAO;AAAA,MACT;AAAA,MACF,SACE;AACE,YAAI,KAAK,gBAAgB,GAAG;AAC1B,cAAI,CAAC,kBAAkB;AACrB,iBAAK,MAAM,OAAO,uCAAuC,KAAK,MAAM,QAAQ;AAAA,UAC9E;AACA,eAAK,KAAK;AACV,iBAAO,KAAK,uBAAuB,MAAM,MAAM,CAAC,oBAAoB,wBAAwB;AAAA,QAC9F;AAAA,MACF;AAAA,IACJ;AACA,UAAM,YAAY,KAAK,MAAM;AAC7B,UAAM,OAAO,KAAK,gBAAgB;AAClC,QAAI,kBAAkB,SAAS,KAAK,KAAK,SAAS,gBAAgB,KAAK,IAAI,EAAE,GAAG;AAC9E,aAAO,KAAK,sBAAsB,MAAM,WAAW,MAAM,KAAK;AAAA,IAChE,OAAO;AACL,aAAO,KAAK,yBAAyB,MAAM,MAAM,UAAU;AAAA,IAC7D;AAAA,EACF;AAAA,EACA,wBAAwB,MAAM;AAC5B,QAAI,CAAC,KAAK,QAAQ,+BAA+B,CAAC,KAAK,UAAU;AAC/D,WAAK,MAAM,OAAO,qBAAqB,IAAI;AAAA,IAC7C;AAAA,EACF;AAAA,EACA,gCAAgC;AAC9B,QAAI,KAAK,UAAU,mBAAmB;AAAG,aAAO;AAChD,WAAO,KAAK,UAAU,YAAY,KAAK,KAAK,gBAAgB,cAAc,wBAAwB,MAAM;AAAA,EAC1G;AAAA,EACA,oBAAoB,iBAAiB,WAAW,YAAY;AAC1D,QAAI,iBAAiB;AACnB,UAAI,UAAU,cAAc,UAAU,WAAW,SAAS,GAAG;AAC3D,YAAI,OAAO,KAAK,gBAAgB,cAAc,wBAAwB,MAAM,WAAW;AACrF,eAAK,MAAM,OAAO,6BAA6B,UAAU,WAAW,CAAC,CAAC;AAAA,QACxE;AACA,kBAAU,WAAW,QAAQ,GAAG,eAAe;AAAA,MACjD,OAAO;AACL,kBAAU,aAAa;AAAA,MACzB;AACA,WAAK,2BAA2B,WAAW,gBAAgB,CAAC,CAAC;AAC7D,UAAI;AAAY,aAAK,2BAA2B,YAAY,SAAS;AAAA,IACvE;AACA,WAAO;AAAA,EACT;AAAA,EACA,0BAA0B;AACxB,WAAO,KAAK,MAAM,EAAE;AAAA,EACtB;AAAA,EACA,gBAAgB,aAAa;AAC3B,UAAM,aAAa,CAAC;AACpB,OAAG;AACD,iBAAW,KAAK,KAAK,eAAe,CAAC;AAAA,IACvC,SAAS,KAAK,MAAM,EAAE;AACtB,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,CAAC,aAAa;AAChB,aAAK,WAAW;AAAA,MAClB;AACA,UAAI,CAAC,KAAK,8BAA8B,GAAG;AACzC,aAAK,MAAM,OAAO,sBAAsB,KAAK,MAAM,QAAQ;AAAA,MAC7D;AAAA,IACF,WAAW,CAAC,KAAK,wBAAwB,GAAG;AAC1C,YAAM,KAAK,MAAM,OAAO,4BAA4B,KAAK,MAAM,QAAQ;AAAA,IACzE;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AACf,SAAK,gBAAgB,CAAC,cAAc,mBAAmB,CAAC;AACxD,UAAM,OAAO,KAAK,UAAU;AAC5B,SAAK,KAAK;AACV,QAAI,KAAK,UAAU,YAAY,GAAG;AAChC,YAAM,WAAW,KAAK,MAAM;AAC5B,UAAI;AACJ,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,cAAMT,YAAW,KAAK,MAAM;AAC5B,aAAK,KAAK;AACV,eAAO,KAAK,gBAAgB;AAC5B,aAAK,OAAO,EAAE;AACd,eAAO,KAAK,gBAAgBA,WAAU,IAAI;AAC1C,cAAM,iBAAiB,KAAK,MAAM;AAClC,aAAK,aAAa,KAAK,6BAA6B,IAAI;AACxD,YAAI,KAAK,gBAAgB,cAAc,wBAAwB,MAAM,SAAS,KAAK,eAAe,MAAM;AACtG,eAAK,MAAM,OAAO,sCAAsC,cAAc;AAAA,QACxE;AAAA,MACF,OAAO;AACL,eAAO,KAAK,gBAAgB,KAAK;AACjC,eAAO,KAAK,IAAI,EAAE,GAAG;AACnB,gBAAMN,QAAO,KAAK,YAAY,QAAQ;AACtC,UAAAA,MAAK,SAAS;AACd,cAAI,KAAK,MAAM,GAAG,GAAG;AACnB,iBAAK,WAAW,eAAe,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQ;AACpE,YAAAA,MAAK,WAAW,KAAK,iBAAiB;AAAA,UACxC,OAAO;AACL,YAAAA,MAAK,WAAW,KAAK,gBAAgB,IAAI;AAAA,UAC3C;AACA,UAAAA,MAAK,WAAW;AAChB,iBAAO,KAAK,WAAWA,OAAM,kBAAkB;AAAA,QACjD;AACA,aAAK,aAAa,KAAK,6BAA6B,IAAI;AAAA,MAC1D;AAAA,IACF,OAAO;AACL,WAAK,aAAa,KAAK,oBAAoB;AAAA,IAC7C;AACA,WAAO,KAAK,WAAW,MAAM,WAAW;AAAA,EAC1C;AAAA,EACA,6BAA6B,MAAM;AACjC,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,OAAO,KAAK,gBAAgB,IAAI;AACtC,WAAK,SAAS;AACd,WAAK,YAAY,KAAK,6BAA6B,IAAI,KAAK;AAC5D,WAAK,iBAAiB,KAAK,SAAS;AACpC,aAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA,EACA,4BAA4B,MAAM,SAAS;AACzC,SAAK,KAAK;AACV,QAAI,KAAK,iBAAiB,GAAG;AAC3B,WAAK,QAAQ;AAAA,IACf,OAAO;AACL,WAAK,QAAQ,KAAK,gBAAgB;AAClC,WAAK,UAAU;AAAA,IACjB;AACA,SAAK,oBAAoB,MAAM,OAAO;AACtC,WAAO,KAAK,WAAW,MAAM,UAAU,mBAAmB,mBAAmB;AAAA,EAC/E;AAAA,EACA,oBAAoB,MAAM,SAAS;AACjC,QAAI;AACJ,SAAK,IAAI,GAAG,IAAI,KAAK,MAAM,OAAO,QAAQ,EAAE,GAAG;AAC7C,YAAM,MAAM,KAAK,MAAM,OAAO,CAAC;AAC/B,UAAI,KAAK,SAAS,QAAQ,IAAI,SAAS,KAAK,MAAM,MAAM;AACtD,YAAI,IAAI,QAAQ,SAAS,WAAW,IAAI,SAAS,IAAI;AACnD;AAAA,QACF;AACA,YAAI,KAAK,SAAS;AAAS;AAAA,MAC7B;AAAA,IACF;AACA,QAAI,MAAM,KAAK,MAAM,OAAO,QAAQ;AAClC,YAAM,OAAO,UAAU,mBAAmB;AAC1C,WAAK,MAAM,OAAO,sBAAsB,MAAM;AAAA,QAC5C;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,uBAAuB,MAAM;AAC3B,SAAK,KAAK;AACV,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,wBAAwB;AACtB,SAAK,OAAO,EAAE;AACd,UAAM,MAAM,KAAK,gBAAgB;AACjC,SAAK,OAAO,EAAE;AACd,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,MAAM;AAC1B,SAAK,KAAK;AACV,SAAK,MAAM,OAAO,KAAK,SAAS;AAChC,SAAK,OAAO,KAAK,mCAAmC,MAAM,KAAK,eAAe,CAAC;AAC/E,SAAK,MAAM,OAAO,IAAI;AACtB,SAAK,OAAO,EAAE;AACd,SAAK,OAAO,KAAK,sBAAsB;AACvC,SAAK,IAAI,EAAE;AACX,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,kBAAkB,MAAM;AACtB,SAAK,KAAK;AACV,SAAK,MAAM,OAAO,KAAK,SAAS;AAChC,QAAI,UAAU;AACd,QAAI,KAAK,eAAe,KAAK,KAAK,cAAc,EAAE,GAAG;AACnD,gBAAU,KAAK,MAAM;AAAA,IACvB;AACA,SAAK,MAAM,MAAM,CAAC;AAClB,SAAK,OAAO,EAAE;AACd,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,YAAY,MAAM;AACpB,aAAK,WAAW,OAAO;AAAA,MACzB;AACA,aAAO,KAAK,SAAS,MAAM,IAAI;AAAA,IACjC;AACA,UAAM,gBAAgB,KAAK,aAAa,GAAG;AAC3C;AACE,YAAM,uBAAuB,KAAK,aAAa,EAAE,KAAK,KAAK,iBAAiB;AAC5E,YAAM,4BAA4B,wBAAwB,KAAK,aAAa,GAAG,KAAK,KAAK,iBAAiB;AAC1G,YAAM,eAAe,iBAAiB,KAAK,wBAAwB,KAAK;AACxE,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,cAAc;AACpD,cAAM,WAAW,KAAK,UAAU;AAChC,YAAI;AACJ,YAAI,sBAAsB;AACxB,iBAAO;AACP,cAAI,CAAC,KAAK,eAAe,GAAG;AAC1B,iBAAK,MAAM,OAAO,6BAA6B,KAAK,MAAM,QAAQ;AAAA,UACpE;AACA,eAAK,KAAK;AAAA,QACZ,OAAO;AACL,iBAAO,KAAK,MAAM;AAAA,QACpB;AACA,aAAK,KAAK;AACV,aAAK,SAAS,UAAU,MAAM,IAAI;AAClC,cAAMgB,QAAO,KAAK,WAAW,UAAU,qBAAqB;AAC5D,cAAM,UAAU,KAAK,MAAM,EAAE;AAC7B,YAAI,WAAW,2BAA2B;AACxC,eAAK,MAAM,OAAO,YAAYA,KAAI;AAAA,QACpC;AACA,aAAK,WAAW,KAAK,aAAa,GAAG,MAAMA,MAAK,aAAa,WAAW,GAAG;AACzE,iBAAO,KAAK,WAAW,MAAMA,OAAM,OAAO;AAAA,QAC5C;AACA,YAAI,YAAY,MAAM;AACpB,eAAK,WAAW,OAAO;AAAA,QACzB;AACA,eAAO,KAAK,SAAS,MAAMA,KAAI;AAAA,MACjC;AAAA,IACF;AACA,UAAM,kBAAkB,KAAK,aAAa,EAAE;AAC5C,UAAM,sBAAsB,IAAI,iBAAiB;AACjD,UAAM,OAAO,KAAK,gBAAgB,MAAM,mBAAmB;AAC3D,UAAM,UAAU,KAAK,aAAa,GAAG;AACrC,QAAI,SAAS;AACX,UAAI,eAAe;AACjB,aAAK,MAAM,OAAO,UAAU,IAAI;AAAA,MAClC;AACA,UAAI,YAAY,QAAQ,mBAAmB,KAAK,SAAS,cAAc;AACrE,aAAK,MAAM,OAAO,YAAY,IAAI;AAAA,MACpC;AAAA,IACF;AACA,QAAI,WAAW,KAAK,MAAM,EAAE,GAAG;AAC7B,WAAK,0BAA0B,mBAAmB;AAClD,WAAK,aAAa,MAAM,IAAI;AAC5B,YAAM,OAAO,UAAU,mBAAmB;AAC1C,WAAK,UAAU,MAAM;AAAA,QACnB,IAAI;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AACD,aAAO,KAAK,WAAW,MAAM,MAAM,OAAO;AAAA,IAC5C,OAAO;AACL,WAAK,sBAAsB,qBAAqB,IAAI;AAAA,IACtD;AACA,QAAI,YAAY,MAAM;AACpB,WAAK,WAAW,OAAO;AAAA,IACzB;AACA,WAAO,KAAK,SAAS,MAAM,IAAI;AAAA,EACjC;AAAA,EACA,uBAAuB,MAAM,SAAS,sBAAsB;AAC1D,SAAK,KAAK;AACV,WAAO,KAAK,cAAc,MAAM,KAAK,uBAAuB,IAAI,MAAM,UAAU,IAAI,EAAE;AAAA,EACxF;AAAA,EACA,iBAAiB,MAAM;AACrB,SAAK,KAAK;AACV,SAAK,OAAO,KAAK,sBAAsB;AACvC,SAAK,aAAa,KAAK,gDAAgD;AACvE,SAAK,YAAY,KAAK,IAAI,EAAE,IAAI,KAAK,gDAAgD,IAAI;AACzF,WAAO,KAAK,WAAW,MAAM,aAAa;AAAA,EAC5C;AAAA,EACA,qBAAqB,MAAM;AACzB,QAAI,CAAC,KAAK,UAAU,aAAa,CAAC,KAAK,QAAQ,4BAA4B;AACzE,WAAK,MAAM,OAAO,eAAe,KAAK,MAAM,QAAQ;AAAA,IACtD;AACA,SAAK,KAAK;AACV,QAAI,KAAK,iBAAiB,GAAG;AAC3B,WAAK,WAAW;AAAA,IAClB,OAAO;AACL,WAAK,WAAW,KAAK,gBAAgB;AACrC,WAAK,UAAU;AAAA,IACjB;AACA,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,qBAAqB,MAAM;AACzB,SAAK,KAAK;AACV,SAAK,eAAe,KAAK,sBAAsB;AAC/C,UAAM,QAAQ,KAAK,QAAQ,CAAC;AAC5B,SAAK,OAAO,CAAC;AACb,SAAK,MAAM,OAAO,KAAK,WAAW;AAClC,SAAK,MAAM,MAAM,CAAC;AAClB,QAAI;AACJ,aAAS,YAAY,CAAC,KAAK,MAAM,CAAC,KAAI;AACpC,UAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,GAAG;AACpC,cAAM,SAAS,KAAK,MAAM,EAAE;AAC5B,YAAI;AAAK,eAAK,WAAW,KAAK,YAAY;AAC1C,cAAM,KAAK,MAAM,KAAK,UAAU,CAAC;AACjC,YAAI,aAAa,CAAC;AAClB,aAAK,KAAK;AACV,YAAI,QAAQ;AACV,cAAI,OAAO,KAAK,gBAAgB;AAAA,QAClC,OAAO;AACL,cAAI,YAAY;AACd,iBAAK,MAAM,OAAO,0BAA0B,KAAK,MAAM,eAAe;AAAA,UACxE;AACA,uBAAa;AACb,cAAI,OAAO;AAAA,QACb;AACA,aAAK,OAAO,EAAE;AAAA,MAChB,OAAO;AACL,YAAI,KAAK;AACP,cAAI,WAAW,KAAK,KAAK,uBAAuB,CAAC;AAAA,QACnD,OAAO;AACL,eAAK,WAAW;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AACA,SAAK,MAAM,KAAK;AAChB,QAAI;AAAK,WAAK,WAAW,KAAK,YAAY;AAC1C,SAAK,KAAK;AACV,SAAK,MAAM,OAAO,IAAI;AACtB,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,oBAAoB,MAAM;AACxB,SAAK,KAAK;AACV,QAAI,KAAK,sBAAsB,GAAG;AAChC,WAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,aAAa;AAAA,IAC/D;AACA,SAAK,WAAW,KAAK,gBAAgB;AACrC,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,wBAAwB;AACtB,UAAM,QAAQ,KAAK,iBAAiB;AACpC,SAAK,MAAM,MAAM,KAAK,QAAQ,UAAU,MAAM,SAAS,eAAe,IAAI,CAAC;AAC3E,SAAK,UAAU,OAAO;AAAA,MACpB,IAAI;AAAA,QACF,MAAM;AAAA,MACR;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,MAAM;AACtB,SAAK,KAAK;AACV,SAAK,QAAQ,KAAK,WAAW;AAC7B,SAAK,UAAU;AACf,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,SAAS,KAAK,UAAU;AAC9B,WAAK,KAAK;AACV,UAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAK,OAAO,EAAE;AACd,eAAO,QAAQ,KAAK,sBAAsB;AAC1C,aAAK,OAAO,EAAE;AAAA,MAChB,OAAO;AACL,eAAO,QAAQ;AACf,aAAK,MAAM,MAAM,CAAC;AAAA,MACpB;AACA,aAAO,OAAO,KAAK,mCAAmC,MAAM,KAAK,WAAW,OAAO,KAAK,CAAC;AACzF,WAAK,MAAM,KAAK;AAChB,WAAK,UAAU,KAAK,WAAW,QAAQ,aAAa;AAAA,IACtD;AACA,SAAK,YAAY,KAAK,IAAI,EAAE,IAAI,KAAK,WAAW,IAAI;AACpD,QAAI,CAAC,KAAK,WAAW,CAAC,KAAK,WAAW;AACpC,WAAK,MAAM,OAAO,kBAAkB,IAAI;AAAA,IAC1C;AACA,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,kBAAkB,MAAM,MAAM,0BAA0B,OAAO;AAC7D,SAAK,KAAK;AACV,SAAK,SAAS,MAAM,OAAO,MAAM,uBAAuB;AACxD,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACpD;AAAA,EACA,oBAAoB,MAAM;AACxB,SAAK,KAAK;AACV,SAAK,OAAO,KAAK,sBAAsB;AACvC,SAAK,MAAM,OAAO,KAAK,SAAS;AAChC,SAAK,OAAO,KAAK,mCAAmC,MAAM,KAAK,eAAe,CAAC;AAC/E,SAAK,MAAM,OAAO,IAAI;AACtB,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,mBAAmB,MAAM;AACvB,QAAI,KAAK,MAAM,QAAQ;AACrB,WAAK,MAAM,OAAO,YAAY,KAAK,MAAM,QAAQ;AAAA,IACnD;AACA,SAAK,KAAK;AACV,SAAK,SAAS,KAAK,sBAAsB;AACzC,SAAK,OAAO,KAAK,mCAAmC,MAAM,KAAK,eAAe,CAAC;AAC/E,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,oBAAoB,MAAM;AACxB,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,sBAAsB,MAAM,WAAW,MAAM,OAAO;AAClD,eAAW,SAAS,KAAK,MAAM,QAAQ;AACrC,UAAI,MAAM,SAAS,WAAW;AAC5B,aAAK,MAAM,OAAO,oBAAoB,MAAM;AAAA,UAC1C,WAAW;AAAA,QACb,CAAC;AAAA,MACH;AAAA,IACF;AACA,UAAM,OAAO,YAAY,KAAK,MAAM,IAAI,IAAI,IAAI,KAAK,MAAM,EAAE,IAAI,IAAI;AACrE,aAAS,IAAI,KAAK,MAAM,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AACtD,YAAM,QAAQ,KAAK,MAAM,OAAO,CAAC;AACjC,UAAI,MAAM,mBAAmB,KAAK,OAAO;AACvC,cAAM,iBAAiB,KAAK,MAAM;AAClC,cAAM,OAAO;AAAA,MACf,OAAO;AACL;AAAA,MACF;AAAA,IACF;AACA,SAAK,MAAM,OAAO,KAAK;AAAA,MACrB,MAAM;AAAA,MACN;AAAA,MACA,gBAAgB,KAAK,MAAM;AAAA,IAC7B,CAAC;AACD,SAAK,OAAO,QAAQ,IAAI,KAAK,gDAAgD,IAAI,IAAI,KAAK,eAAe;AACzG,SAAK,MAAM,OAAO,IAAI;AACtB,SAAK,QAAQ;AACb,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD;AAAA,EACA,yBAAyB,MAAM,MAAM,YAAY;AAC/C,SAAK,aAAa;AAClB,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,EACpD;AAAA,EACA,WAAW,kBAAkB,OAAO,wBAAwB,MAAM,iBAAiB;AACjF,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,iBAAiB;AACnB,WAAK,MAAM,aAAa,MAAM;AAAA,IAChC;AACA,SAAK,OAAO,CAAC;AACb,QAAI,uBAAuB;AACzB,WAAK,MAAM,MAAM,CAAC;AAAA,IACpB;AACA,SAAK,eAAe,MAAM,iBAAiB,OAAO,GAAG,eAAe;AACpE,QAAI,uBAAuB;AACzB,WAAK,MAAM,KAAK;AAAA,IAClB;AACA,WAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,EAC/C;AAAA,EACA,iBAAiB,MAAM;AACrB,WAAO,KAAK,SAAS,yBAAyB,KAAK,WAAW,SAAS,mBAAmB,CAAC,KAAK,WAAW,MAAM;AAAA,EACnH;AAAA,EACA,eAAe,MAAM,iBAAiB,UAAU,KAAK,iBAAiB;AACpE,UAAM,OAAO,KAAK,OAAO,CAAC;AAC1B,UAAM,aAAa,KAAK,aAAa,CAAC;AACtC,SAAK,4BAA4B,MAAM,kBAAkB,aAAa,QAAW,UAAU,KAAK,eAAe;AAAA,EACjH;AAAA,EACA,4BAA4B,MAAM,YAAY,UAAU,KAAK,iBAAiB;AAC5E,UAAM,YAAY,KAAK,MAAM;AAC7B,QAAI,yBAAyB;AAC7B,QAAI,qBAAqB;AACzB,WAAO,CAAC,KAAK,MAAM,GAAG,GAAG;AACvB,YAAM,OAAO,WAAW,KAAK,gBAAgB,IAAI,KAAK,uBAAuB;AAC7E,UAAI,cAAc,CAAC,oBAAoB;AACrC,YAAI,KAAK,iBAAiB,IAAI,GAAG;AAC/B,gBAAM,YAAY,KAAK,gBAAgB,IAAI;AAC3C,qBAAW,KAAK,SAAS;AACzB,cAAI,CAAC,0BAA0B,UAAU,MAAM,UAAU,cAAc;AACrE,qCAAyB;AACzB,iBAAK,UAAU,IAAI;AAAA,UACrB;AACA;AAAA,QACF;AACA,6BAAqB;AACrB,aAAK,MAAM,aAAa,MAAM;AAAA,MAChC;AACA,WAAK,KAAK,IAAI;AAAA,IAChB;AACA,uBAAmB,QAAQ,gBAAgB,KAAK,MAAM,sBAAsB;AAC5E,QAAI,CAAC,WAAW;AACd,WAAK,UAAU,KAAK;AAAA,IACtB;AACA,SAAK,KAAK;AAAA,EACZ;AAAA,EACA,SAAS,MAAM,MAAM;AACnB,SAAK,OAAO;AACZ,SAAK,UAAU,KAAK;AACpB,SAAK,OAAO,KAAK,MAAM,EAAE,IAAI,OAAO,KAAK,gBAAgB;AACzD,SAAK,UAAU,KAAK;AACpB,SAAK,SAAS,KAAK,MAAM,EAAE,IAAI,OAAO,KAAK,gBAAgB;AAC3D,SAAK,OAAO,EAAE;AACd,SAAK,OAAO,KAAK,mCAAmC,MAAM,KAAK,eAAe,CAAC;AAC/E,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,OAAO,IAAI;AACtB,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AAAA,EACA,WAAW,MAAM,MAAM,SAAS;AAC9B,UAAM,UAAU,KAAK,MAAM,EAAE;AAC7B,SAAK,KAAK;AACV,QAAI,SAAS;AACX,UAAI,YAAY;AAAM,aAAK,WAAW,OAAO;AAAA,IAC/C,OAAO;AACL,WAAK,QAAQ,YAAY;AAAA,IAC3B;AACA,QAAI,KAAK,SAAS,yBAAyB,KAAK,aAAa,CAAC,EAAE,QAAQ,SAAS,CAAC,WAAW,CAAC,KAAK,QAAQ,UAAU,KAAK,MAAM,UAAU,KAAK,SAAS,SAAS,KAAK,aAAa,CAAC,EAAE,GAAG,SAAS,eAAe;AAC/M,WAAK,MAAM,OAAO,wBAAwB,MAAM;AAAA,QAC9C,MAAM,UAAU,mBAAmB;AAAA,MACrC,CAAC;AAAA,IACH;AACA,QAAI,KAAK,SAAS,qBAAqB;AACrC,WAAK,MAAM,OAAO,YAAY,MAAM;AAAA,QAClC,UAAU;AAAA,UACR,MAAM;AAAA,QACR;AAAA,MACF,CAAC;AAAA,IACH;AACA,SAAK,OAAO;AACZ,SAAK,QAAQ,UAAU,KAAK,gBAAgB,IAAI,KAAK,wBAAwB;AAC7E,SAAK,OAAO,EAAE;AACd,SAAK,OAAO,KAAK,mCAAmC,MAAM,KAAK,eAAe,CAAC;AAC/E,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,OAAO,IAAI;AACtB,WAAO,KAAK,WAAW,MAAM,UAAU,mBAAmB,gBAAgB;AAAA,EAC5E;AAAA,EACA,SAAS,MAAM,OAAO,MAAM,0BAA0B,OAAO;AAC3D,UAAM,eAAe,KAAK,eAAe,CAAC;AAC1C,SAAK,OAAO;AACZ,eAAS;AACP,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,WAAW,MAAM,IAAI;AAC1B,WAAK,OAAO,CAAC,KAAK,IAAI,EAAE,IAAI,OAAO,QAAQ,KAAK,2BAA2B,IAAI,KAAK,wBAAwB;AAC5G,UAAI,KAAK,SAAS,QAAQ,CAAC,yBAAyB;AAClD,YAAI,KAAK,GAAG,SAAS,gBAAgB,EAAE,UAAU,KAAK,MAAM,EAAE,KAAK,KAAK,aAAa,GAAG,KAAK;AAC3F,eAAK,MAAM,OAAO,+BAA+B,KAAK,MAAM,eAAe;AAAA,YACzE,MAAM;AAAA,UACR,CAAC;AAAA,QACH,WAAW,SAAS,WAAW,EAAE,KAAK,MAAM,EAAE,KAAK,KAAK,aAAa,GAAG,IAAI;AAC1E,eAAK,MAAM,OAAO,+BAA+B,KAAK,MAAM,eAAe;AAAA,YACzE,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAAA,MACF;AACA,mBAAa,KAAK,KAAK,WAAW,MAAM,oBAAoB,CAAC;AAC7D,UAAI,CAAC,KAAK,IAAI,EAAE;AAAG;AAAA,IACrB;AACA,WAAO;AAAA,EACT;AAAA,EACA,WAAW,MAAM,MAAM;AACrB,UAAM,KAAK,KAAK,iBAAiB;AACjC,SAAK,UAAU,IAAI;AAAA,MACjB,IAAI;AAAA,QACF,MAAM;AAAA,MACR;AAAA,MACA,SAAS,SAAS,QAAQ,IAAI;AAAA,IAChC,CAAC;AACD,SAAK,KAAK;AAAA,EACZ;AAAA,EACA,6BAA6B,MAAM;AACjC,WAAO,KAAK,cAAc,MAAM,CAAC;AAAA,EACnC;AAAA,EACA,cAAc,MAAM,QAAQ,GAAG;AAC7B,UAAM,qBAAqB,QAAQ;AACnC,UAAM,gBAAgB,CAAC,EAAE,QAAQ;AACjC,UAAM,YAAY,iBAAiB,EAAE,QAAQ;AAC7C,UAAM,UAAU,CAAC,EAAE,QAAQ;AAC3B,SAAK,aAAa,MAAM,OAAO;AAC/B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,oBAAoB;AACtB,aAAK,MAAM,OAAO,mCAAmC,KAAK,MAAM,QAAQ;AAAA,MAC1E;AACA,WAAK,KAAK;AACV,WAAK,YAAY;AAAA,IACnB;AACA,QAAI,eAAe;AACjB,WAAK,KAAK,KAAK,gBAAgB,SAAS;AAAA,IAC1C;AACA,UAAM,4BAA4B,KAAK,MAAM;AAC7C,SAAK,MAAM,yBAAyB;AACpC,SAAK,MAAM,MAAM,CAAC;AAClB,SAAK,UAAU,MAAM,cAAc,SAAS,KAAK,SAAS,CAAC;AAC3D,QAAI,CAAC,eAAe;AAClB,WAAK,KAAK,KAAK,gBAAgB;AAAA,IACjC;AACA,SAAK,oBAAoB,MAAM,KAAK;AACpC,SAAK,mCAAmC,MAAM;AAC5C,WAAK,2BAA2B,MAAM,gBAAgB,wBAAwB,oBAAoB;AAAA,IACpG,CAAC;AACD,SAAK,UAAU,KAAK;AACpB,SAAK,MAAM,KAAK;AAChB,QAAI,iBAAiB,CAAC,oBAAoB;AACxC,WAAK,4BAA4B,IAAI;AAAA,IACvC;AACA,SAAK,MAAM,yBAAyB;AACpC,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,WAAW;AACzB,WAAO,aAAa,kBAAkB,KAAK,MAAM,IAAI,IAAI,KAAK,gBAAgB,IAAI;AAAA,EACpF;AAAA,EACA,oBAAoB,MAAM,eAAe;AACvC,SAAK,OAAO,EAAE;AACd,SAAK,gBAAgB,MAAM,6BAA6B,CAAC;AACzD,SAAK,SAAS,KAAK,iBAAiB,IAAI,IAAI,KAAK,gBAAgB,IAAI,EAAE;AACvE,SAAK,gBAAgB,KAAK;AAAA,EAC5B;AAAA,EACA,4BAA4B,MAAM;AAChC,QAAI,CAAC,KAAK;AAAI;AACd,SAAK,MAAM,YAAY,KAAK,GAAG,MAAM,CAAC,KAAK,QAAQ,UAAU,KAAK,MAAM,UAAU,KAAK,aAAa,KAAK,QAAQ,KAAK,MAAM,sBAAsB,IAAI,OAAO,IAAI,KAAK,GAAG,IAAI,KAAK;AAAA,EACpL;AAAA,EACA,WAAW,MAAM,aAAa,YAAY;AACxC,SAAK,KAAK;AACV,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS;AACpB,SAAK,aAAa,MAAM,aAAa,UAAU;AAC/C,SAAK,gBAAgB,IAAI;AACzB,SAAK,OAAO,KAAK,eAAe,CAAC,CAAC,KAAK,YAAY,SAAS;AAC5D,WAAO,KAAK,WAAW,MAAM,cAAc,qBAAqB,iBAAiB;AAAA,EACnF;AAAA,EACA,kBAAkB;AAChB,WAAO,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,CAAC;AAAA,EACzD;AAAA,EACA,gBAAgB;AACd,WAAO,KAAK,MAAM,EAAE;AAAA,EACtB;AAAA,EACA,uBAAuB,QAAQ;AAC7B,WAAO,CAAC,OAAO,YAAY,CAAC,OAAO,WAAW,OAAO,IAAI,SAAS,iBAAiB,OAAO,IAAI,UAAU;AAAA,EAC1G;AAAA,EACA,eAAe,eAAe,WAAW;AACvC,SAAK,WAAW,MAAM;AACtB,UAAM,QAAQ;AAAA,MACZ,gBAAgB;AAAA,MAChB;AAAA,IACF;AACA,QAAI,aAAa,CAAC;AAClB,UAAM,YAAY,KAAK,UAAU;AACjC,cAAU,OAAO,CAAC;AAClB,SAAK,OAAO,CAAC;AACb,SAAK,mCAAmC,MAAM;AAC5C,aAAO,CAAC,KAAK,MAAM,CAAC,GAAG;AACrB,YAAI,KAAK,IAAI,EAAE,GAAG;AAChB,cAAI,WAAW,SAAS,GAAG;AACzB,kBAAM,KAAK,MAAM,OAAO,oBAAoB,KAAK,MAAM,aAAa;AAAA,UACtE;AACA;AAAA,QACF;AACA,YAAI,KAAK,MAAM,EAAE,GAAG;AAClB,qBAAW,KAAK,KAAK,eAAe,CAAC;AACrC;AAAA,QACF;AACA,cAAM,SAAS,KAAK,UAAU;AAC9B,YAAI,WAAW,QAAQ;AACrB,iBAAO,aAAa;AACpB,eAAK,2BAA2B,QAAQ,WAAW,CAAC,CAAC;AACrD,uBAAa,CAAC;AAAA,QAChB;AACA,aAAK,iBAAiB,WAAW,QAAQ,KAAK;AAC9C,YAAI,OAAO,SAAS,iBAAiB,OAAO,cAAc,OAAO,WAAW,SAAS,GAAG;AACtF,eAAK,MAAM,OAAO,sBAAsB,MAAM;AAAA,QAChD;AAAA,MACF;AAAA,IACF,CAAC;AACD,SAAK,MAAM,SAAS;AACpB,SAAK,KAAK;AACV,QAAI,WAAW,QAAQ;AACrB,YAAM,KAAK,MAAM,OAAO,mBAAmB,KAAK,MAAM,QAAQ;AAAA,IAChE;AACA,SAAK,WAAW,KAAK;AACrB,WAAO,KAAK,WAAW,WAAW,WAAW;AAAA,EAC/C;AAAA,EACA,6BAA6B,WAAW,QAAQ;AAC9C,UAAM,MAAM,KAAK,gBAAgB,IAAI;AACrC,QAAI,KAAK,cAAc,GAAG;AACxB,YAAM,SAAS;AACf,aAAO,OAAO;AACd,aAAO,WAAW;AAClB,aAAO,MAAM;AACb,aAAO,SAAS;AAChB,WAAK,gBAAgB,WAAW,QAAQ,OAAO,OAAO,OAAO,KAAK;AAClE,aAAO;AAAA,IACT,WAAW,KAAK,gBAAgB,GAAG;AACjC,YAAM,OAAO;AACb,WAAK,WAAW;AAChB,WAAK,MAAM;AACX,WAAK,SAAS;AACd,gBAAU,KAAK,KAAK,KAAK,mBAAmB,IAAI,CAAC;AACjD,aAAO;AAAA,IACT;AACA,SAAK,kCAAkC,GAAG;AAC1C,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB,WAAW,QAAQ,OAAO;AACzC,UAAM,WAAW,KAAK,aAAa,GAAG;AACtC,QAAI,UAAU;AACZ,UAAI,KAAK,6BAA6B,WAAW,MAAM,GAAG;AACxD;AAAA,MACF;AACA,UAAI,KAAK,IAAI,CAAC,GAAG;AACf,aAAK,sBAAsB,WAAW,MAAM;AAC5C;AAAA,MACF;AAAA,IACF;AACA,SAAK,6BAA6B,WAAW,QAAQ,OAAO,QAAQ;AAAA,EACtE;AAAA,EACA,6BAA6B,WAAW,QAAQ,OAAO,UAAU;AAC/D,UAAM,eAAe;AACrB,UAAM,gBAAgB;AACtB,UAAM,aAAa;AACnB,UAAM,cAAc;AACpB,UAAM,eAAe;AACrB,UAAM,SAAS;AACf,UAAM,eAAe;AACrB,WAAO,SAAS;AAChB,SAAK,gCAAgC,MAAM;AAC3C,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,aAAO,OAAO;AACd,YAAM,gBAAgB,KAAK,MAAM,GAAG;AACpC,WAAK,sBAAsB,MAAM;AACjC,UAAI,eAAe;AACjB,aAAK,uBAAuB,WAAW,eAAe,MAAM,KAAK;AACjE;AAAA,MACF;AACA,UAAI,KAAK,uBAAuB,YAAY,GAAG;AAC7C,aAAK,MAAM,OAAO,wBAAwB,aAAa,GAAG;AAAA,MAC5D;AACA,WAAK,gBAAgB,WAAW,cAAc,MAAM,OAAO,OAAO,KAAK;AACvE;AAAA,IACF;AACA,UAAM,eAAe,kBAAkB,KAAK,MAAM,IAAI,KAAK,CAAC,KAAK,MAAM;AACvE,UAAM,YAAY,KAAK,MAAM,GAAG;AAChC,UAAM,MAAM,KAAK,sBAAsB,MAAM;AAC7C,UAAM,6BAA6B,KAAK,MAAM;AAC9C,SAAK,6BAA6B,YAAY;AAC9C,QAAI,KAAK,cAAc,GAAG;AACxB,aAAO,OAAO;AACd,UAAI,WAAW;AACb,aAAK,uBAAuB,WAAW,eAAe,OAAO,KAAK;AAClE;AAAA,MACF;AACA,YAAM,gBAAgB,KAAK,uBAAuB,YAAY;AAC9D,UAAI,oBAAoB;AACxB,UAAI,eAAe;AACjB,qBAAa,OAAO;AACpB,YAAI,MAAM,kBAAkB,CAAC,KAAK,UAAU,YAAY,GAAG;AACzD,eAAK,MAAM,OAAO,sBAAsB,GAAG;AAAA,QAC7C;AACA,YAAI,iBAAiB,KAAK,UAAU,YAAY,KAAK,OAAO,UAAU;AACpE,eAAK,MAAM,OAAO,uBAAuB,GAAG;AAAA,QAC9C;AACA,cAAM,iBAAiB;AACvB,4BAAoB,MAAM;AAAA,MAC5B;AACA,WAAK,gBAAgB,WAAW,cAAc,OAAO,OAAO,eAAe,iBAAiB;AAAA,IAC9F,WAAW,KAAK,gBAAgB,GAAG;AACjC,UAAI,WAAW;AACb,aAAK,yBAAyB,WAAW,WAAW;AAAA,MACtD,OAAO;AACL,aAAK,kBAAkB,WAAW,UAAU;AAAA,MAC9C;AAAA,IACF,WAAW,gBAAgB,IAAI,SAAS,WAAW,CAAC,KAAK,iBAAiB,GAAG;AAC3E,WAAK,kCAAkC,GAAG;AAC1C,YAAM,cAAc,KAAK,IAAI,EAAE;AAC/B,UAAI,aAAa,UAAU;AACzB,aAAK,WAAW,0BAA0B;AAAA,MAC5C;AACA,aAAO,OAAO;AACd,YAAMC,aAAY,KAAK,MAAM,GAAG;AAChC,WAAK,sBAAsB,MAAM;AACjC,WAAK,6BAA6B,YAAY;AAC9C,UAAIA,YAAW;AACb,aAAK,uBAAuB,WAAW,eAAe,aAAa,IAAI;AAAA,MACzE,OAAO;AACL,YAAI,KAAK,uBAAuB,YAAY,GAAG;AAC7C,eAAK,MAAM,OAAO,oBAAoB,aAAa,GAAG;AAAA,QACxD;AACA,aAAK,gBAAgB,WAAW,cAAc,aAAa,MAAM,OAAO,KAAK;AAAA,MAC/E;AAAA,IACF,WAAW,iBAAiB,IAAI,SAAS,SAAS,IAAI,SAAS,UAAU,EAAE,KAAK,MAAM,EAAE,KAAK,KAAK,iBAAiB,IAAI;AACrH,WAAK,kCAAkC,GAAG;AAC1C,aAAO,OAAO,IAAI;AAClB,YAAMA,aAAY,KAAK,MAAM,GAAG;AAChC,WAAK,sBAAsB,YAAY;AACvC,UAAIA,YAAW;AACb,aAAK,uBAAuB,WAAW,eAAe,OAAO,KAAK;AAAA,MACpE,OAAO;AACL,YAAI,KAAK,uBAAuB,YAAY,GAAG;AAC7C,eAAK,MAAM,OAAO,uBAAuB,aAAa,GAAG;AAAA,QAC3D;AACA,aAAK,gBAAgB,WAAW,cAAc,OAAO,OAAO,OAAO,KAAK;AAAA,MAC1E;AACA,WAAK,wBAAwB,YAAY;AAAA,IAC3C,WAAW,gBAAgB,IAAI,SAAS,cAAc,CAAC,KAAK,iBAAiB,GAAG;AAC9E,WAAK,aAAa,wBAAwB;AAC1C,WAAK,kCAAkC,GAAG;AAC1C,YAAMA,aAAY,KAAK,MAAM,GAAG;AAChC,WAAK,sBAAsB,UAAU;AACrC,WAAK,0BAA0B,WAAW,cAAcA,UAAS;AAAA,IACnE,WAAW,KAAK,iBAAiB,GAAG;AAClC,UAAI,WAAW;AACb,aAAK,yBAAyB,WAAW,WAAW;AAAA,MACtD,OAAO;AACL,aAAK,kBAAkB,WAAW,UAAU;AAAA,MAC9C;AAAA,IACF,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,sBAAsB,QAAQ;AAC5B,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AACT,SAAK,SAAS,OAAO,SAAS,QAAQ,OAAO,UAAU,UAAU,aAAa;AAC5E,WAAK,MAAM,OAAO,iBAAiB,KAAK,MAAM,QAAQ;AAAA,IACxD;AACA,QAAI,SAAS,KAAK;AAChB,UAAI,UAAU,eAAe;AAC3B,aAAK,MAAM,OAAO,8BAA8B,KAAK,MAAM,QAAQ;AAAA,MACrE;AACA,YAAM,MAAM,KAAK,iBAAiB;AAClC,aAAO,MAAM;AACb,aAAO;AAAA,IACT;AACA,WAAO,KAAK,kBAAkB,MAAM;AAAA,EACtC;AAAA,EACA,sBAAsB,WAAW,QAAQ;AACvC,QAAI;AACJ,SAAK,MAAM,MAAM,KAAK,MAAM,EAAE;AAC9B,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,SAAS,CAAC;AACrB,SAAK,UAAU,MAAM,CAAC;AACtB,UAAM,OAAO,OAAO,OAAO,CAAC;AAC5B,SAAK,4BAA4B,MAAM,QAAW,OAAO,CAAC;AAC1D,SAAK,UAAU,KAAK;AACpB,SAAK,MAAM,KAAK;AAChB,SAAK,MAAM,SAAS;AACpB,cAAU,KAAK,KAAK,KAAK,WAAW,QAAQ,aAAa,CAAC;AAC1D,SAAK,qBAAqB,OAAO,eAAe,QAAQ,mBAAmB,QAAQ;AACjF,WAAK,MAAM,OAAO,sBAAsB,MAAM;AAAA,IAChD;AAAA,EACF;AAAA,EACA,kBAAkB,WAAW,MAAM;AACjC,QAAI,CAAC,KAAK,aAAa,KAAK,IAAI,SAAS,iBAAiB,KAAK,IAAI,UAAU,gBAAgB;AAC3F,WAAK,MAAM,OAAO,uBAAuB,KAAK,GAAG;AAAA,IACnD;AACA,cAAU,KAAK,KAAK,KAAK,mBAAmB,IAAI,CAAC;AAAA,EACnD;AAAA,EACA,yBAAyB,WAAW,MAAM;AACxC,UAAM,OAAO,KAAK,0BAA0B,IAAI;AAChD,cAAU,KAAK,KAAK,IAAI;AACxB,SAAK,WAAW,mBAAmB,KAAK,iBAAiB,KAAK,GAAG,GAAG,GAAG,KAAK,IAAI,IAAI,KAAK;AAAA,EAC3F;AAAA,EACA,0BAA0B,WAAW,MAAM,WAAW;AACpD,QAAI,CAAC,aAAa,CAAC,KAAK,UAAU;AAChC,YAAM,MAAM,KAAK;AACjB,UAAI,IAAI,SAAS,iBAAiB,IAAI,UAAU,eAAe;AAC7D,aAAK,MAAM,OAAO,uBAAuB,GAAG;AAAA,MAC9C;AAAA,IACF;AACA,UAAM,OAAO,KAAK,2BAA2B,IAAI;AACjD,cAAU,KAAK,KAAK,IAAI;AACxB,QAAI,WAAW;AACb,WAAK,WAAW,mBAAmB,KAAK,iBAAiB,KAAK,GAAG,GAAG,GAAG,KAAK,IAAI,IAAI,KAAK;AAAA,IAC3F;AAAA,EACF;AAAA,EACA,gBAAgB,WAAW,QAAQ,aAAa,SAAS,eAAe,mBAAmB;AACzF,cAAU,KAAK,KAAK,KAAK,YAAY,QAAQ,aAAa,SAAS,eAAe,mBAAmB,eAAe,IAAI,CAAC;AAAA,EAC3H;AAAA,EACA,uBAAuB,WAAW,QAAQ,aAAa,SAAS;AAC9D,UAAM,OAAO,KAAK,YAAY,QAAQ,aAAa,SAAS,OAAO,OAAO,sBAAsB,IAAI;AACpG,cAAU,KAAK,KAAK,IAAI;AACxB,UAAM,OAAO,KAAK,SAAS,QAAQ,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,QAAQ,KAAK,SAAS,IAAI,IAAI;AACrG,SAAK,iCAAiC,MAAM,IAAI;AAAA,EAClD;AAAA,EACA,iCAAiC,MAAM,MAAM;AAC3C,SAAK,WAAW,mBAAmB,KAAK,iBAAiB,KAAK,GAAG,GAAG,MAAM,KAAK,IAAI,IAAI,KAAK;AAAA,EAC9F;AAAA,EACA,6BAA6B,cAAc;AAAA,EAAC;AAAA,EAC5C,0BAA0B,MAAM;AAC9B,SAAK,iBAAiB,IAAI;AAC1B,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,EACrD;AAAA,EACA,mBAAmB,MAAM;AACvB,SAAK,iBAAiB,IAAI;AAC1B,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,2BAA2B,MAAM;AAC/B,SAAK,iBAAiB,IAAI;AAC1B,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,uBAAuB;AAAA,EACtD;AAAA,EACA,iBAAiB,MAAM;AACrB,SAAK,MAAM,MAAM,KAAK,EAAE;AACxB,SAAK,gBAAgB,MAAM,mBAAmB,CAAC;AAC/C,SAAK,UAAU,MAAM,CAAC;AACtB,SAAK,QAAQ,KAAK,IAAI,EAAE,IAAI,KAAK,wBAAwB,IAAI;AAC7D,SAAK,gBAAgB,KAAK;AAC1B,SAAK,UAAU,KAAK;AACpB,SAAK,MAAM,KAAK;AAAA,EAClB;AAAA,EACA,aAAa,MAAM,aAAa,YAAY,cAAc,MAAM;AAC9D,QAAI,kBAAkB,KAAK,MAAM,IAAI,GAAG;AACtC,WAAK,KAAK,KAAK,gBAAgB;AAC/B,UAAI,aAAa;AACf,aAAK,0BAA0B,KAAK,IAAI,WAAW;AAAA,MACrD;AAAA,IACF,OAAO;AACL,UAAI,cAAc,CAAC,aAAa;AAC9B,aAAK,KAAK;AAAA,MACZ,OAAO;AACL,cAAM,KAAK,MAAM,OAAO,kBAAkB,KAAK,MAAM,QAAQ;AAAA,MAC/D;AAAA,IACF;AAAA,EACF;AAAA,EACA,gBAAgB,MAAM;AACpB,SAAK,aAAa,KAAK,IAAI,EAAE,IAAI,KAAK,oBAAoB,IAAI;AAAA,EAChE;AAAA,EACA,YAAY,MAAM,YAAY;AAC5B,UAAM,yBAAyB,KAAK,sBAAsB,MAAM,IAAI;AACpE,UAAM,aAAa,KAAK,iCAAiC,MAAM,sBAAsB;AACrF,UAAM,oBAAoB,CAAC,cAAc,KAAK,IAAI,EAAE;AACpD,UAAM,UAAU,qBAAqB,KAAK,cAAc,IAAI;AAC5D,UAAM,eAAe,WAAW,KAAK,mCAAmC,IAAI;AAC5E,UAAM,sBAAsB,sBAAsB,CAAC,gBAAgB,KAAK,IAAI,EAAE;AAC9E,UAAM,iBAAiB,cAAc;AACrC,QAAI,WAAW,CAAC,cAAc;AAC5B,UAAI;AAAY,aAAK,WAAW;AAChC,UAAI,YAAY;AACd,cAAM,KAAK,MAAM,OAAO,4BAA4B,IAAI;AAAA,MAC1D;AACA,WAAK,gBAAgB,MAAM,IAAI;AAC/B,aAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,IACrD;AACA,UAAM,gBAAgB,KAAK,gCAAgC,IAAI;AAC/D,QAAI,cAAc,qBAAqB,CAAC,WAAW,CAAC,eAAe;AACjE,WAAK,WAAW,MAAM,CAAC;AAAA,IACzB;AACA,QAAI,gBAAgB,qBAAqB;AACvC,WAAK,WAAW,MAAM,EAAE;AAAA,IAC1B;AACA,QAAI;AACJ,QAAI,kBAAkB,eAAe;AACnC,uBAAiB;AACjB,UAAI,YAAY;AACd,cAAM,KAAK,MAAM,OAAO,4BAA4B,IAAI;AAAA,MAC1D;AACA,WAAK,gBAAgB,MAAM,cAAc;AAAA,IAC3C,OAAO;AACL,uBAAiB,KAAK,4BAA4B,IAAI;AAAA,IACxD;AACA,QAAI,kBAAkB,iBAAiB,gBAAgB;AACrD,UAAI;AACJ,YAAM,QAAQ;AACd,WAAK,YAAY,OAAO,MAAM,OAAO,CAAC,CAAC,MAAM,MAAM;AACnD,YAAM,qBAAqB,MAAM,gBAAgB,OAAO,SAAS,mBAAmB,UAAU,oBAAoB;AAChH,aAAK,oBAAoB,YAAY,MAAM,aAAa,KAAK;AAAA,MAC/D,WAAW,YAAY;AACrB,cAAM,KAAK,MAAM,OAAO,4BAA4B,IAAI;AAAA,MAC1D;AACA,aAAO,KAAK,WAAW,OAAO,wBAAwB;AAAA,IACxD;AACA,QAAI,KAAK,IAAI,EAAE,GAAG;AAChB,YAAM,QAAQ;AACd,YAAM,OAAO,KAAK,6BAA6B;AAC/C,YAAM,cAAc;AACpB,UAAI,KAAK,SAAS,oBAAoB;AACpC,aAAK,oBAAoB,YAAY,MAAM,KAAK;AAAA,MAClD,WAAW,YAAY;AACrB,cAAM,KAAK,MAAM,OAAO,4BAA4B,IAAI;AAAA,MAC1D;AACA,WAAK,YAAY,OAAO,MAAM,IAAI;AAClC,aAAO,KAAK,WAAW,OAAO,0BAA0B;AAAA,IAC1D;AACA,SAAK,WAAW,MAAM,CAAC;AAAA,EACzB;AAAA,EACA,cAAc,MAAM;AAClB,WAAO,KAAK,IAAI,EAAE;AAAA,EACpB;AAAA,EACA,iCAAiC,MAAM,wBAAwB;AAC7D,QAAI,0BAA0B,KAAK,yBAAyB,GAAG;AAC7D,WAAK,aAAa,qBAAqB,0BAA0B,OAAO,SAAS,uBAAuB,IAAI,KAAK;AACjH,YAAM,KAAK,0BAA0B,KAAK,gBAAgB,IAAI;AAC9D,YAAM,YAAY,KAAK,gBAAgB,EAAE;AACzC,gBAAU,WAAW;AACrB,WAAK,aAAa,CAAC,KAAK,WAAW,WAAW,wBAAwB,CAAC;AACvE,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,mCAAmC,MAAM;AACvC,QAAI,KAAK,aAAa,EAAE,GAAG;AACzB,UAAI,CAAC,KAAK;AAAY,aAAK,aAAa,CAAC;AACzC,YAAM,YAAY,KAAK,YAAY,KAAK,MAAM,eAAe;AAC7D,WAAK,KAAK;AACV,gBAAU,WAAW,KAAK,sBAAsB;AAChD,WAAK,WAAW,KAAK,KAAK,WAAW,WAAW,0BAA0B,CAAC;AAC3E,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,gCAAgC,MAAM;AACpC,QAAI,KAAK,MAAM,CAAC,GAAG;AACjB,UAAI,CAAC,KAAK;AAAY,aAAK,aAAa,CAAC;AACzC,YAAM,eAAe,KAAK,eAAe;AACzC,WAAK,WAAW,KAAK,GAAG,KAAK,sBAAsB,YAAY,CAAC;AAChE,WAAK,SAAS;AACd,WAAK,cAAc;AACnB,UAAI,KAAK,UAAU,kBAAkB,GAAG;AACtC,aAAK,aAAa,CAAC;AAAA,MACrB;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,4BAA4B,MAAM;AAChC,QAAI,KAAK,6BAA6B,GAAG;AACvC,WAAK,aAAa,CAAC;AACnB,WAAK,SAAS;AACd,UAAI,KAAK,UAAU,kBAAkB,GAAG;AACtC,aAAK,aAAa,CAAC;AAAA,MACrB;AACA,WAAK,cAAc,KAAK,uBAAuB,IAAI;AACnD,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB;AAChB,QAAI,CAAC,KAAK,aAAa,EAAE;AAAG,aAAO;AACnC,UAAM,OAAO,KAAK,qBAAqB;AACvC,WAAO,KAAK,qBAAqB,MAAM,UAAU;AAAA,EACnD;AAAA,EACA,+BAA+B;AAC7B,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,WAAK,KAAK;AACV,aAAO,KAAK,cAAc,MAAM,IAAI,CAAC;AAAA,IACvC,WAAW,KAAK,gBAAgB,GAAG;AACjC,WAAK,KAAK;AACV,WAAK,KAAK;AACV,aAAO,KAAK,cAAc,MAAM,IAAI,IAAI,CAAC;AAAA,IAC3C;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,aAAO,KAAK,WAAW,MAAM,MAAM,IAAI;AAAA,IACzC;AACA,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,KAAK,UAAU,YAAY,KAAK,KAAK,gBAAgB,cAAc,wBAAwB,MAAM,MAAM;AACzG,aAAK,MAAM,OAAO,uBAAuB,KAAK,MAAM,QAAQ;AAAA,MAC9D;AACA,aAAO,KAAK,WAAW,KAAK,oBAAoB,KAAK,gBAAgB,KAAK,GAAG,KAAK,UAAU,CAAC,GAAG,MAAM,IAAI;AAAA,IAC5G;AACA,QAAI,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,KAAK,KAAK,MAAM,GAAG;AACpD,YAAM,KAAK,MAAM,OAAO,0BAA0B,KAAK,MAAM,QAAQ;AAAA,IACvE;AACA,UAAM,MAAM,KAAK,wBAAwB;AACzC,SAAK,UAAU;AACf,WAAO;AAAA,EACT;AAAA,EACA,uBAAuB,MAAM;AAC3B,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAMjB,QAAO,KAAK,WAAW,KAAK,UAAU,GAAG,MAAM,KAAK;AAC1D,aAAOA;AAAA,IACT;AACA,WAAO,KAAK,uBAAuB;AAAA,EACrC;AAAA,EACA,2BAA2B;AACzB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,kBAAkB,IAAI,GAAG;AAC3B,UAAI,SAAS,MAAM,CAAC,KAAK,MAAM,eAAe,SAAS,KAAK;AAC1D,eAAO;AAAA,MACT;AACA,WAAK,SAAS,OAAO,SAAS,QAAQ,CAAC,KAAK,MAAM,aAAa;AAC7D,cAAM;AAAA,UACJ,MAAM;AAAA,QACR,IAAI,KAAK,UAAU;AACnB,YAAI,kBAAkB,QAAQ,KAAK,aAAa,MAAM,aAAa,GAAG;AACpE,eAAK,gBAAgB,CAAC,QAAQ,YAAY,CAAC;AAC3C,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF,WAAW,CAAC,KAAK,MAAM,EAAE,GAAG;AAC1B,aAAO;AAAA,IACT;AACA,UAAM,OAAO,KAAK,eAAe;AACjC,UAAM,UAAU,KAAK,qBAAqB,MAAM,MAAM;AACtD,QAAI,KAAK,MAAM,WAAW,IAAI,MAAM,MAAM,kBAAkB,KAAK,MAAM,IAAI,KAAK,SAAS;AACvF,aAAO;AAAA,IACT;AACA,QAAI,KAAK,MAAM,EAAE,KAAK,SAAS;AAC7B,YAAM,gBAAgB,KAAK,MAAM,WAAW,KAAK,oBAAoB,OAAO,CAAC,CAAC;AAC9E,aAAO,kBAAkB,MAAM,kBAAkB;AAAA,IACnD;AACA,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,MAAM,QAAQ;AAC5B,QAAI,KAAK,cAAc,EAAE,GAAG;AAC1B,WAAK,SAAS,KAAK,kBAAkB;AACrC,WAAK,YAAY,IAAI;AACrB,WAAK,2BAA2B,IAAI;AACpC,WAAK,sBAAsB,IAAI;AAAA,IACjC,WAAW,QAAQ;AACjB,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,UAAU;AAAA,EACjB;AAAA,EACA,+BAA+B;AAC7B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAAS,IAAI;AACf,WAAK,gBAAgB,CAAC,cAAc,mBAAmB,CAAC;AACxD,UAAI,KAAK,UAAU,YAAY,GAAG;AAChC,YAAI,KAAK,gBAAgB,cAAc,wBAAwB,MAAM,MAAM;AACzE,eAAK,MAAM,OAAO,uBAAuB,KAAK,MAAM,QAAQ;AAAA,QAC9D;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO,SAAS,MAAM,SAAS,MAAM,SAAS,MAAM,SAAS,MAAM,KAAK,MAAM,KAAK,KAAK,gBAAgB;AAAA,EAC1G;AAAA,EACA,YAAY,MAAM,YAAY,WAAW,QAAQ;AAC/C,QAAI,YAAY;AACd,UAAI;AACJ,UAAI,WAAW;AACb,aAAK,sBAAsB,MAAM,SAAS;AAC1C,YAAI,KAAK,UAAU,mBAAmB,GAAG;AACvC,cAAI;AACJ,gBAAM,cAAc,KAAK;AACzB,cAAI,YAAY,SAAS,gBAAgB,YAAY,SAAS,UAAU,YAAY,MAAM,YAAY,UAAU,KAAK,GAAG,qBAAqB,YAAY,UAAU,QAAQ,mBAAmB,gBAAgB;AAC5M,iBAAK,MAAM,OAAO,+BAA+B,WAAW;AAAA,UAC9D;AAAA,QACF;AAAA,MACF,YAAY,mBAAmB,KAAK,eAAe,QAAQ,iBAAiB,QAAQ;AAClF,mBAAW,aAAa,KAAK,YAAY;AACvC,gBAAM;AAAA,YACJ;AAAA,UACF,IAAI;AACJ,gBAAM,aAAa,SAAS,SAAS,eAAe,SAAS,OAAO,SAAS;AAC7E,eAAK,sBAAsB,WAAW,UAAU;AAChD,cAAI,CAAC,UAAU,UAAU,OAAO;AAC9B,kBAAM;AAAA,cACJ;AAAA,YACF,IAAI;AACJ,gBAAI,MAAM,SAAS,cAAc;AAC/B,mBAAK,MAAM,OAAO,uBAAuB,WAAW;AAAA,gBAClD,WAAW,MAAM;AAAA,gBACjB;AAAA,cACF,CAAC;AAAA,YACH,OAAO;AACL,mBAAK,kBAAkB,MAAM,MAAM,MAAM,IAAI,OAAO,MAAM,KAAK;AAC/D,mBAAK,MAAM,iBAAiB,KAAK;AAAA,YACnC;AAAA,UACF;AAAA,QACF;AAAA,MACF,WAAW,KAAK,aAAa;AAC3B,YAAI,KAAK,YAAY,SAAS,yBAAyB,KAAK,YAAY,SAAS,oBAAoB;AACnG,gBAAM,KAAK,KAAK,YAAY;AAC5B,cAAI,CAAC;AAAI,kBAAM,IAAI,MAAM,mBAAmB;AAC5C,eAAK,sBAAsB,MAAM,GAAG,IAAI;AAAA,QAC1C,WAAW,KAAK,YAAY,SAAS,uBAAuB;AAC1D,qBAAW,eAAe,KAAK,YAAY,cAAc;AACvD,iBAAK,iBAAiB,YAAY,EAAE;AAAA,UACtC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,iBAAiB,MAAM;AACrB,QAAI,KAAK,SAAS,cAAc;AAC9B,WAAK,sBAAsB,MAAM,KAAK,IAAI;AAAA,IAC5C,WAAW,KAAK,SAAS,iBAAiB;AACxC,iBAAW,QAAQ,KAAK,YAAY;AAClC,aAAK,iBAAiB,IAAI;AAAA,MAC5B;AAAA,IACF,WAAW,KAAK,SAAS,gBAAgB;AACvC,iBAAW,QAAQ,KAAK,UAAU;AAChC,YAAI,MAAM;AACR,eAAK,iBAAiB,IAAI;AAAA,QAC5B;AAAA,MACF;AAAA,IACF,WAAW,KAAK,SAAS,kBAAkB;AACzC,WAAK,iBAAiB,KAAK,KAAK;AAAA,IAClC,WAAW,KAAK,SAAS,eAAe;AACtC,WAAK,iBAAiB,KAAK,QAAQ;AAAA,IACrC,WAAW,KAAK,SAAS,qBAAqB;AAC5C,WAAK,iBAAiB,KAAK,IAAI;AAAA,IACjC;AAAA,EACF;AAAA,EACA,sBAAsB,MAAM,YAAY;AACtC,QAAI,KAAK,oBAAoB,IAAI,UAAU,GAAG;AAC5C,UAAI,eAAe,WAAW;AAC5B,aAAK,MAAM,OAAO,wBAAwB,IAAI;AAAA,MAChD,OAAO;AACL,aAAK,MAAM,OAAO,iBAAiB,MAAM;AAAA,UACvC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,SAAK,oBAAoB,IAAI,UAAU;AAAA,EACzC;AAAA,EACA,sBAAsB,gBAAgB;AACpC,UAAM,QAAQ,CAAC;AACf,QAAI,QAAQ;AACZ,SAAK,OAAO,CAAC;AACb,WAAO,CAAC,KAAK,IAAI,CAAC,GAAG;AACnB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,aAAK,OAAO,EAAE;AACd,YAAI,KAAK,IAAI,CAAC;AAAG;AAAA,MACnB;AACA,YAAM,kBAAkB,KAAK,aAAa,GAAG;AAC7C,YAAM,WAAW,KAAK,MAAM,GAAG;AAC/B,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,QAAQ,KAAK,sBAAsB;AACxC,YAAM,KAAK,KAAK,qBAAqB,MAAM,UAAU,gBAAgB,eAAe,CAAC;AAAA,IACvF;AACA,WAAO;AAAA,EACT;AAAA,EACA,qBAAqB,MAAM,UAAU,gBAAgB,iBAAiB;AACpE,QAAI,KAAK,cAAc,EAAE,GAAG;AAC1B,WAAK,WAAW,KAAK,sBAAsB;AAAA,IAC7C,WAAW,UAAU;AACnB,WAAK,WAAW,mBAAmB,KAAK,KAAK;AAAA,IAC/C,WAAW,CAAC,KAAK,UAAU;AACzB,WAAK,WAAW,gBAAgB,KAAK,KAAK;AAAA,IAC5C;AACA,WAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,EAChD;AAAA,EACA,wBAAwB;AACtB,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,YAAM,SAAS,KAAK,mBAAmB,KAAK,MAAM,KAAK;AACvD,YAAM,YAAY,OAAO,MAAM,MAAM,aAAa;AAClD,UAAI,WAAW;AACb,aAAK,MAAM,OAAO,kCAAkC,QAAQ;AAAA,UAC1D,mBAAmB,UAAU,CAAC,EAAE,WAAW,CAAC;AAAA,QAC9C,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AACA,WAAO,KAAK,gBAAgB,IAAI;AAAA,EAClC;AAAA,EACA,mBAAmB,MAAM;AACvB,QAAI,KAAK,cAAc,MAAM;AAC3B,aAAO,KAAK,WAAW,KAAK,CAAC;AAAA,QAC3B;AAAA,QACA;AAAA,MACF,MAAM;AACJ,eAAO,MAAM,UAAU,WAAW,IAAI,SAAS,eAAe,IAAI,SAAS,SAAS,IAAI,UAAU;AAAA,MACpG,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EACA,sBAAsB,MAAM;AAC1B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,UAAM,oBAAoB,WAAW,WAAW,IAAI,WAAW,CAAC,EAAE,OAAO;AACzE,QAAI,KAAK,UAAU,UAAU;AAC3B,UAAI,sBAAsB,0BAA0B;AAClD,aAAK,MAAM,OAAO,kCAAkC,WAAW,CAAC,EAAE,IAAI,KAAK;AAAA,MAC7E;AAAA,IACF,WAAW,KAAK,UAAU,SAAS;AACjC,UAAI,sBAAsB,4BAA4B;AACpD,aAAK,MAAM,OAAO,8BAA8B,WAAW,CAAC,EAAE,IAAI,KAAK;AAAA,MACzE;AAAA,IACF,WAAW,KAAK,QAAQ;AACtB,UAAI;AACJ,UAAI,sBAAsB,0BAA0B;AAClD,aAAK,MAAM,OAAO,4BAA4B,WAAW,CAAC,EAAE,IAAI,KAAK;AAAA,MACvE;AACA,YAAM,mBAAmB,KAAK,eAAe,OAAO,SAAS,iBAAiB,UAAU,GAAG;AACzF,aAAK,MAAM,OAAO,8BAA8B,WAAW,CAAC,EAAE,IAAI,KAAK;AAAA,MACzE;AAAA,IACF;AAAA,EACF;AAAA,EACA,sBAAsB,MAAM;AAC1B,QAAI,KAAK,mBAAmB,IAAI,KAAK,KAAK,SAAS,wBAAwB;AACzE,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,UAAI,cAAc,MAAM;AACtB,cAAM,2BAA2B,WAAW,KAAK,eAAa;AAC5D,cAAI;AACJ,cAAI,UAAU,SAAS,mBAAmB;AACxC,uBAAW,UAAU;AAAA,UACvB,WAAW,UAAU,SAAS,mBAAmB;AAC/C,uBAAW,UAAU;AAAA,UACvB;AACA,cAAI,aAAa,QAAW;AAC1B,mBAAO,SAAS,SAAS,eAAe,SAAS,SAAS,YAAY,SAAS,UAAU;AAAA,UAC3F;AAAA,QACF,CAAC;AACD,YAAI,6BAA6B,QAAW;AAC1C,eAAK,MAAM,OAAO,6BAA6B,yBAAyB,IAAI,KAAK;AAAA,QACnF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,uBAAuB,UAAU;AAC/B,QAAI;AAAU,aAAO;AACrB,WAAO,KAAK,aAAa,GAAG,KAAK,KAAK,aAAa,EAAE,KAAK,KAAK,aAAa,GAAG;AAAA,EACjF;AAAA,EACA,iBAAiB,MAAM,UAAU,OAAO,KAAK;AAC3C,QAAI,UAAU;AACZ;AAAA,IACF;AACA,QAAI,UAAU,UAAU;AACtB,WAAK,aAAa,oBAAoB,GAAG;AACzC,WAAK,SAAS;AAAA,IAChB,WAAW,KAAK,UAAU,kBAAkB,GAAG;AAC7C,WAAK,SAAS;AAAA,IAChB;AACA,QAAI,UAAU,UAAU;AACtB,WAAK,aAAa,sBAAsB,GAAG;AAC3C,WAAK,QAAQ;AAAA,IACf,WAAW,UAAU,SAAS;AAC5B,WAAK,aAAa,4BAA4B,GAAG;AACjD,WAAK,QAAQ;AAAA,IACf,WAAW,KAAK,UAAU,oBAAoB,GAAG;AAC/C,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA,EACA,sBAAsB,MAAM,UAAU;AACpC,QAAI,CAAC,KAAK,uBAAuB,QAAQ,GAAG;AAC1C,WAAK,iBAAiB,MAAM,UAAU,IAAI;AAC1C,aAAO;AAAA,IACT;AACA,UAAM,kBAAkB,KAAK,gBAAgB,IAAI;AACjD,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,UAAM,gBAAgB,2BAA2B,IAAI,IAAI,SAAS,MAAM,KAAK,kBAAkB,MAAM,MAAM,SAAS;AACpH,QAAI,eAAe;AACjB,WAAK,uCAAuC,eAAe;AAC3D,WAAK,iBAAiB,MAAM,UAAU,gBAAgB,MAAM,gBAAgB,IAAI,KAAK;AACrF,aAAO;AAAA,IACT,OAAO;AACL,WAAK,iBAAiB,MAAM,UAAU,IAAI;AAC1C,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,yBAAyB,OAAO;AAC9B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,KAAK;AACT,WAAO,kBAAkB,IAAI,IAAI,SAAS,MAAM,KAAK,kBAAkB,MAAM,MAAM,SAAS;AAAA,EAC9F;AAAA,EACA,YAAY,MAAM;AAChB,QAAI,KAAK,MAAM,GAAG,GAAG;AACnB,aAAO,KAAK,+BAA+B,IAAI;AAAA,IACjD;AACA,WAAO,KAAK,8BAA8B,MAAM,KAAK,sBAAsB,MAAM,KAAK,CAAC;AAAA,EACzF;AAAA,EACA,8BAA8B,MAAM,wBAAwB;AAC1D,SAAK,aAAa,CAAC;AACnB,UAAM,aAAa,KAAK,iCAAiC,MAAM,sBAAsB;AACrF,UAAM,YAAY,CAAC,cAAc,KAAK,IAAI,EAAE;AAC5C,UAAM,UAAU,aAAa,KAAK,8BAA8B,IAAI;AACpE,QAAI,aAAa,CAAC;AAAS,WAAK,2BAA2B,IAAI;AAC/D,SAAK,iBAAiB,EAAE;AACxB,WAAO,KAAK,+BAA+B,IAAI;AAAA,EACjD;AAAA,EACA,+BAA+B,MAAM;AACnC,QAAI;AACJ,KAAC,oBAAoB,KAAK,eAAe,OAAO,oBAAoB,KAAK,aAAa,CAAC;AACvF,SAAK,SAAS,KAAK,kBAAkB;AACrC,SAAK,2BAA2B,IAAI;AACpC,SAAK,sBAAsB,IAAI;AAC/B,SAAK,sBAAsB,IAAI;AAC/B,SAAK,UAAU;AACf,WAAO,KAAK,WAAW,MAAM,mBAAmB;AAAA,EAClD;AAAA,EACA,oBAAoB;AAClB,QAAI,CAAC,KAAK,MAAM,GAAG;AAAG,WAAK,WAAW;AACtC,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EACA,0BAA0B,MAAM,WAAW,MAAM;AAC/C,cAAU,QAAQ,KAAK,gBAAgB;AACvC,SAAK,WAAW,KAAK,KAAK,sBAAsB,WAAW,IAAI,CAAC;AAAA,EAClE;AAAA,EACA,sBAAsB,WAAW,MAAM,cAAc,MAAM;AACzD,SAAK,UAAU,UAAU,OAAO;AAAA,MAC9B,IAAI;AAAA,QACF;AAAA,MACF;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AACD,WAAO,KAAK,WAAW,WAAW,IAAI;AAAA,EACxC;AAAA,EACA,wBAAwB;AACtB,SAAK,OAAO,CAAC;AACb,UAAM,QAAQ,CAAC;AACf,UAAM,YAAY,oBAAI,IAAI;AAC1B,OAAG;AACD,UAAI,KAAK,MAAM,CAAC,GAAG;AACjB;AAAA,MACF;AACA,YAAM,OAAO,KAAK,UAAU;AAC5B,YAAM,UAAU,KAAK,MAAM;AAC3B,UAAI,UAAU,IAAI,OAAO,GAAG;AAC1B,aAAK,MAAM,OAAO,mCAAmC,KAAK,MAAM,UAAU;AAAA,UACxE,KAAK;AAAA,QACP,CAAC;AAAA,MACH;AACA,gBAAU,IAAI,OAAO;AACrB,UAAI,KAAK,MAAM,GAAG,GAAG;AACnB,aAAK,MAAM,KAAK,mBAAmB,OAAO;AAAA,MAC5C,OAAO;AACL,aAAK,MAAM,KAAK,gBAAgB,IAAI;AAAA,MACtC;AACA,WAAK,OAAO,EAAE;AACd,UAAI,CAAC,KAAK,MAAM,GAAG,GAAG;AACpB,cAAM,KAAK,MAAM,OAAO,6BAA6B,KAAK,MAAM,QAAQ;AAAA,MAC1E;AACA,WAAK,QAAQ,KAAK,mBAAmB,KAAK,MAAM,KAAK;AACrD,YAAM,KAAK,KAAK,WAAW,MAAM,iBAAiB,CAAC;AAAA,IACrD,SAAS,KAAK,IAAI,EAAE;AACpB,SAAK,OAAO,CAAC;AACb,WAAO;AAAA,EACT;AAAA,EACA,wBAAwB;AACtB,UAAM,QAAQ,CAAC;AACf,UAAM,aAAa,oBAAI,IAAI;AAC3B,OAAG;AACD,YAAM,OAAO,KAAK,UAAU;AAC5B,WAAK,MAAM,KAAK,gBAAgB,IAAI;AACpC,UAAI,KAAK,IAAI,SAAS,QAAQ;AAC5B,aAAK,MAAM,OAAO,kCAAkC,KAAK,GAAG;AAAA,MAC9D;AACA,UAAI,WAAW,IAAI,KAAK,IAAI,IAAI,GAAG;AACjC,aAAK,MAAM,OAAO,mCAAmC,KAAK,KAAK;AAAA,UAC7D,KAAK,KAAK,IAAI;AAAA,QAChB,CAAC;AAAA,MACH;AACA,iBAAW,IAAI,KAAK,IAAI,IAAI;AAC5B,WAAK,OAAO,EAAE;AACd,UAAI,CAAC,KAAK,MAAM,GAAG,GAAG;AACpB,cAAM,KAAK,MAAM,OAAO,6BAA6B,KAAK,MAAM,QAAQ;AAAA,MAC1E;AACA,WAAK,QAAQ,KAAK,mBAAmB,KAAK,MAAM,KAAK;AACrD,YAAM,KAAK,KAAK,WAAW,MAAM,iBAAiB,CAAC;AAAA,IACrD,SAAS,KAAK,IAAI,EAAE;AACpB,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B,MAAM;AAC/B,QAAI;AACJ,QAAI,UAAU;AACd,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,UAAI,KAAK,sBAAsB,KAAK,KAAK,kBAAkB,MAAM,IAAI;AACnE;AAAA,MACF;AACA,WAAK,KAAK;AACV;AACE,YAAI,KAAK,UAAU,kBAAkB,GAAG;AACtC,uBAAa,KAAK,sBAAsB;AAAA,QAC1C,OAAO;AACL,eAAK,6BAA6B;AAClC,uBAAa,KAAK,sBAAsB;AAAA,QAC1C;AAAA,MACF;AACA,gBAAU;AAAA,IACZ,WAAW,KAAK,aAAa,EAAE,KAAK,CAAC,KAAK,sBAAsB,GAAG;AACjE,UAAI,KAAK,UAAU,kBAAkB,GAAG;AACtC,YAAI,KAAK,gBAAgB,oBAAoB,wBAAwB,MAAM,MAAM;AAC/E,eAAK,MAAM,OAAO,2BAA2B,KAAK,MAAM,QAAQ;AAAA,QAClE;AACA,aAAK,SAAS,MAAM,0BAA0B,IAAI;AAAA,MACpD,OAAO;AACL,aAAK,gBAAgB,CAAC,oBAAoB,kBAAkB,CAAC;AAAA,MAC/D;AACA,WAAK,KAAK;AACV,mBAAa,KAAK,sBAAsB;AAAA,IAC1C,WAAW,KAAK,UAAU,kBAAkB,KAAK,KAAK,UAAU,kBAAkB,GAAG;AACnF,mBAAa,CAAC;AAAA,IAChB,OAAO;AACL,UAAI,KAAK,UAAU,kBAAkB,GAAG;AACtC,qBAAa,CAAC;AAAA,MAChB;AAAO;AAAA,IACT;AACA,QAAI,CAAC,WAAW,KAAK,UAAU,kBAAkB,GAAG;AAClD,WAAK,aAAa;AAAA,IACpB,OAAO;AACL,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AAAA,EACA,iCAAiC,MAAM,wBAAwB;AAC7D,QAAI,wBAAwB;AAC1B,YAAM,YAAY,KAAK,gBAAgB,sBAAsB;AAC7D,gBAAU,QAAQ;AAClB,WAAK,WAAW,KAAK,KAAK,sBAAsB,WAAW,wBAAwB,CAAC;AACpF,aAAO;AAAA,IACT,WAAW,2BAA2B,KAAK,MAAM,IAAI,GAAG;AACtD,WAAK,0BAA0B,MAAM,KAAK,UAAU,GAAG,wBAAwB;AAC/E,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,8BAA8B,MAAM;AAClC,QAAI,KAAK,MAAM,EAAE,GAAG;AAClB,YAAM,YAAY,KAAK,UAAU;AACjC,WAAK,KAAK;AACV,WAAK,iBAAiB,EAAE;AACxB,WAAK,0BAA0B,MAAM,WAAW,0BAA0B;AAC1E,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,2BAA2B,MAAM;AAC/B,QAAI,QAAQ;AACZ,SAAK,OAAO,CAAC;AACb,WAAO,CAAC,KAAK,IAAI,CAAC,GAAG;AACnB,UAAI,OAAO;AACT,gBAAQ;AAAA,MACV,OAAO;AACL,YAAI,KAAK,IAAI,EAAE,GAAG;AAChB,gBAAM,KAAK,MAAM,OAAO,wBAAwB,KAAK,MAAM,QAAQ;AAAA,QACrE;AACA,aAAK,OAAO,EAAE;AACd,YAAI,KAAK,IAAI,CAAC;AAAG;AAAA,MACnB;AACA,YAAM,YAAY,KAAK,UAAU;AACjC,YAAM,mBAAmB,KAAK,MAAM,GAAG;AACvC,YAAM,kBAAkB,KAAK,aAAa,GAAG;AAC7C,gBAAU,WAAW,KAAK,sBAAsB;AAChD,YAAM,kBAAkB,KAAK,qBAAqB,WAAW,kBAAkB,KAAK,eAAe,UAAU,KAAK,eAAe,UAAU,iBAAiB,MAAS;AACrK,WAAK,WAAW,KAAK,eAAe;AAAA,IACtC;AAAA,EACF;AAAA,EACA,qBAAqB,WAAW,kBAAkB,oBAAoB,iBAAiB,aAAa;AAClG,QAAI,KAAK,cAAc,EAAE,GAAG;AAC1B,gBAAU,QAAQ,KAAK,gBAAgB;AAAA,IACzC,OAAO;AACL,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,UAAI,kBAAkB;AACpB,cAAM,KAAK,MAAM,OAAO,uBAAuB,WAAW;AAAA,UACxD,YAAY,SAAS;AAAA,QACvB,CAAC;AAAA,MACH;AACA,WAAK,kBAAkB,SAAS,MAAM,UAAU,IAAI,OAAO,MAAM,IAAI;AACrE,UAAI,CAAC,UAAU,OAAO;AACpB,kBAAU,QAAQ,gBAAgB,QAAQ;AAAA,MAC5C;AAAA,IACF;AACA,WAAO,KAAK,sBAAsB,WAAW,mBAAmB,WAAW;AAAA,EAC7E;AAAA,EACA,YAAY,OAAO;AACjB,WAAO,MAAM,SAAS,gBAAgB,MAAM,SAAS;AAAA,EACvD;AACF;AACA,MAAM,eAAe,gBAAgB;AAAA,EACnC,YAAY,SAAS,OAAO;AAC1B,cAAU,WAAW,OAAO;AAC5B,UAAM,SAAS,KAAK;AACpB,SAAK,UAAU;AACf,SAAK,iBAAiB;AACtB,SAAK,UAAU,WAAW,KAAK,QAAQ,OAAO;AAC9C,SAAK,WAAW,QAAQ;AAAA,EAC1B;AAAA,EACA,kBAAkB;AAChB,WAAO;AAAA,EACT;AAAA,EACA,QAAQ;AACN,SAAK,mBAAmB;AACxB,UAAM,OAAO,KAAK,UAAU;AAC5B,UAAM,UAAU,KAAK,UAAU;AAC/B,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,cAAc,MAAM,OAAO;AAChC,SAAK,SAAS,KAAK,MAAM;AACzB,SAAK,SAAS,SAAS,KAAK,MAAM;AAClC,WAAO;AAAA,EACT;AACF;AACA,SAAS,WAAW,SAAS;AAC3B,QAAM,YAAY,oBAAI,IAAI;AAC1B,aAAW,UAAU,SAAS;AAC5B,UAAM,CAAC,MAAM,OAAO,IAAI,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,QAAQ,CAAC,CAAC;AACpE,QAAI,CAAC,UAAU,IAAI,IAAI;AAAG,gBAAU,IAAI,MAAM,WAAW,CAAC,CAAC;AAAA,EAC7D;AACA,SAAO;AACT;AACA,SAAS,MAAM,OAAO,SAAS;AAC7B,MAAI;AACJ,QAAM,WAAW,YAAY,OAAO,SAAS,SAAS,gBAAgB,eAAe;AACnF,cAAU,OAAO,OAAO,CAAC,GAAG,OAAO;AACnC,QAAI;AACF,cAAQ,aAAa;AACrB,YAAM,SAAS,UAAU,SAAS,KAAK;AACvC,YAAM,MAAM,OAAO,MAAM;AACzB,UAAI,OAAO,mBAAmB;AAC5B,eAAO;AAAA,MACT;AACA,UAAI,OAAO,6BAA6B;AACtC,YAAI;AACF,kBAAQ,aAAa;AACrB,iBAAO,UAAU,SAAS,KAAK,EAAE,MAAM;AAAA,QACzC,SAAS,SAAS;AAAA,QAAC;AAAA,MACrB,OAAO;AACL,YAAI,QAAQ,aAAa;AAAA,MAC3B;AACA,aAAO;AAAA,IACT,SAAS,aAAa;AACpB,UAAI;AACF,gBAAQ,aAAa;AACrB,eAAO,UAAU,SAAS,KAAK,EAAE,MAAM;AAAA,MACzC,SAAS,UAAU;AAAA,MAAC;AACpB,YAAM;AAAA,IACR;AAAA,EACF,OAAO;AACL,WAAO,UAAU,SAAS,KAAK,EAAE,MAAM;AAAA,EACzC;AACF;AACA,SAAS,gBAAgB,OAAO,SAAS;AACvC,QAAM,SAAS,UAAU,SAAS,KAAK;AACvC,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,MAAM,SAAS;AAAA,EACxB;AACA,SAAO,OAAO,cAAc;AAC9B;AACA,SAAS,2BAA2B,oBAAoB;AACtD,QAAMkB,cAAa,CAAC;AACpB,aAAW,YAAY,OAAO,KAAK,kBAAkB,GAAG;AACtD,IAAAA,YAAW,QAAQ,IAAI,iBAAiB,mBAAmB,QAAQ,CAAC;AAAA,EACtE;AACA,SAAOA;AACT;AACA,MAAM,WAAW,2BAA2B,EAAE;AAC9C,SAAS,UAAU,SAAS,OAAO;AACjC,MAAI,MAAM;AACV,MAAI,WAAW,QAAQ,QAAQ,SAAS;AACtC,oBAAgB,QAAQ,OAAO;AAC/B,UAAM,eAAe,QAAQ,OAAO;AAAA,EACtC;AACA,SAAO,IAAI,IAAI,SAAS,KAAK;AAC/B;AACA,MAAM,mBAAmB,CAAC;AAC1B,SAAS,eAAe,oBAAoB;AAC1C,QAAM,aAAa,iBAAiB,OAAO,UAAQ,UAAU,oBAAoB,IAAI,CAAC;AACtF,QAAM,MAAM,WAAW,KAAK,GAAG;AAC/B,MAAI,MAAM,iBAAiB,GAAG;AAC9B,MAAI,CAAC,KAAK;AACR,UAAM;AACN,eAAW,UAAU,YAAY;AAC/B,YAAM,aAAa,MAAM,EAAE,GAAG;AAAA,IAChC;AACA,qBAAiB,GAAG,IAAI;AAAA,EAC1B;AACA,SAAO;AACT;AACA,QAAQ,QAAQ;AAChB,QAAQ,kBAAkB;AAC1B,QAAQ,WAAW;\",\n  \"names\": [\"prefix\", \"code\", \"ch\", \"node\", \"ScopeHandler\", \"bodyNode\", \"parse\", \"jsx\", \"arrowExpression\", \"startLoc\", \"types\", \"result\", \"estree\", \"plugin\", \"left\", \"expr\", \"startsExpr\", \"type\", \"tokenIsKeyword\", \"init\", \"isPrivate\", \"tokenTypes\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1727610131413,
      "end": 1727610131413,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1727610131413,
      "end": 1727610131413,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1727610131413,
      "end": 1727610131413,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1727610131413,
      "end": 1727610131413,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "result": "import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as lib } from \"\\u0000/Users/mamthenebo/Me/Help/fuz/roadmap-starter/node_modules/.pnpm/@babel+parser@7.23.9/node_modules/@babel/parser/lib/index.js?commonjs-exports\";\n\n\"use strict\";\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = ({\n  type,\n  prefix: prefix2\n}) => type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  DynamicImportPhaseRequiresImportExpressions: ({\n    phase\n  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({\n    maxArgumentCount\n  }) => `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nconst UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`,\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n};\nconst _excluded = [\"toMessage\"], _excluded2 = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor(_ref) {\n  let {\n    toMessage\n  } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    Object.assign(error, properties, {\n      loc,\n      pos: loc.index\n    });\n    if (\"missingPlugin\" in details) {\n      Object.assign(error, {\n        missingPlugin: details.missingPlugin\n      });\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref2 = typeof template === \"string\" ? {\n      message: () => template\n    } : typeof template === \"function\" ? {\n      message: template\n    } : template, {\n      message\n    } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = (superClass) => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {\n    }\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = \"Literal\";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = \"ExpressionStatement\";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n    classBody.body.push(method);\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    return this.finishNode(node, \"MethodDefinition\");\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$, _node$arguments$2;\n        node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n        node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;\n      }\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = /* @__PURE__ */ new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 132;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 132;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 136;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = (context) => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = (context) => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[142].updateContext = (context) => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = \"------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\";\nlet nonASCIIidentifierChars = \"-----------------------------------------------------------------------------------------------------------------------------------------------------\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code2, set) {\n  let pos = 65536;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code2)\n      return false;\n    pos += set[i + 1];\n    if (pos >= code2)\n      return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code2) {\n  if (code2 < 65)\n    return code2 === 36;\n  if (code2 <= 90)\n    return true;\n  if (code2 < 97)\n    return code2 === 95;\n  if (code2 <= 122)\n    return true;\n  if (code2 <= 65535) {\n    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));\n  }\n  return isInAstralSet(code2, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code2) {\n  if (code2 < 48)\n    return code2 === 36;\n  if (code2 < 58)\n    return true;\n  if (code2 < 65)\n    return false;\n  if (code2 <= 90)\n    return true;\n  if (code2 < 97)\n    return code2 === 95;\n  if (code2 <= 122)\n    return true;\n  if (code2 <= 65535) {\n    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));\n  }\n  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = /* @__PURE__ */ new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = /* @__PURE__ */ new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = /* @__PURE__ */ new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (387 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 387)\n          break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1))\n      return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name);\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 387) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (387 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = /* @__PURE__ */ new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType))\n      return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === void 0) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === void 0) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === void 0) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename)\n      comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length != commentsLen)\n      this.comments.length = commentsLen;\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0)\n      return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default: {\n            setInnerComments(node, comments);\n          }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0)\n      return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  resetPreviousIdentifierLeadingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0)\n      return;\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0)\n      return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code2) {\n  switch (code2) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code2) {\n  switch (code2) {\n    case 9:\n    case 11:\n    case 12:\n    case 32:\n    case 160:\n    case 5760:\n    case 8192:\n    case 8193:\n    case 8194:\n    case 8195:\n    case 8196:\n    case 8197:\n    case 8198:\n    case 8199:\n    case 8200:\n    case 8201:\n    case 8202:\n    case 8239:\n    case 8287:\n    case 12288:\n    case 65279:\n      return true;\n    default:\n      return false;\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 139;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = /* @__PURE__ */ new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(value) {\n    if (value) {\n      this.flags |= 1;\n    } else {\n      this.flags &= ~1;\n    }\n  }\n  init({\n    strictMode,\n    sourceType,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(value) {\n    if (value) {\n      this.flags |= 2;\n    } else {\n      this.flags &= ~2;\n    }\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(value) {\n    if (value) {\n      this.flags |= 4;\n    } else {\n      this.flags &= ~4;\n    }\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(value) {\n    if (value) {\n      this.flags |= 8;\n    } else {\n      this.flags &= ~8;\n    }\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(value) {\n    if (value) {\n      this.flags |= 16;\n    } else {\n      this.flags &= ~16;\n    }\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(value) {\n    if (value) {\n      this.flags |= 32;\n    } else {\n      this.flags &= ~32;\n    }\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(value) {\n    if (value) {\n      this.flags |= 64;\n    } else {\n      this.flags &= ~64;\n    }\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(value) {\n    if (value) {\n      this.flags |= 128;\n    } else {\n      this.flags &= ~128;\n    }\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(value) {\n    if (value) {\n      this.flags |= 256;\n    } else {\n      this.flags &= ~256;\n    }\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(value) {\n    if (value) {\n      this.flags |= 512;\n    } else {\n      this.flags &= ~512;\n    }\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(value) {\n    if (value) {\n      this.flags |= 1024;\n    } else {\n      this.flags &= ~1024;\n    }\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(value) {\n    if (value) {\n      this.flags |= 2048;\n    } else {\n      this.flags &= ~2048;\n    }\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code2) {\n  return code2 >= 48 && code2 <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: (ch) => ch === 48 || ch === 49,\n  oct: (ch) => ch >= 48 && ch <= 55,\n  dec: (ch) => ch >= 48 && ch <= 57,\n  hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (; ; ) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = (ch2) => ({\n    pos,\n    ch: ch2,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120: {\n      let code2;\n      ({\n        code: code2,\n        pos\n      } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n      return res(code2 === null ? null : String.fromCharCode(code2));\n    }\n    case 117: {\n      let code2;\n      ({\n        code: code2,\n        pos\n      } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n      return res(code2 === null ? null : String.fromCodePoint(code2));\n    }\n    case 116:\n      return res(\"\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\v\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code2 = input.charCodeAt(pos);\n    let val;\n    if (code2 === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError)\n          return {\n            n: null,\n            pos\n          };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError)\n          return {\n            n: null,\n            pos\n          };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code2 >= 97) {\n      val = code2 - 97 + 10;\n    } else if (code2 >= 65) {\n      val = code2 - 65 + 10;\n    } else if (_isDigit(code2)) {\n      val = code2 - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code2;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code: code2,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code2 !== null && code2 > 1114111) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code: code2,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code: code2,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery)\n          return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 64512) === 55296 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 64512) === 56320) {\n        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead)\n      this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(139);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead)\n      startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead)\n      return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens)\n      this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead)\n      startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead)\n      return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens)\n      this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop:\n      while (this.state.pos < this.length) {\n        const ch = this.input.charCodeAt(this.state.pos);\n        switch (ch) {\n          case 32:\n          case 160:\n          case 9:\n            ++this.state.pos;\n            break;\n          case 13:\n            if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n              ++this.state.pos;\n            }\n          case 10:\n          case 8232:\n          case 8233:\n            ++this.state.pos;\n            ++this.state.curLine;\n            this.state.lineStart = this.state.pos;\n            break;\n          case 47:\n            switch (this.input.charCodeAt(this.state.pos + 1)) {\n              case 42: {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n                break;\n              }\n              case 47: {\n                const comment = this.skipLineComment(2);\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n                break;\n              }\n              default:\n                break loop;\n            }\n            break;\n          default:\n            if (isWhitespace(ch)) {\n              ++this.state.pos;\n            } else if (ch === 45 && !this.inModule && this.options.annexB) {\n              const pos = this.state.pos;\n              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n                const comment = this.skipLineComment(3);\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n              } else {\n                break loop;\n              }\n            } else if (ch === 60 && !this.inModule && this.options.annexB) {\n              const pos = this.state.pos;\n              if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n                const comment = this.skipLineComment(4);\n                if (comment !== void 0) {\n                  this.addComment(comment);\n                  if (this.options.attachComment)\n                    comments.push(comment);\n                }\n              } else {\n                break loop;\n              }\n            } else {\n              break loop;\n            }\n        }\n      }\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(138, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(138, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2)\n      return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33)\n      return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code2) {\n    let type = code2 === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code2 === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code2) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code2 === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code2 === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code2 === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code2) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code2 === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code2 === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code2) {\n    switch (code2) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        if (next === 120 || next === 88) {\n          this.readRadixNumber(16);\n          return;\n        }\n        if (next === 111 || next === 79) {\n          this.readRadixNumber(8);\n          return;\n        }\n        if (next === 98 || next === 66) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code2);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code2);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code2);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code2);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code2);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code2)) {\n          this.readWord(code2);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code2)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(137, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(135, str);\n      return;\n    }\n    this.finishToken(134, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(135, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(136, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(134, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code: code2,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code2;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(133, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== void 0) {\n      this.state.pos += firstCode <= 65535 ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 65535 ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== void 0) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!this.options.errorRecovery)\n      throw error;\n    if (!this.isLookahead)\n      this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos)\n        break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {\n  }\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some((name) => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = /* @__PURE__ */ new Set();\n    this.loneAccessors = /* @__PURE__ */ new Map();\n    this.undefinedPrivateNames = /* @__PURE__ */ new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = /* @__PURE__ */ new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined)\n          loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name))\n        return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = /* @__PURE__ */ new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration())\n      return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node)\n      return;\n    const extra = node.extra = node.extra || {};\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13))\n      return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node2 = null) => {\n        abortSignal.node = node2;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors)\n      return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = /* @__PURE__ */ new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler2 = this.getScopeHandler();\n    this.scope = new ScopeHandler2(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule) {\n      paramFlags |= 2;\n    }\n    this.scope.enter(1);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges)\n      this.range = [pos, 0];\n    if (parser != null && parser.filename)\n      this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function() {\n    const newNode = new Node(void 0, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== void 0) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges)\n      node.range[1] = endLoc.index;\n    if (this.options.attachComment)\n      this.processComment(node);\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges)\n      node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges)\n      node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\nconst reservedTypes = /* @__PURE__ */ new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass) => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = void 0;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n  finishToken(type, val) {\n    if (type !== 133 && type !== 13 && type !== 28) {\n      if (this.flowPragma === void 0) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === void 0) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches)\n        ;\n      else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(133)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode2 = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        super.parseImport(bodyNode2);\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode2 = this.flowParseDeclare(bodyNode2, true);\n      }\n      body.push(bodyNode2);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach((bodyElement) => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n    this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word))\n      return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(142)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\")\n          this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    var _startLoc;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3))\n        break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 10:\n        this.next();\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 133:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(134)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        this.unexpected();\n        return;\n      case 134:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 135:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17))\n      return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node2 = stack.pop();\n      if (node2.type === \"ArrowFunctionExpression\") {\n        if (node2.typeParameters || !node2.returnType) {\n          this.finishArrowValidation(node2);\n        } else {\n          arrows.push(node2);\n        }\n        stack.push(node2.body);\n      } else if (node2.type === \"ConditionalExpression\") {\n        stack.push(node2.consequent);\n        stack.push(node2.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach((node2) => this.finishArrowValidation(node2));\n      return [arrows, []];\n    }\n    return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(2 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse2) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse2();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse2();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return node;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node))\n      return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code2 === 62 || code2 === 60)) {\n      this.finishOp(code2 === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code2 === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code2);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node2 = this.startNode();\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node2.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node2.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node2, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10))\n        this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport))\n      return true;\n    if (this.isContextual(130)) {\n      if (!isExport)\n        return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55))\n        this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx2;\n    if (this.hasPlugin(\"jsx\") && (this.match(142) || this.match(47))) {\n      state = this.state.clone();\n      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx2.error)\n        return jsx2.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse((abort) => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)\n          abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);\n        if (expr.type !== \"ArrowFunctionExpression\")\n          abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression2;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx2) != null && _jsx2.node) {\n        this.state = jsx2.failState;\n        return jsx2.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx2) != null && _jsx3.thrown)\n        throw jsx2.error;\n      if (arrow.thrown)\n        throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon())\n          this.unexpected();\n        if (!this.match(19))\n          this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown)\n        return null;\n      if (result.error)\n        this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted)\n        return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error)\n        return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error)\n          this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node))\n      return;\n    return super.parseArrowExpression(node, void 0, true);\n  }\n  readToken_mult_modulo(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code2);\n  }\n  readToken_pipe_amp(code2) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code2 === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code2);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 134: {\n        const literal = this.parseNumericLiteral(this.state.value);\n        if (endOfInit()) {\n          return {\n            type: \"number\",\n            loc: literal.loc.start,\n            value: literal\n          };\n        }\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n      }\n      case 133: {\n        const literal = this.parseStringLiteral(this.state.value);\n        if (endOfInit()) {\n          return {\n            type: \"string\",\n            loc: literal.loc.start,\n            value: literal\n          };\n        }\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n      }\n      case 85:\n      case 86: {\n        const literal = this.parseBooleanLiteral(this.match(85));\n        if (endOfInit()) {\n          return {\n            type: \"boolean\",\n            loc: literal.loc.start,\n            value: literal\n          };\n        }\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n      }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = /* @__PURE__ */ new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\": {\n          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n          memberNode.init = init.value;\n          members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n          break;\n        }\n        case \"number\": {\n          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n          memberNode.init = init.value;\n          members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n          break;\n        }\n        case \"string\": {\n          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n          memberNode.init = init.value;\n          members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n          break;\n        }\n        case \"invalid\": {\n          throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n        }\n        case \"none\": {\n          switch (explicitType) {\n            case \"boolean\":\n              this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n              break;\n            case \"number\":\n              this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n              break;\n            default:\n              members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n          }\n        }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102))\n      return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default: {\n        const empty = () => {\n          node.members = [];\n          this.expect(8);\n          return this.finishNode(node, \"EnumStringBody\");\n        };\n        node.explicitType = false;\n        const boolsLen = members.booleanMembers.length;\n        const numsLen = members.numberMembers.length;\n        const strsLen = members.stringMembers.length;\n        const defaultedLen = members.defaultedMembers.length;\n        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n          return empty();\n        } else if (!boolsLen && !numsLen) {\n          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n            enumName\n          });\n          this.expect(8);\n          return this.finishNode(node, \"EnumStringBody\");\n        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n          for (const member of members.defaultedMembers) {\n            this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n              enumName,\n              memberName: member.id.name\n            });\n          }\n          node.members = members.booleanMembers;\n          this.expect(8);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n          for (const member of members.defaultedMembers) {\n            this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n              enumName,\n              memberName: member.id.name\n            });\n          }\n          node.members = members.numberMembers;\n          this.expect(8);\n          return this.finishNode(node, \"EnumNumberBody\");\n        } else {\n          this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n            enumName\n          });\n          return empty();\n        }\n      }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: '\"',\n  amp: \"&\",\n  apos: \"'\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\",\n  iexcl: \"\",\n  cent: \"\",\n  pound: \"\",\n  curren: \"\",\n  yen: \"\",\n  brvbar: \"\",\n  sect: \"\",\n  uml: \"\",\n  copy: \"\",\n  ordf: \"\",\n  laquo: \"\",\n  not: \"\",\n  shy: \"\",\n  reg: \"\",\n  macr: \"\",\n  deg: \"\",\n  plusmn: \"\",\n  sup2: \"\",\n  sup3: \"\",\n  acute: \"\",\n  micro: \"\",\n  para: \"\",\n  middot: \"\",\n  cedil: \"\",\n  sup1: \"\",\n  ordm: \"\",\n  raquo: \"\",\n  frac14: \"\",\n  frac12: \"\",\n  frac34: \"\",\n  iquest: \"\",\n  Agrave: \"\",\n  Aacute: \"\",\n  Acirc: \"\",\n  Atilde: \"\",\n  Auml: \"\",\n  Aring: \"\",\n  AElig: \"\",\n  Ccedil: \"\",\n  Egrave: \"\",\n  Eacute: \"\",\n  Ecirc: \"\",\n  Euml: \"\",\n  Igrave: \"\",\n  Iacute: \"\",\n  Icirc: \"\",\n  Iuml: \"\",\n  ETH: \"\",\n  Ntilde: \"\",\n  Ograve: \"\",\n  Oacute: \"\",\n  Ocirc: \"\",\n  Otilde: \"\",\n  Ouml: \"\",\n  times: \"\",\n  Oslash: \"\",\n  Ugrave: \"\",\n  Uacute: \"\",\n  Ucirc: \"\",\n  Uuml: \"\",\n  Yacute: \"\",\n  THORN: \"\",\n  szlig: \"\",\n  agrave: \"\",\n  aacute: \"\",\n  acirc: \"\",\n  atilde: \"\",\n  auml: \"\",\n  aring: \"\",\n  aelig: \"\",\n  ccedil: \"\",\n  egrave: \"\",\n  eacute: \"\",\n  ecirc: \"\",\n  euml: \"\",\n  igrave: \"\",\n  iacute: \"\",\n  icirc: \"\",\n  iuml: \"\",\n  eth: \"\",\n  ntilde: \"\",\n  ograve: \"\",\n  oacute: \"\",\n  ocirc: \"\",\n  otilde: \"\",\n  ouml: \"\",\n  divide: \"\",\n  oslash: \"\",\n  ugrave: \"\",\n  uacute: \"\",\n  ucirc: \"\",\n  uuml: \"\",\n  yacute: \"\",\n  thorn: \"\",\n  yuml: \"\",\n  OElig: \"\",\n  oelig: \"\",\n  Scaron: \"\",\n  scaron: \"\",\n  Yuml: \"\",\n  fnof: \"\",\n  circ: \"\",\n  tilde: \"\",\n  Alpha: \"\",\n  Beta: \"\",\n  Gamma: \"\",\n  Delta: \"\",\n  Epsilon: \"\",\n  Zeta: \"\",\n  Eta: \"\",\n  Theta: \"\",\n  Iota: \"\",\n  Kappa: \"\",\n  Lambda: \"\",\n  Mu: \"\",\n  Nu: \"\",\n  Xi: \"\",\n  Omicron: \"\",\n  Pi: \"\",\n  Rho: \"\",\n  Sigma: \"\",\n  Tau: \"\",\n  Upsilon: \"\",\n  Phi: \"\",\n  Chi: \"\",\n  Psi: \"\",\n  Omega: \"\",\n  alpha: \"\",\n  beta: \"\",\n  gamma: \"\",\n  delta: \"\",\n  epsilon: \"\",\n  zeta: \"\",\n  eta: \"\",\n  theta: \"\",\n  iota: \"\",\n  kappa: \"\",\n  lambda: \"\",\n  mu: \"\",\n  nu: \"\",\n  xi: \"\",\n  omicron: \"\",\n  pi: \"\",\n  rho: \"\",\n  sigmaf: \"\",\n  sigma: \"\",\n  tau: \"\",\n  upsilon: \"\",\n  phi: \"\",\n  chi: \"\",\n  psi: \"\",\n  omega: \"\",\n  thetasym: \"\",\n  upsih: \"\",\n  piv: \"\",\n  ensp: \"\",\n  emsp: \"\",\n  thinsp: \"\",\n  zwnj: \"\",\n  zwj: \"\",\n  lrm: \"\",\n  rlm: \"\",\n  ndash: \"\",\n  mdash: \"\",\n  lsquo: \"\",\n  rsquo: \"\",\n  sbquo: \"\",\n  ldquo: \"\",\n  rdquo: \"\",\n  bdquo: \"\",\n  dagger: \"\",\n  Dagger: \"\",\n  bull: \"\",\n  hellip: \"\",\n  permil: \"\",\n  prime: \"\",\n  Prime: \"\",\n  lsaquo: \"\",\n  rsaquo: \"\",\n  oline: \"\",\n  frasl: \"\",\n  euro: \"\",\n  image: \"\",\n  weierp: \"\",\n  real: \"\",\n  trade: \"\",\n  alefsym: \"\",\n  larr: \"\",\n  uarr: \"\",\n  rarr: \"\",\n  darr: \"\",\n  harr: \"\",\n  crarr: \"\",\n  lArr: \"\",\n  uArr: \"\",\n  rArr: \"\",\n  dArr: \"\",\n  hArr: \"\",\n  forall: \"\",\n  part: \"\",\n  exist: \"\",\n  empty: \"\",\n  nabla: \"\",\n  isin: \"\",\n  notin: \"\",\n  ni: \"\",\n  prod: \"\",\n  sum: \"\",\n  minus: \"\",\n  lowast: \"\",\n  radic: \"\",\n  prop: \"\",\n  infin: \"\",\n  ang: \"\",\n  and: \"\",\n  or: \"\",\n  cap: \"\",\n  cup: \"\",\n  int: \"\",\n  there4: \"\",\n  sim: \"\",\n  cong: \"\",\n  asymp: \"\",\n  ne: \"\",\n  equiv: \"\",\n  le: \"\",\n  ge: \"\",\n  sub: \"\",\n  sup: \"\",\n  nsub: \"\",\n  sube: \"\",\n  supe: \"\",\n  oplus: \"\",\n  otimes: \"\",\n  perp: \"\",\n  sdot: \"\",\n  lceil: \"\",\n  rceil: \"\",\n  lfloor: \"\",\n  rfloor: \"\",\n  lang: \"\",\n  rang: \"\",\n  loz: \"\",\n  spades: \"\",\n  clubs: \"\",\n  hearts: \"\",\n  diams: \"\"\n};\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = (superClass) => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (; ; ) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(142);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(141, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (; ; ) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote)\n        break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(133, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, void 0, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(140, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(140)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14))\n      return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 142:\n      case 133:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(143)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(143)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(143);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(143)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(143);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents:\n        for (; ; ) {\n          switch (this.state.type) {\n            case 142:\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(56)) {\n                closingElement = this.jsxParseClosingElementAt(startLoc);\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startLoc));\n              break;\n            case 141:\n              children.push(this.parseExprAtom());\n              break;\n            case 5: {\n              const node2 = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node2));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node2, types.j_expr));\n              }\n              break;\n            }\n            default:\n              this.unexpected();\n          }\n        }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(141)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(142)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(142);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace)\n      super.skipSpace();\n  }\n  getTokenFromCode(code2) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code2)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code2 === 62) {\n        ++this.state.pos;\n        this.finishToken(143);\n        return;\n      }\n      if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {\n        this.jsxReadString(code2);\n        return;\n      }\n    }\n    if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(142);\n      return;\n    }\n    super.getTokenFromCode(code2);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 142) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 142) {\n      context.push(types.j_oTag);\n    } else if (type === 143) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = /* @__PURE__ */ new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(/* @__PURE__ */ new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags == 256) {\n      this.importsStack.push(/* @__PURE__ */ new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags == 256) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name))\n          return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type)\n      scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name))\n      return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nconst unwrapParenthesizedExpression = (node) => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = void 0;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\": {\n        const {\n          key,\n          value\n        } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n        }\n        this.toAssignable(value, isLHS);\n        break;\n      }\n      case \"SpreadElement\": {\n        throw new Error(\"Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.\");\n      }\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt)\n        continue;\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return node.properties.every((prop, i) => {\n          return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n        });\n      }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every((element) => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0: {\n        const node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(3, 93, 1);\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n        }\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 138) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseAssignableListItem(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  parseAssignableListItemTypes(param, flags) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    var _startLoc, _left;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29))\n      return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    }, type);\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, {\n    in: ancestor,\n    binding = 64,\n    checkClashes = false,\n    strictModeChanged = false,\n    hasParenthesizedAncestor = false\n  }) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression))\n      return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true)\n      return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern)\n          break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return void 0;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = (superClass) => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return void 0;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return void 0;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return void 0;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (; ; ) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier)\n        break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (; ; ) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return void 0;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return void 0;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(133)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n    }\n    node.argument = super.parseExprAtom();\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(142)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type)\n      node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17))\n      node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly)\n        property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type)\n        property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach((elementNode) => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const {\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const startLoc2 = this.state.startLoc;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAtNode(label);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAtNode(type);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract)\n        this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 133:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType)\n      return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 133:\n      case 134:\n      case 135:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 134 && nextToken.type !== 135) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default: {\n        const {\n          type\n        } = this.state;\n        if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n          const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n          if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, nodeType);\n          }\n          return this.tsParseTypeReference();\n        }\n      }\n    }\n    this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types2 = [];\n    do {\n      types2.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types2.length === 1 && !hasLeadingOperator) {\n      return types2[0];\n    }\n    node.types = types2;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon)\n        this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak())\n      return null;\n    this.expectContextual(129);\n    if (properties.declare)\n      node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookahead().type !== 16) {\n        const node2 = this.startNode();\n        this.next();\n        return this.finishNode(node2, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const)\n      node.const = true;\n    if (properties.declare)\n      node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(133)) {\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    node.isExport = isExport || false;\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(133)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse((abort) => f() || abort());\n    if (result.aborted || !result.node)\n      return;\n    if (result.error)\n      this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== void 0 && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let startType = this.state.type;\n    let kind;\n    if (this.isContextual(100)) {\n      startType = 74;\n      kind = \"let\";\n    }\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          nany.declare = true;\n          return super.parseFunctionStatement(nany, false, false);\n        case 80:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(nany, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            nany.declare = true;\n            return this.parseVarStatement(nany, kind || this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(nany, {\n            const: true,\n            declare: true\n          });\n        case 129: {\n          const result = this.tsParseInterfaceDeclaration(nany, {\n            declare: true\n          });\n          if (result)\n            return result;\n        }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(nany, this.state.value, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\": {\n        const declaration = this.tsTryParseDeclare(node);\n        if (declaration) {\n          declaration.declare = true;\n        }\n        return declaration;\n      }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(256);\n          this.prodParam.enter(0);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(133)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak())\n        return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47))\n      return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res)\n      return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47)\n      return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart())\n      return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseAssignableListItem(flags, decorators) {\n    const startLoc = this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility)\n        pp.accessibility = accessibility;\n      if (readonly)\n        pp.readonly = readonly;\n      if (override)\n        pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : void 0;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach((node) => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments)\n          return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result2.typeParameters = typeArguments;\n          return result2;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node2 = this.startNodeAt(startLoc);\n          node2.callee = base;\n          node2.arguments = this.parseCallExpressionArguments(11, false);\n          this.tsCheckForInvalidTypeCasts(node2.arguments);\n          node2.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node2.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node2, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport))\n      return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(133)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      } else {\n        node.importKind = \"value\";\n      }\n      return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result)\n        return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext)\n      return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init)\n        continue;\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(126)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result)\n        return result;\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some((modifier) => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional)\n      methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart())\n      return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n      return expr;\n    }\n    if (result.error)\n      this.state = result.failState;\n    return result.node;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration)\n      return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters)\n      node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type)\n      node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters)\n      method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters)\n      method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\")\n      return;\n    if (node.type === \"MethodDefinition\" && !node.value.body)\n      return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters)\n      prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters)\n      node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx2;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(142) || this.match(47))) {\n      state = this.state.clone();\n      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx2.error)\n        return jsx2.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state)\n      state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse((abort) => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters)\n        this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx2) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error)\n        return typeCast.node;\n    }\n    if ((_jsx2 = jsx2) != null && _jsx2.node) {\n      this.state = jsx2.failState;\n      return jsx2.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters)\n        this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse((abort) => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19))\n          abort();\n        return returnType;\n      });\n      if (result.aborted)\n        return;\n      if (!result.thrown) {\n        if (result.error)\n          this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseAssignableListItemTypes(param, flags) {\n    if (!(flags & 2))\n      return param;\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type)\n      param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code2) {\n    if (this.state.inType) {\n      if (code2 === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code2 === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code2);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every((expr) => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments)\n        node.typeParameters = typeArguments;\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\")\n    return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree2) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree2) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree2) {\n  if (estree2) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree2) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree2)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\")\n    return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(144)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(144);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n  getTokenFromCode(code2) {\n    if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(144, 2);\n    } else {\n      super.getTokenFromCode(code2);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== void 0) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const nextToken = this.lookahead();\n    if (nextToken.type === 144) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\")\n      return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(144) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder)\n      return super.parseExport(node, decorators);\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter((node2) => node2.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder)\n      return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport)\n        this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some((p) => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find((plugin2) => {\n    if (Array.isArray(plugin2)) {\n      return plugin2[0] === name;\n    } else {\n      return plugin2 === name;\n    }\n  });\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return plugin[1][option];\n  }\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = getPluginOption(plugins, \"decorators\", \"allowCallParenthesized\");\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map((p) => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map((t) => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\") || hasPlugin(plugins, \"importAttributes\")) {\n        throw new Error(\"Cannot combine importAssertions, importAttributes and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (hasPlugin(plugins, \"importAssertions\") && hasPlugin(plugins, \"importAttributes\")) {\n    throw new Error(\"Cannot combine importAssertions and importAttributes plugins.\");\n  }\n  if (hasPlugin(plugins, \"recordAndTuple\") && getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(\", \"));\n  }\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (hasPlugin(plugins, \"optionalChainingAssign\") && getPluginOption(plugins, \"optionalChainingAssign\", \"version\") !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: void 0,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowNewTargetOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createImportExpressions: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true,\n  annexB: true\n};\nfunction getOptions(opts) {\n  if (opts == null) {\n    return Object.assign({}, defaultOptions);\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  const options = {};\n  for (const key of Object.keys(defaultOptions)) {\n    var _opts$key;\n    options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];\n  }\n  return options;\n}\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      protoRef.used = true;\n    }\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(139)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(108)) {\n      if (this.prodParam.hasYield) {\n        let left2 = this.parseYield();\n        if (afterLeftParse) {\n          left2 = afterLeftParse.call(this, left2, startLoc);\n        }\n        return left2;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(108)) {\n                throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n              }\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr2 = this.parseAwait(startLoc);\n      if (!sawUnary)\n        this.checkExponentialAfterUnary(expr2);\n      return expr2;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr2 = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr2 && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\")\n      });\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false))\n      return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.operator = this.state.value;\n      node2.prefix = false;\n      node2.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node2, \"UpdateExpression\")\n      });\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(138)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n  expectImportAttributesPlugin() {\n    if (!this.hasPlugin(\"importAssertions\")) {\n      this.expectPlugin(\"importAttributes\");\n    }\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectImportAttributesPlugin();\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node, {\n          maxArgumentCount: this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAttributes\") && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (this.match(10)) {\n          if (this.options.createImportExpressions) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90: {\n        return this.parseDo(this.startNode(), false);\n      }\n      case 56:\n      case 31: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n      case 134:\n        return this.parseNumericLiteral(this.state.value);\n      case 135:\n        return this.parseBigIntLiteral(this.state.value);\n      case 136:\n        return this.parseDecimalLiteral(this.state.value);\n      case 133:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n      case 2:\n      case 1: {\n        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n      }\n      case 0: {\n        return this.parseArrayLike(3, true, false, refExpressionErrors);\n      }\n      case 6:\n      case 7: {\n        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n      }\n      case 5: {\n        return this.parseObjectLike(8, false, false, refExpressionErrors);\n      }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = node.callee = this.parseNoCallExpr();\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, callee);\n        }\n      }\n      case 138: {\n        this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n          identifierName: this.state.value\n        });\n        return this.parsePrivateName();\n      }\n      case 33: {\n        return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n      }\n      case 32: {\n        return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n      }\n      case 37:\n      case 38: {\n        return this.parseTopicReference(\"hack\");\n      }\n      case 44:\n      case 54:\n      case 27: {\n        const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        }\n        this.unexpected();\n        break;\n      }\n      case 47: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n        } else {\n          this.unexpected();\n        }\n        break;\n      }\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type: type2\n            } = this.state;\n            if (type2 === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type2)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type2 === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" : \"TopicReference\";\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);\n      }\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\"pipelineOperator\", {\n          topicToken: tokenLabelName(tokenType)\n        }]);\n      }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n    if (this.isContextual(101)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, id);\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      if (!isSource)\n        this.unexpected();\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      if (!this.options.createImportExpressions) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {\n          phase: this.state.value\n        });\n      }\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    }\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc)\n      this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc)\n      this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = /* @__PURE__ */ Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length)\n        this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern)\n        this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node)\n      this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 134:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 133:\n            key = this.parseStringLiteral(value);\n            break;\n          case 135:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 136:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case 138: {\n            const privateKeyLoc = this.state.startLoc;\n            if (refExpressionErrors != null) {\n              if (refExpressionErrors.privateKeyLoc === null) {\n                refExpressionErrors.privateKeyLoc = privateKeyLoc;\n              }\n            } else {\n              this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n            }\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 138) {\n        prop.computed = false;\n      }\n    }\n    return prop.key;\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(2 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i]))\n        return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: 5,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword2) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait)\n      return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak())\n      return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 139:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating)\n            break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n      node.options = null;\n    }\n    if (this.eat(12)) {\n      this.expectImportAttributesPlugin();\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        this.eat(12);\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parsePropertyNamePrefixOperator(prop) {\n  }\n}\nconst loopLabel = {\n  kind: 1\n}, switchLabel = {\n  kind: 2\n};\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 138) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(132),\n            value,\n            start: hashEndPos,\n            end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.comments;\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end = 139, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, at, {\n          localName\n        });\n      }\n    }\n    let finishedProgram;\n    if (end === 139) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifier() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n  startsUsingForOf() {\n    const {\n      type,\n      containsEsc\n    } = this.lookahead();\n    if (type === 102 && !containsEsc) {\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n  startsAwaitUsing() {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46)\n          break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration)\n          this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100: {\n        if (this.state.containsEsc) {\n          break;\n        }\n        const next = this.nextTokenStart();\n        const nextCh = this.codePointAtPos(next);\n        if (nextCh !== 91) {\n          if (!allowDeclaration && this.hasFollowingLineBreak())\n            break;\n          if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n            break;\n          }\n        }\n      }\n      case 75: {\n        if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n      }\n      case 74: {\n        const kind = this.state.value;\n        return this.parseVarStatement(node, kind);\n      }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n          break;\n        }\n      }\n      case 82: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n        }\n        this.next();\n        let result;\n        if (starttype === 83) {\n          result = this.parseImport(node);\n          if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(node, decorators);\n          if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n            this.sawUnambiguousESM = true;\n          }\n        }\n        this.assertModuleNodeAllowed(result);\n        return result;\n      }\n      default: {\n        if (this.isAsyncFunction()) {\n          if (!allowDeclaration) {\n            this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n          }\n          this.next();\n          return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n        }\n      }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\"))\n      return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode)\n        this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc2 = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc2, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node2 = this.startNodeAt(startLoc);\n          node2.object = expr;\n          if (this.match(138)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node2.property = this.parsePrivateName();\n          } else {\n            node2.property = this.parseIdentifier(true);\n          }\n          node2.computed = false;\n          expr = this.finishNode(node2, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak)\n          break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init2 = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init2);\n        }\n        if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {\n          return this.parseForIn(node, init2, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init2);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(0);\n    let cur;\n    for (let sawDefault; !this.match(8); ) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur)\n          this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur)\n      this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: 9\n    });\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind,\n      statementStart: this.state.start\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null)\n        this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (; ; ) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"const\"\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12))\n        break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    this.checkLVal(id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? 5 : 8201\n    });\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(2);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id)\n      return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(138);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(138);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate2 = this.match(138);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate2) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate2 = this.match(138);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate2) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate2 = this.match(138);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 133) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 138) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    return this.parsePropertyName(member);\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(64 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, void 0, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, key);\n      }\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n  }\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(64 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault)\n        this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers)\n        node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers)\n        node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95))\n      return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node2 = this.parseClass(this.startNode(), true, false);\n      return node2;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id)\n            throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8))\n          break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(133);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(133)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find((specifier) => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== void 0) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== void 0) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport)\n      return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.parseIdentifier(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return phaseIdentifier;\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(133)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar)\n      this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(133))\n      this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      in: {\n        type\n      },\n      binding: bindingType\n    });\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = /* @__PURE__ */ new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(133)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(133)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = /* @__PURE__ */ new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(133)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    let useWith = false;\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      {\n        if (this.hasPlugin(\"moduleAttributes\")) {\n          attributes = this.parseModuleAttributes();\n        } else {\n          this.expectImportAttributesPlugin();\n          attributes = this.parseImportAttributes();\n        }\n      }\n      useWith = true;\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (this.hasPlugin(\"importAttributes\")) {\n        if (this.getPluginOption(\"importAttributes\", \"deprecatedAssertSyntax\") !== true) {\n          this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n        }\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      } else {\n        this.expectOnePlugin([\"importAttributes\", \"importAssertions\"]);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else if (this.hasPlugin(\"importAttributes\") || this.hasPlugin(\"importAssertions\")) {\n      attributes = [];\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = [];\n      } else\n        return;\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8))\n          break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(133);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, void 0);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    file.comments.length = this.state.commentsLen;\n    return file;\n  }\n}\nfunction pluginsMap(plugins) {\n  const pluginMap = /* @__PURE__ */ new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name))\n      pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {\n        }\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {\n      }\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes2 = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes2;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n  return new cls(options, input);\n}\nconst parserClassCache = {};\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\nvar parse_1 = lib.parse = parse;\nvar parseExpression_1 = lib.parseExpression = parseExpression;\nvar tokTypes_1 = lib.tokTypes = tokTypes;\n\nexport { lib as __moduleExports, parse_1 as parse, parseExpression_1 as parseExpression, tokTypes_1 as tokTypes, lib as default };",
      "start": 1727610131413,
      "end": 1727610131524,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          ""
        ],
        "names": [],
        "mappings": "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AAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AAC5hE,MAAM,qBAAqB,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;AAC/hC,SAAS,aAAa,CAAC,KAAK,EAAE,GAAG,EAAE;AACnC,EAAE,IAAI,GAAG,GAAG,KAAK,CAAC;AAClB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;AAC3D,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;AAClB,IAAI,IAAI,GAAG,GAAG,KAAK;AACnB,MAAM,OAAO,KAAK,CAAC;AACnB,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACtB,IAAI,IAAI,GAAG,IAAI,KAAK;AACpB,MAAM,OAAO,IAAI,CAAC;AAClB,GAAG;AACH,EAAE,OAAO,KAAK,CAAC;AACf,CAAC;AACD,SAAS,iBAAiB,CAAC,KAAK,EAAE;AAClC,EAAE,IAAI,KAAK,GAAG,EAAE;AAChB,IAAI,OAAO,KAAK,KAAK,EAAE,CAAC;AACxB,EAAE,IAAI,KAAK,IAAI,EAAE;AACjB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE,IAAI,KAAK,GAAG,EAAE;AAChB,IAAI,OAAO,KAAK,KAAK,EAAE,CAAC;AACxB,EAAE,IAAI,KAAK,IAAI,GAAG;AAClB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE,IAAI,KAAK,IAAI,KAAK,EAAE;AACtB,IAAI,OAAO,KAAK,IAAI,GAAG,IAAI,uBAAuB,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;AACpF,GAAG;AACH,EAAE,OAAO,aAAa,CAAC,KAAK,EAAE,0BAA0B,CAAC,CAAC;AAC1D,CAAC;AACD,SAAS,gBAAgB,CAAC,KAAK,EAAE;AACjC,EAAE,IAAI,KAAK,GAAG,EAAE;AAChB,IAAI,OAAO,KAAK,KAAK,EAAE,CAAC;AACxB,EAAE,IAAI,KAAK,GAAG,EAAE;AAChB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE,IAAI,KAAK,GAAG,EAAE;AAChB,IAAI,OAAO,KAAK,CAAC;AACjB,EAAE,IAAI,KAAK,IAAI,EAAE;AACjB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE,IAAI,KAAK,GAAG,EAAE;AAChB,IAAI,OAAO,KAAK,KAAK,EAAE,CAAC;AACxB,EAAE,IAAI,KAAK,IAAI,GAAG;AAClB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE,IAAI,KAAK,IAAI,KAAK,EAAE;AACtB,IAAI,OAAO,KAAK,IAAI,GAAG,IAAI,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/E,GAAG;AACH,EAAE,OAAO,aAAa,CAAC,KAAK,EAAE,0BAA0B,CAAC,IAAI,aAAa,CAAC,KAAK,EAAE,qBAAqB,CAAC,CAAC;AACzG,CAAC;AACD,MAAM,aAAa,GAAG;AACtB,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,CAAC;AACxU,EAAE,MAAM,EAAE,CAAC,YAAY,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC;AAC5G,EAAE,UAAU,EAAE,CAAC,MAAM,EAAE,WAAW,CAAC;AACnC,CAAC,CAAC;AACF,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;AAChD,MAAM,sBAAsB,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;AAC7D,MAAM,0BAA0B,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AACrE,SAAS,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;AACxC,EAAE,OAAO,QAAQ,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,MAAM,CAAC;AACzD,CAAC;AACD,SAAS,oBAAoB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC9C,EAAE,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC5E,CAAC;AACD,SAAS,4BAA4B,CAAC,IAAI,EAAE;AAC5C,EAAE,OAAO,0BAA0B,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC9C,CAAC;AACD,SAAS,wBAAwB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAClD,EAAE,OAAO,oBAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,4BAA4B,CAAC,IAAI,CAAC,CAAC;AACpF,CAAC;AACD,SAAS,SAAS,CAAC,IAAI,EAAE;AACzB,EAAE,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC5B,CAAC;AACD,SAAS,eAAe,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE;AAC/C,EAAE,OAAO,OAAO,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,CAAC;AACnE,CAAC;AACD,MAAM,mBAAmB,GAAG,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AAC3f,SAAS,iBAAiB,CAAC,IAAI,EAAE;AACjC,EAAE,OAAO,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvC,CAAC;AACD,MAAM,KAAK,CAAC;AACZ,EAAE,WAAW,CAAC,KAAK,EAAE;AACrB,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AAC3C,IAAI,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;AAC/B,IAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,GAAG;AACH,CAAC;AACD,MAAM,YAAY,CAAC;AACnB,EAAE,WAAW,CAAC,MAAM,EAAE,QAAQ,EAAE;AAChC,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;AACzB,IAAI,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;AACzB,IAAI,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;AAC3B,IAAI,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AACtD,IAAI,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC7B,GAAG;AACH,EAAE,IAAI,UAAU,GAAG;AACnB,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AAC/C,GAAG;AACH,EAAE,IAAI,UAAU,GAAG;AACnB,IAAI,OAAO,CAAC,IAAI,CAAC,oBAAoB,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,IAAI,UAAU,GAAG;AACnB,IAAI,OAAO,CAAC,IAAI,CAAC,qBAAqB,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,IAAI,gBAAgB,GAAG;AACzB,IAAI,OAAO,CAAC,IAAI,CAAC,qBAAqB,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,IAAI,OAAO,GAAG;AAChB,IAAI,OAAO,CAAC,IAAI,CAAC,qBAAqB,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,IAAI,+BAA+B,GAAG;AACxC,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC;AAC/C,IAAI,OAAO,CAAC,KAAK,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,MAAM,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,IAAI,aAAa,GAAG;AACtB,IAAI,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE;AACpD,MAAM,MAAM;AACZ,QAAQ,KAAK;AACb,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7B,MAAM,IAAI,KAAK,GAAG,GAAG,EAAE;AACvB,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,MAAM,IAAI,KAAK,IAAI,GAAG,GAAG,EAAE,CAAC,EAAE;AAC9B,QAAQ,OAAO,KAAK,CAAC;AACrB,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,IAAI,kBAAkB,GAAG;AAC3B,IAAI,OAAO,CAAC,IAAI,CAAC,qBAAqB,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AAClD,GAAG;AACH,EAAE,IAAI,mBAAmB,GAAG;AAC5B,IAAI,OAAO,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;AAChE,GAAG;AACH,EAAE,WAAW,CAAC,KAAK,EAAE;AACrB,IAAI,OAAO,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;AAC5B,GAAG;AACH,EAAE,KAAK,CAAC,KAAK,EAAE;AACf,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;AAClD,GAAG;AACH,EAAE,IAAI,GAAG;AACT,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;AACxC,IAAI,OAAO,KAAK,CAAC,KAAK,CAAC;AACvB,GAAG;AACH,EAAE,0BAA0B,CAAC,KAAK,EAAE;AACpC,IAAI,OAAO,CAAC,EAAE,KAAK,CAAC,KAAK,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AACnF,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,EAAE;AACtC,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;AACpC,IAAI,IAAI,WAAW,GAAG,CAAC,IAAI,WAAW,GAAG,EAAE,EAAE;AAC7C,MAAM,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;AACpE,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5C,MAAM,IAAI,WAAW,GAAG,EAAE,EAAE;AAC5B,QAAQ,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC;AACxB,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;AACrC,UAAU,KAAK,CAAC,gBAAgB,GAAG,IAAI,CAAC;AACxC,SAAS;AACT,QAAQ,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC;AACxB,OAAO;AACP,MAAM,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAClC,MAAM,IAAI,WAAW,GAAG,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC7C,OAAO;AACP,KAAK,MAAM,IAAI,WAAW,GAAG,CAAC,EAAE;AAChC,MAAM,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;AAC5D,QAAQ,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACnC,QAAQ,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;AACtE,QAAQ,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAChE,QAAQ,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC7C,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,GAAG;AAC7B,UAAU,MAAM;AAChB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;AACjD,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACzC,KAAK;AACL,GAAG;AACH,EAAE,kBAAkB,CAAC,KAAK,EAAE,IAAI,EAAE;AAClC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;AACjD,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACzC,KAAK;AACL,GAAG;AACH,EAAE,yBAAyB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,EAAE;AAC3D,IAAI,IAAI,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,CAAC,EAAE;AAC5D,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,gBAAgB,EAAE,GAAG,EAAE;AACtD,QAAQ,cAAc,EAAE,IAAI;AAC5B,OAAO,CAAC,CAAC;AACT,KAAK;AACL,GAAG;AACH,EAAE,mBAAmB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE;AAChD,IAAI,IAAI,EAAE,WAAW,GAAG,CAAC,CAAC;AAC1B,MAAM,OAAO,KAAK,CAAC;AACnB,IAAI,IAAI,WAAW,GAAG,CAAC,EAAE;AACzB,MAAM,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACnC,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvC,IAAI,IAAI,WAAW,GAAG,EAAE,EAAE;AAC1B,MAAM,OAAO,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AACzF,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,GAAG,CAAC,IAAI,KAAK,CAAC,gBAAgB,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AAChJ,GAAG;AACH,EAAE,gBAAgB,CAAC,EAAE,EAAE;AACvB,IAAI,MAAM;AACV,MAAM,IAAI;AACV,KAAK,GAAG,EAAE,CAAC;AACX,IAAI,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7C,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACxC,MAAM,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACpD,KAAK;AACL,GAAG;AACH,EAAE,YAAY,GAAG;AACjB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACvD,GAAG;AACH,EAAE,oBAAoB,GAAG;AACzB,IAAI,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE;AACpD,MAAM,MAAM;AACZ,QAAQ,KAAK;AACb,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7B,MAAM,IAAI,KAAK,GAAG,GAAG,EAAE;AACvB,QAAQ,OAAO,KAAK,CAAC;AACrB,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,qBAAqB,GAAG;AAC1B,IAAI,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE;AACpD,MAAM,MAAM;AACZ,QAAQ,KAAK;AACb,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7B,MAAM,IAAI,KAAK,IAAI,GAAG,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE;AAC9C,QAAQ,OAAO,KAAK,CAAC;AACrB,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC;AACD,MAAM,SAAS,SAAS,KAAK,CAAC;AAC9B,EAAE,WAAW,CAAC,GAAG,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AACtD,GAAG;AACH,CAAC;AACD,MAAM,gBAAgB,SAAS,YAAY,CAAC;AAC5C,EAAE,WAAW,CAAC,KAAK,EAAE;AACrB,IAAI,OAAO,IAAI,SAAS,CAAC,KAAK,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,EAAE;AACtC,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;AACtC,IAAI,IAAI,WAAW,GAAG,IAAI,EAAE;AAC5B,MAAM,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;AACpE,MAAM,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC3C,MAAM,KAAK,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvC,MAAM,OAAO;AACb,KAAK;AACL,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;AAC9C,GAAG;AACH,EAAE,mBAAmB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE;AAChD,IAAI,IAAI,KAAK,CAAC,mBAAmB,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,CAAC;AAC3D,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI,IAAI,WAAW,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACjE,MAAM,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,MAAM,OAAO,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,gBAAgB,CAAC,EAAE,EAAE;AACvB,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;AAC3D,MAAM,KAAK,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;AACjC,KAAK;AACL,GAAG;AACH,CAAC;AACD,MAAM,UAAU,CAAC;AACjB,EAAE,WAAW,GAAG;AAChB,IAAI,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;AACnC,IAAI,IAAI,CAAC,2BAA2B,GAAG,KAAK,CAAC;AAC7C,GAAG;AACH,EAAE,SAAS,CAAC,YAAY,EAAE;AAC1B,IAAI,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;AAC1C,MAAM,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAC5C,KAAK,MAAM;AACX,MAAM,MAAM,CAAC,UAAU,EAAE,aAAa,CAAC,GAAG,YAAY,CAAC;AACvD,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;AACvC,QAAQ,OAAO,KAAK,CAAC;AACrB,OAAO;AACP,MAAM,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AACzD,MAAM,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;AACpD,QAAQ,IAAI,CAAC,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,MAAM,aAAa,CAAC,GAAG,CAAC,EAAE;AAC1F,UAAU,OAAO,KAAK,CAAC;AACvB,SAAS;AACT,OAAO;AACP,MAAM,OAAO,IAAI,CAAC;AAClB,KAAK;AACL,GAAG;AACH,EAAE,eAAe,CAAC,MAAM,EAAE,IAAI,EAAE;AAChC,IAAI,IAAI,iBAAiB,CAAC;AAC1B,IAAI,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;AACrG,GAAG;AACH,CAAC;AACD,SAAS,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC7C,EAAE,IAAI,IAAI,CAAC,gBAAgB,KAAK,KAAK,CAAC,EAAE;AACxC,IAAI,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC;AACrC,GAAG,MAAM;AACT,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC/C,GAAG;AACH,CAAC;AACD,SAAS,kBAAkB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC5C,EAAE,IAAI,IAAI,CAAC,eAAe,KAAK,KAAK,CAAC,EAAE;AACvC,IAAI,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;AACpC,GAAG,MAAM;AACT,IAAI,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC9C,GAAG;AACH,CAAC;AACD,SAAS,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC1C,EAAE,IAAI,IAAI,CAAC,aAAa,KAAK,KAAK,CAAC,EAAE;AACrC,IAAI,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;AAClC,GAAG,MAAM;AACT,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC5C,GAAG;AACH,CAAC;AACD,SAAS,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE;AACxD,EAAE,IAAI,WAAW,GAAG,IAAI,CAAC;AACzB,EAAE,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC;AAC1B,EAAE,OAAO,WAAW,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE;AACxC,IAAI,WAAW,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,IAAI,WAAW,KAAK,IAAI,IAAI,WAAW,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,EAAE;AACnE,IAAI,gBAAgB,CAAC,IAAI,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC;AAC/C,GAAG,MAAM;AACT,IAAI,mBAAmB,CAAC,WAAW,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC;AACzD,GAAG;AACH,CAAC;AACD,MAAM,cAAc,SAAS,UAAU,CAAC;AACxC,EAAE,UAAU,CAAC,OAAO,EAAE;AACtB,IAAI,IAAI,IAAI,CAAC,QAAQ;AACrB,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC3C,IAAI,MAAM;AACV,MAAM,WAAW;AACjB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,WAAW;AAC3C,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,WAAW,CAAC;AACzC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAChC,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AAC7B,GAAG;AACH,EAAE,cAAc,CAAC,IAAI,EAAE;AACvB,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM,kBAAkB,GAAG,YAAY,CAAC,MAAM,CAAC;AACnD,IAAI,IAAI,kBAAkB,KAAK,CAAC;AAChC,MAAM,OAAO;AACb,IAAI,IAAI,CAAC,GAAG,kBAAkB,GAAG,CAAC,CAAC;AACnC,IAAI,MAAM,aAAa,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;AAC1C,IAAI,IAAI,aAAa,CAAC,KAAK,KAAK,IAAI,CAAC,GAAG,EAAE;AAC1C,MAAM,aAAa,CAAC,WAAW,GAAG,IAAI,CAAC;AACvC,MAAM,CAAC,EAAE,CAAC;AACV,KAAK;AACL,IAAI,MAAM;AACV,MAAM,KAAK,EAAE,SAAS;AACtB,KAAK,GAAG,IAAI,CAAC;AACb,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACxB,MAAM,MAAM,SAAS,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;AACxC,MAAM,MAAM,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC;AACvC,MAAM,IAAI,UAAU,GAAG,SAAS,EAAE;AAClC,QAAQ,SAAS,CAAC,cAAc,GAAG,IAAI,CAAC;AACxC,QAAQ,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;AACxC,QAAQ,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAClC,OAAO,MAAM;AACb,QAAQ,IAAI,UAAU,KAAK,SAAS,EAAE;AACtC,UAAU,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC;AACxC,SAAS;AACT,QAAQ,MAAM;AACd,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,eAAe,CAAC,SAAS,EAAE;AAC7B,IAAI,MAAM;AACV,MAAM,QAAQ;AACd,KAAK,GAAG,SAAS,CAAC;AAClB,IAAI,IAAI,SAAS,CAAC,WAAW,KAAK,IAAI,IAAI,SAAS,CAAC,YAAY,KAAK,IAAI,EAAE;AAC3E,MAAM,IAAI,SAAS,CAAC,WAAW,KAAK,IAAI,EAAE;AAC1C,QAAQ,mBAAmB,CAAC,SAAS,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AAC7D,OAAO;AACP,MAAM,IAAI,SAAS,CAAC,YAAY,KAAK,IAAI,EAAE;AAC3C,QAAQ,kBAAkB,CAAC,SAAS,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;AAC7D,OAAO;AACP,KAAK,MAAM;AACX,MAAM,MAAM;AACZ,QAAQ,cAAc,EAAE,IAAI;AAC5B,QAAQ,KAAK,EAAE,YAAY;AAC3B,OAAO,GAAG,SAAS,CAAC;AACpB,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,YAAY,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AAC1D,QAAQ,QAAQ,IAAI,CAAC,IAAI;AACzB,UAAU,KAAK,kBAAkB,CAAC;AAClC,UAAU,KAAK,eAAe,CAAC;AAC/B,UAAU,KAAK,kBAAkB;AACjC,YAAY,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;AAClE,YAAY,MAAM;AAClB,UAAU,KAAK,gBAAgB,CAAC;AAChC,UAAU,KAAK,wBAAwB;AACvC,YAAY,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;AACjE,YAAY,MAAM;AAClB,UAAU,KAAK,qBAAqB,CAAC;AACrC,UAAU,KAAK,oBAAoB,CAAC;AACpC,UAAU,KAAK,yBAAyB,CAAC;AACzC,UAAU,KAAK,cAAc,CAAC;AAC9B,UAAU,KAAK,aAAa,CAAC;AAC7B,UAAU,KAAK,oBAAoB;AACnC,YAAY,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;AAC9D,YAAY,MAAM;AAClB,UAAU,KAAK,iBAAiB,CAAC;AACjC,UAAU,KAAK,cAAc,CAAC;AAC9B,UAAU,KAAK,iBAAiB;AAChC,YAAY,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;AAChE,YAAY,MAAM;AAClB,UAAU,KAAK,wBAAwB,CAAC;AACxC,UAAU,KAAK,mBAAmB;AAClC,YAAY,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;AAClE,YAAY,MAAM;AAClB,UAAU,SAAS;AACnB,YAAY,gBAAgB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AAC7C,WAAW;AACX,SAAS;AACT,OAAO,MAAM;AACb,QAAQ,gBAAgB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACzC,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,yBAAyB,GAAG;AAC9B,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACvD,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,GAAG,EAAE,CAAC;AACjC,GAAG;AACH,EAAE,iCAAiC,CAAC,IAAI,EAAE;AAC1C,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM;AACV,MAAM,MAAM;AACZ,KAAK,GAAG,YAAY,CAAC;AACrB,IAAI,IAAI,MAAM,KAAK,CAAC;AACpB,MAAM,OAAO;AACb,IAAI,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/C,IAAI,IAAI,SAAS,CAAC,WAAW,KAAK,IAAI,EAAE;AACxC,MAAM,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC;AACnC,KAAK;AACL,GAAG;AACH,EAAE,sCAAsC,CAAC,IAAI,EAAE;AAC/C,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM;AACV,MAAM,MAAM;AACZ,KAAK,GAAG,YAAY,CAAC;AACrB,IAAI,IAAI,MAAM,KAAK,CAAC;AACpB,MAAM,OAAO;AACb,IAAI,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,KAAK,IAAI,EAAE;AACxD,MAAM,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC;AACnD,KAAK,MAAM,IAAI,MAAM,IAAI,CAAC,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,KAAK,IAAI,EAAE;AAC9E,MAAM,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC;AACnD,KAAK;AACL,GAAG;AACH,EAAE,uBAAuB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE;AAC5C,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM,kBAAkB,GAAG,YAAY,CAAC,MAAM,CAAC;AACnD,IAAI,IAAI,kBAAkB,KAAK,CAAC;AAChC,MAAM,OAAO;AACb,IAAI,IAAI,CAAC,GAAG,kBAAkB,GAAG,CAAC,CAAC;AACnC,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACxB,MAAM,MAAM,SAAS,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;AACxC,MAAM,MAAM,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC;AACvC,MAAM,MAAM,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC;AAC3C,MAAM,IAAI,YAAY,KAAK,GAAG,EAAE;AAChC,QAAQ,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC;AACrC,OAAO,MAAM,IAAI,UAAU,KAAK,KAAK,EAAE;AACvC,QAAQ,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC;AACtC,OAAO,MAAM,IAAI,UAAU,GAAG,KAAK,EAAE;AACrC,QAAQ,MAAM;AACd,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC;AACD,MAAM,SAAS,GAAG,wBAAwB,CAAC;AAC3C,MAAM,UAAU,GAAG,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AACrD,SAAS,SAAS,CAAC,KAAK,EAAE;AAC1B,EAAE,QAAQ,KAAK;AACf,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI;AACb,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI;AACJ,MAAM,OAAO,KAAK,CAAC;AACnB,GAAG;AACH,CAAC;AACD,MAAM,cAAc,GAAG,+BAA+B,CAAC;AACvD,MAAM,oBAAoB,GAAG,gDAAgD,CAAC;AAC9E,MAAM,yBAAyB,GAAG,IAAI,MAAM,CAAC,MAAM,GAAG,oBAAoB,CAAC,MAAM,GAAG,OAAO,GAAG,0CAA0C,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AACtJ,SAAS,YAAY,CAAC,KAAK,EAAE;AAC7B,EAAE,QAAQ,KAAK;AACf,IAAI,KAAK,CAAC,CAAC;AACX,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,KAAK,GAAG,CAAC;AACb,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,KAAK,CAAC;AACf,IAAI,KAAK,KAAK;AACd,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI;AACJ,MAAM,OAAO,KAAK,CAAC;AACnB,GAAG;AACH,CAAC;AACD,MAAM,KAAK,CAAC;AACZ,EAAE,WAAW,GAAG;AAChB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACtB,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;AAC1B,IAAI,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;AAC5B,IAAI,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;AAC3B,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;AACzB,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC;AAC/B,IAAI,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;AACxB,IAAI,IAAI,CAAC,yBAAyB,GAAG,EAAE,CAAC;AACxC,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB,MAAM,wBAAwB,EAAE,CAAC;AACjC,MAAM,aAAa,EAAE,IAAI;AACzB,KAAK,CAAC;AACN,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;AACzB,IAAI,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;AAC3B,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AACjB,IAAI,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;AACpB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACtB,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AACjB,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;AAC9B,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;AAChC,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACjC,IAAI,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC;AAC9C,IAAI,IAAI,CAAC,YAAY,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AAClD,IAAI,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;AAC1B,GAAG;AACH,EAAE,IAAI,MAAM,GAAG;AACf,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,IAAI,MAAM,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;AACtB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;AACvB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,CAAC;AACP,IAAI,UAAU;AACd,IAAI,UAAU;AACd,IAAI,SAAS;AACb,IAAI,WAAW;AACf,GAAG,EAAE;AACL,IAAI,IAAI,CAAC,MAAM,GAAG,UAAU,KAAK,KAAK,GAAG,KAAK,GAAG,UAAU,KAAK,IAAI,GAAG,IAAI,GAAG,UAAU,KAAK,QAAQ,CAAC;AACtG,IAAI,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;AAC7B,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,WAAW,CAAC;AAClC,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,QAAQ,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC,CAAC,CAAC;AAC1E,GAAG;AACH,EAAE,IAAI,sBAAsB,GAAG;AAC/B,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,IAAI,sBAAsB,CAAC,KAAK,EAAE;AACpC,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;AACtB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;AACvB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,MAAM,GAAG;AACf,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,IAAI,MAAM,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;AACtB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;AACvB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,kBAAkB,GAAG;AAC3B,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,IAAI,kBAAkB,CAAC,KAAK,EAAE;AAChC,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;AACtB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;AACvB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,cAAc,GAAG;AACvB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,IAAI,CAAC,CAAC;AACjC,GAAG;AACH,EAAE,IAAI,cAAc,CAAC,KAAK,EAAE;AAC5B,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;AACvB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC;AACxB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,gBAAgB,GAAG;AACzB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,IAAI,CAAC,CAAC;AACjC,GAAG;AACH,EAAE,IAAI,gBAAgB,CAAC,KAAK,EAAE;AAC9B,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;AACvB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC;AACxB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,eAAe,GAAG;AACxB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,IAAI,CAAC,CAAC;AACjC,GAAG;AACH,EAAE,IAAI,eAAe,CAAC,KAAK,EAAE;AAC7B,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;AACvB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC;AACxB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,iCAAiC,GAAG;AAC1C,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,GAAG,IAAI,CAAC,CAAC;AAClC,GAAG;AACH,EAAE,IAAI,iCAAiC,CAAC,KAAK,EAAE;AAC/C,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC;AACxB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC;AACzB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,SAAS,GAAG;AAClB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,GAAG,IAAI,CAAC,CAAC;AAClC,GAAG;AACH,EAAE,IAAI,SAAS,CAAC,KAAK,EAAE;AACvB,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC;AACxB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC;AACzB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,0BAA0B,GAAG;AACnC,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,GAAG,IAAI,CAAC,CAAC;AAClC,GAAG;AACH,EAAE,IAAI,0BAA0B,CAAC,KAAK,EAAE;AACxC,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC;AACxB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC;AACzB,KAAK;AACL,GAAG;AACH,EAAE,IAAI,kBAAkB,GAAG;AAC3B,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,IAAI,CAAC,CAAC;AACnC,GAAG;AACH,EAAE,IAAI,kBAAkB,CAAC,KAAK,EAAE;AAChC,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC;AACzB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC;AAC1B,KAAK;AACL,GAAG;AACH,EAAE,IAAI,WAAW,GAAG;AACpB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,IAAI,CAAC,CAAC;AACnC,GAAG;AACH,EAAE,IAAI,WAAW,CAAC,KAAK,EAAE;AACzB,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC;AACzB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC;AAC1B,KAAK;AACL,GAAG;AACH,EAAE,WAAW,GAAG;AAChB,IAAI,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AAC3E,GAAG;AACH,EAAE,KAAK,GAAG;AACV,IAAI,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;AAC9B,IAAI,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AAC7B,IAAI,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;AACjC,IAAI,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;AACrC,IAAI,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AACnC,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;AAC/B,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;AACvC,IAAI,KAAK,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;AACnD,IAAI,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;AAC7C,IAAI,KAAK,CAAC,yBAAyB,GAAG,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,CAAC;AAC7E,IAAI,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;AAC3C,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;AACvC,IAAI,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;AACzC,IAAI,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;AACnD,IAAI,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;AACzB,IAAI,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AAC3B,IAAI,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AAC7B,IAAI,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AAC7B,IAAI,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;AACzB,IAAI,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;AAC7C,IAAI,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;AACjD,IAAI,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;AACzC,IAAI,KAAK,CAAC,6BAA6B,GAAG,IAAI,CAAC,6BAA6B,CAAC;AAC7E,IAAI,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;AAC3C,IAAI,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;AAC3C,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,CAAC;AACD,IAAI,QAAQ,GAAG,SAAS,OAAO,CAAC,KAAK,EAAE;AACvC,EAAE,OAAO,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,CAAC;AACpC,CAAC,CAAC;AACF,MAAM,iCAAiC,GAAG;AAC1C,EAAE,SAAS,EAAE,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxE,EAAE,GAAG,EAAE,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;AACjD,CAAC,CAAC;AACF,MAAM,gCAAgC,GAAG;AACzC,EAAE,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;AACrC,EAAE,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AACnC,EAAE,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AACnC,EAAE,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,GAAG;AACpF,CAAC,CAAC;AACF,SAAS,kBAAkB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE;AAC1E,EAAE,MAAM,UAAU,GAAG,GAAG,CAAC;AACzB,EAAE,MAAM,gBAAgB,GAAG,SAAS,CAAC;AACrC,EAAE,MAAM,cAAc,GAAG,OAAO,CAAC;AACjC,EAAE,IAAI,GAAG,GAAG,EAAE,CAAC;AACf,EAAE,IAAI,eAAe,GAAG,IAAI,CAAC;AAC7B,EAAE,IAAI,UAAU,GAAG,GAAG,CAAC;AACvB,EAAE,MAAM;AACR,IAAI,MAAM;AACV,GAAG,GAAG,KAAK,CAAC;AACZ,EAAE,WAAW;AACb,IAAI,IAAI,GAAG,IAAI,MAAM,EAAE;AACvB,MAAM,MAAM,CAAC,YAAY,CAAC,UAAU,EAAE,gBAAgB,EAAE,cAAc,CAAC,CAAC;AACxE,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;AAC1C,MAAM,MAAM;AACZ,KAAK;AACL,IAAI,MAAM,EAAE,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACrC,IAAI,IAAI,WAAW,CAAC,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,GAAG,CAAC,EAAE;AAC3C,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;AAC1C,MAAM,MAAM;AACZ,KAAK;AACL,IAAI,IAAI,EAAE,KAAK,EAAE,EAAE;AACnB,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;AAC1C,MAAM,MAAM,GAAG,GAAG,eAAe,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,KAAK,UAAU,EAAE,MAAM,CAAC,CAAC;AAC/F,MAAM,IAAI,GAAG,CAAC,EAAE,KAAK,IAAI,IAAI,CAAC,eAAe,EAAE;AAC/C,QAAQ,eAAe,GAAG;AAC1B,UAAU,GAAG;AACb,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,SAAS,CAAC;AACV,OAAO,MAAM;AACb,QAAQ,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC;AACtB,OAAO;AACP,MAAM,CAAC;AACP,QAAQ,GAAG;AACX,QAAQ,SAAS;AACjB,QAAQ,OAAO;AACf,OAAO,GAAG,GAAG,EAAE;AACf,MAAM,UAAU,GAAG,GAAG,CAAC;AACvB,KAAK,MAAM,IAAI,EAAE,KAAK,IAAI,IAAI,EAAE,KAAK,IAAI,EAAE;AAC3C,MAAM,EAAE,GAAG,CAAC;AACZ,MAAM,EAAE,OAAO,CAAC;AAChB,MAAM,SAAS,GAAG,GAAG,CAAC;AACtB,KAAK,MAAM,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;AACvC,MAAM,IAAI,IAAI,KAAK,UAAU,EAAE;AAC/B,QAAQ,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC;AACnD,QAAQ,EAAE,GAAG,CAAC;AACd,QAAQ,IAAI,EAAE,KAAK,EAAE,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;AACvD,UAAU,EAAE,GAAG,CAAC;AAChB,SAAS;AACT,QAAQ,EAAE,OAAO,CAAC;AAClB,QAAQ,UAAU,GAAG,SAAS,GAAG,GAAG,CAAC;AACrC,OAAO,MAAM;AACb,QAAQ,MAAM,CAAC,YAAY,CAAC,UAAU,EAAE,gBAAgB,EAAE,cAAc,CAAC,CAAC;AAC1E,OAAO;AACP,KAAK,MAAM;AACX,MAAM,EAAE,GAAG,CAAC;AACZ,KAAK;AACL,GAAG;AACH,EAAE,OAAO;AACT,IAAI,GAAG;AACP,IAAI,GAAG,EAAE,GAAG;AACZ,IAAI,eAAe;AACnB,IAAI,SAAS;AACb,IAAI,OAAO;AACX,IAAI,eAAe,EAAE,CAAC,CAAC,eAAe;AACtC,GAAG,CAAC;AACJ,CAAC;AACD,SAAS,WAAW,CAAC,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;AAC3C,EAAE,IAAI,IAAI,KAAK,UAAU,EAAE;AAC3B,IAAI,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC;AACvE,GAAG;AACH,EAAE,OAAO,EAAE,MAAM,IAAI,KAAK,QAAQ,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;AAC9C,CAAC;AACD,SAAS,eAAe,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE;AAC7E,EAAE,MAAM,cAAc,GAAG,CAAC,UAAU,CAAC;AACrC,EAAE,GAAG,EAAE,CAAC;AACR,EAAE,MAAM,GAAG,GAAG,CAAC,GAAG,MAAM;AACxB,IAAI,GAAG;AACP,IAAI,EAAE,EAAE,GAAG;AACX,IAAI,SAAS;AACb,IAAI,OAAO;AACX,GAAG,CAAC,CAAC;AACL,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC;AACrC,EAAE,QAAQ,EAAE;AACZ,IAAI,KAAK,GAAG;AACZ,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACvB,IAAI,KAAK,GAAG;AACZ,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACvB,IAAI,KAAK,GAAG,EAAE;AACd,MAAM,IAAI,KAAK,CAAC;AAChB,MAAM,CAAC;AACP,QAAQ,IAAI,EAAE,KAAK;AACnB,QAAQ,GAAG;AACX,OAAO,GAAG,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,cAAc,EAAE,MAAM,CAAC,EAAE;AACzF,MAAM,OAAO,GAAG,CAAC,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;AACrE,KAAK;AACL,IAAI,KAAK,GAAG,EAAE;AACd,MAAM,IAAI,KAAK,CAAC;AAChB,MAAM,CAAC;AACP,QAAQ,IAAI,EAAE,KAAK;AACnB,QAAQ,GAAG;AACX,OAAO,GAAG,aAAa,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,MAAM,CAAC,EAAE;AACjF,MAAM,OAAO,GAAG,CAAC,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;AACtE,KAAK;AACL,IAAI,KAAK,GAAG;AACZ,MAAM,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;AACtB,IAAI,KAAK,EAAE;AACX,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACvB,IAAI,KAAK,GAAG;AACZ,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACvB,IAAI,KAAK,GAAG;AACZ,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACvB,IAAI,KAAK,EAAE;AACX,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;AACxC,QAAQ,EAAE,GAAG,CAAC;AACd,OAAO;AACP,IAAI,KAAK,EAAE;AACX,MAAM,SAAS,GAAG,GAAG,CAAC;AACtB,MAAM,EAAE,OAAO,CAAC;AAChB,IAAI,KAAK,IAAI,CAAC;AACd,IAAI,KAAK,IAAI;AACb,MAAM,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC;AACrB,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,KAAK,EAAE;AACX,MAAM,IAAI,UAAU,EAAE;AACtB,QAAQ,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACzB,OAAO,MAAM;AACb,QAAQ,MAAM,CAAC,mBAAmB,CAAC,GAAG,GAAG,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AAChE,OAAO;AACP,IAAI;AACJ,MAAM,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;AAChC,QAAQ,MAAM,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;AACjC,QAAQ,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AACtE,QAAQ,IAAI,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAChC,QAAQ,IAAI,KAAK,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC1C,QAAQ,IAAI,KAAK,GAAG,GAAG,EAAE;AACzB,UAAU,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAC3C,UAAU,KAAK,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,GAAG,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;AACnC,QAAQ,MAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC3C,QAAQ,IAAI,QAAQ,KAAK,GAAG,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AAC5D,UAAU,IAAI,UAAU,EAAE;AAC1B,YAAY,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AAC7B,WAAW,MAAM;AACjB,YAAY,MAAM,CAAC,mBAAmB,CAAC,QAAQ,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AACrE,WAAW;AACX,SAAS;AACT,QAAQ,OAAO,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/C,OAAO;AACP,MAAM,OAAO,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1C,GAAG;AACH,CAAC;AACD,SAAS,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,cAAc,EAAE,MAAM,EAAE;AAC5F,EAAE,MAAM,UAAU,GAAG,GAAG,CAAC;AACzB,EAAE,IAAI,CAAC,CAAC;AACR,EAAE,CAAC;AACH,IAAI,CAAC;AACL,IAAI,GAAG;AACP,GAAG,GAAG,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,cAAc,CAAC,EAAE;AAClG,EAAE,IAAI,CAAC,KAAK,IAAI,EAAE;AAClB,IAAI,IAAI,cAAc,EAAE;AACxB,MAAM,MAAM,CAAC,qBAAqB,CAAC,UAAU,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AACnE,KAAK,MAAM;AACX,MAAM,GAAG,GAAG,UAAU,GAAG,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,OAAO;AACT,IAAI,IAAI,EAAE,CAAC;AACX,IAAI,GAAG;AACP,GAAG,CAAC;AACJ,CAAC;AACD,SAAS,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,QAAQ,EAAE,iBAAiB,EAAE,MAAM,EAAE,WAAW,EAAE;AAC/G,EAAE,MAAM,KAAK,GAAG,GAAG,CAAC;AACpB,EAAE,MAAM,iBAAiB,GAAG,KAAK,KAAK,EAAE,GAAG,iCAAiC,CAAC,GAAG,GAAG,iCAAiC,CAAC,SAAS,CAAC;AAC/H,EAAE,MAAM,gBAAgB,GAAG,KAAK,KAAK,EAAE,GAAG,gCAAgC,CAAC,GAAG,GAAG,KAAK,KAAK,EAAE,GAAG,gCAAgC,CAAC,GAAG,GAAG,KAAK,KAAK,CAAC,GAAG,gCAAgC,CAAC,GAAG,GAAG,gCAAgC,CAAC,GAAG,CAAC;AACjO,EAAE,IAAI,OAAO,GAAG,KAAK,CAAC;AACtB,EAAE,IAAI,KAAK,GAAG,CAAC,CAAC;AAChB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,IAAI,IAAI,GAAG,QAAQ,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;AAChE,IAAI,MAAM,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACxC,IAAI,IAAI,GAAG,CAAC;AACZ,IAAI,IAAI,KAAK,KAAK,EAAE,IAAI,iBAAiB,KAAK,MAAM,EAAE;AACtD,MAAM,MAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC7C,MAAM,MAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC7C,MAAM,IAAI,CAAC,iBAAiB,EAAE;AAC9B,QAAQ,IAAI,WAAW;AACvB,UAAU,OAAO;AACjB,YAAY,CAAC,EAAE,IAAI;AACnB,YAAY,GAAG;AACf,WAAW,CAAC;AACZ,QAAQ,MAAM,CAAC,gCAAgC,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AACzE,OAAO,MAAM,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AAC9H,QAAQ,IAAI,WAAW;AACvB,UAAU,OAAO;AACjB,YAAY,CAAC,EAAE,IAAI;AACnB,YAAY,GAAG;AACf,WAAW,CAAC;AACZ,QAAQ,MAAM,CAAC,0BAA0B,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AACnE,OAAO;AACP,MAAM,EAAE,GAAG,CAAC;AACZ,MAAM,SAAS;AACf,KAAK;AACL,IAAI,IAAI,KAAK,IAAI,EAAE,EAAE;AACrB,MAAM,GAAG,GAAG,KAAK,GAAG,EAAE,GAAG,EAAE,CAAC;AAC5B,KAAK,MAAM,IAAI,KAAK,IAAI,EAAE,EAAE;AAC5B,MAAM,GAAG,GAAG,KAAK,GAAG,EAAE,GAAG,EAAE,CAAC;AAC5B,KAAK,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE;AAChC,MAAM,GAAG,GAAG,KAAK,GAAG,EAAE,CAAC;AACvB,KAAK,MAAM;AACX,MAAM,GAAG,GAAG,QAAQ,CAAC;AACrB,KAAK;AACL,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE;AACtB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,WAAW,EAAE;AACnC,QAAQ,OAAO;AACf,UAAU,CAAC,EAAE,IAAI;AACjB,UAAU,GAAG;AACb,SAAS,CAAC;AACV,OAAO,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE;AAClF,QAAQ,GAAG,GAAG,CAAC,CAAC;AAChB,OAAO,MAAM,IAAI,QAAQ,EAAE;AAC3B,QAAQ,GAAG,GAAG,CAAC,CAAC;AAChB,QAAQ,OAAO,GAAG,IAAI,CAAC;AACvB,OAAO,MAAM;AACb,QAAQ,MAAM;AACd,OAAO;AACP,KAAK;AACL,IAAI,EAAE,GAAG,CAAC;AACV,IAAI,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG,CAAC;AAChC,GAAG;AACH,EAAE,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,GAAG,IAAI,OAAO,EAAE;AACtE,IAAI,OAAO;AACX,MAAM,CAAC,EAAE,IAAI;AACb,MAAM,GAAG;AACT,KAAK,CAAC;AACN,GAAG;AACH,EAAE,OAAO;AACT,IAAI,CAAC,EAAE,KAAK;AACZ,IAAI,GAAG;AACP,GAAG,CAAC;AACJ,CAAC;AACD,SAAS,aAAa,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,MAAM,EAAE;AAC/E,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACnC,EAAE,IAAI,KAAK,CAAC;AACZ,EAAE,IAAI,EAAE,KAAK,GAAG,EAAE;AAClB,IAAI,EAAE,GAAG,CAAC;AACV,IAAI,CAAC;AACL,MAAM,IAAI,EAAE,KAAK;AACjB,MAAM,GAAG;AACT,KAAK,GAAG,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,EAAE,IAAI,EAAE,cAAc,EAAE,MAAM,CAAC,EAAE;AAClH,IAAI,EAAE,GAAG,CAAC;AACV,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,GAAG,OAAO,EAAE;AAC3C,MAAM,IAAI,cAAc,EAAE;AAC1B,QAAQ,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AACzD,OAAO,MAAM;AACb,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,IAAI;AACpB,UAAU,GAAG;AACb,SAAS,CAAC;AACV,OAAO;AACP,KAAK;AACL,GAAG,MAAM;AACT,IAAI,CAAC;AACL,MAAM,IAAI,EAAE,KAAK;AACjB,MAAM,GAAG;AACT,KAAK,GAAG,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,cAAc,EAAE,MAAM,CAAC,EAAE;AACvF,GAAG;AACH,EAAE,OAAO;AACT,IAAI,IAAI,EAAE,KAAK;AACf,IAAI,GAAG;AACP,GAAG,CAAC;AACJ,CAAC;AACD,SAAS,aAAa,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE;AAChD,EAAE,OAAO,IAAI,QAAQ,CAAC,OAAO,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,CAAC,CAAC;AACrD,CAAC;AACD,MAAM,iBAAiB,GAAG,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AAC5F,MAAM,KAAK,CAAC;AACZ,EAAE,WAAW,CAAC,KAAK,EAAE;AACrB,IAAI,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;AAC3B,IAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AAC7B,IAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AAC7B,IAAI,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;AACzB,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,cAAc,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;AAChE,GAAG;AACH,CAAC;AACD,MAAM,SAAS,SAAS,cAAc,CAAC;AACvC,EAAE,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE;AAC9B,IAAI,KAAK,EAAE,CAAC;AACZ,IAAI,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC;AAC9B,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,qBAAqB,GAAG;AACjC,MAAM,YAAY,EAAE,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,KAAK;AACxD,QAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa;AACvC,UAAU,OAAO,KAAK,CAAC;AACvB,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,EAAE,aAAa,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE;AAChF,UAAU,KAAK;AACf,SAAS,CAAC,CAAC;AACX,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,MAAM,gCAAgC,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,gCAAgC,CAAC;AAClG,MAAM,0BAA0B,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,0BAA0B,CAAC;AACtF,KAAK,CAAC;AACN,IAAI,IAAI,CAAC,2BAA2B,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,qBAAqB,EAAE;AACrF,MAAM,qBAAqB,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,qBAAqB,CAAC;AAC5E,MAAM,gBAAgB,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,gBAAgB,CAAC;AAClE,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,uCAAuC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,2BAA2B,EAAE;AACvG,MAAM,mBAAmB,EAAE,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,KAAK;AACxD,QAAQ,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,mBAAmB,EAAE,aAAa,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;AACxG,OAAO;AACP,MAAM,YAAY,EAAE,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,KAAK;AACjD,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,EAAE,aAAa,CAAC,GAAG,GAAG,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;AAChG,OAAO;AACP,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,yCAAyC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,2BAA2B,EAAE;AACzG,MAAM,mBAAmB,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,mBAAmB,CAAC;AACxE,MAAM,YAAY,EAAE,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,KAAK;AACjD,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,EAAE,aAAa,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;AAC9F,OAAO;AACP,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;AAC7B,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC7B,IAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;AAC/B,IAAI,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;AACvB,IAAI,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;AAC7B,GAAG;AACH,EAAE,SAAS,CAAC,KAAK,EAAE;AACnB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC;AACjD,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC5B,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC;AAC9B,GAAG;AACH,EAAE,IAAI,GAAG;AACT,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;AAC/B,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AAC7B,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AAC5C,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACjD,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACrD,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,GAAG;AACH,EAAE,GAAG,CAAC,IAAI,EAAE;AACZ,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC1B,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC;AAClB,KAAK,MAAM;AACX,MAAM,OAAO,KAAK,CAAC;AACnB,KAAK;AACL,GAAG;AACH,EAAE,KAAK,CAAC,IAAI,EAAE;AACd,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC;AACpC,GAAG;AACH,EAAE,oBAAoB,CAAC,KAAK,EAAE;AAC9B,IAAI,OAAO;AACX,MAAM,GAAG,EAAE,KAAK,CAAC,GAAG;AACpB,MAAM,KAAK,EAAE,IAAI;AACjB,MAAM,IAAI,EAAE,KAAK,CAAC,IAAI;AACtB,MAAM,KAAK,EAAE,KAAK,CAAC,KAAK;AACxB,MAAM,GAAG,EAAE,KAAK,CAAC,GAAG;AACpB,MAAM,OAAO,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;AAClC,MAAM,MAAM,EAAE,KAAK,CAAC,MAAM;AAC1B,MAAM,QAAQ,EAAE,KAAK,CAAC,QAAQ;AAC9B,MAAM,aAAa,EAAE,KAAK,CAAC,aAAa;AACxC,MAAM,OAAO,EAAE,KAAK,CAAC,OAAO;AAC5B,MAAM,SAAS,EAAE,KAAK,CAAC,SAAS;AAChC,MAAM,WAAW,EAAE,KAAK,CAAC,WAAW;AACpC,KAAK,CAAC;AACN,GAAG;AACH,EAAE,SAAS,GAAG;AACd,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;AAC3B,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC;AAChD,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;AAC5B,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;AAC7B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;AAC5B,IAAI,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC;AACrB,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,cAAc,GAAG;AACnB,IAAI,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACpD,GAAG;AACH,EAAE,mBAAmB,CAAC,GAAG,EAAE;AAC3B,IAAI,cAAc,CAAC,SAAS,GAAG,GAAG,CAAC;AACnC,IAAI,OAAO,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,cAAc,CAAC,SAAS,GAAG,GAAG,CAAC;AAC5E,GAAG;AACH,EAAE,iBAAiB,GAAG;AACtB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;AACxD,GAAG;AACH,EAAE,oBAAoB,GAAG;AACzB,IAAI,OAAO,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC1D,GAAG;AACH,EAAE,yBAAyB,CAAC,GAAG,EAAE;AACjC,IAAI,oBAAoB,CAAC,SAAS,GAAG,GAAG,CAAC;AACzC,IAAI,OAAO,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,oBAAoB,CAAC,SAAS,GAAG,GAAG,CAAC;AACxF,GAAG;AACH,EAAE,uBAAuB,GAAG;AAC5B,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC;AAC9D,GAAG;AACH,EAAE,cAAc,CAAC,GAAG,EAAE;AACtB,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACxC,IAAI,IAAI,CAAC,EAAE,GAAG,KAAK,MAAM,KAAK,IAAI,EAAE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AAC7D,MAAM,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC/C,MAAM,IAAI,CAAC,KAAK,GAAG,KAAK,MAAM,KAAK,EAAE;AACrC,QAAQ,EAAE,GAAG,KAAK,IAAI,CAAC,EAAE,GAAG,IAAI,KAAK,EAAE,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC;AAC1D,OAAO;AACP,KAAK;AACL,IAAI,OAAO,EAAE,CAAC;AACd,GAAG;AACH,EAAE,SAAS,CAAC,MAAM,EAAE;AACpB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;AAC/B,IAAI,IAAI,MAAM,EAAE;AAChB,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC,CAAC;AAC5F,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;AACtC,KAAK;AACL,GAAG;AACH,EAAE,UAAU,GAAG;AACf,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC7D,GAAG;AACH,EAAE,SAAS,GAAG;AACd,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACtC,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW;AACzB,MAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AACrD,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE;AACvC,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;AAC5B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/D,GAAG;AACH,EAAE,gBAAgB,CAAC,UAAU,EAAE;AAC/B,IAAI,IAAI,QAAQ,CAAC;AACjB,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW;AACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AAC1C,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACjC,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;AAC1D,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE;AACpB,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,mBAAmB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC7E,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC;AAC7C,IAAI,UAAU,CAAC,SAAS,GAAG,KAAK,GAAG,CAAC,CAAC;AACrC,IAAI,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,SAAS,IAAI,GAAG,EAAE;AACvE,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;AAC3B,MAAM,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;AAClD,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,WAAW;AACxB,MAAM,OAAO;AACb,IAAI,MAAM,OAAO,GAAG;AACpB,MAAM,IAAI,EAAE,cAAc;AAC1B,MAAM,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC;AAC7C,MAAM,KAAK;AACX,MAAM,GAAG,EAAE,GAAG,GAAG,UAAU,CAAC,MAAM;AAClC,MAAM,GAAG,EAAE,IAAI,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AACjE,KAAK,CAAC;AACN,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;AAC3B,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AAC9B,IAAI,OAAO,OAAO,CAAC;AACnB,GAAG;AACH,EAAE,eAAe,CAAC,SAAS,EAAE;AAC7B,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACjC,IAAI,IAAI,QAAQ,CAAC;AACjB,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW;AACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AAC1C,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,SAAS,CAAC,CAAC;AAChE,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AACtC,MAAM,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AAC/D,QAAQ,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACnD,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,WAAW;AACxB,MAAM,OAAO;AACb,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC/B,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,EAAE,GAAG,CAAC,CAAC;AAC3D,IAAI,MAAM,OAAO,GAAG;AACpB,MAAM,IAAI,EAAE,aAAa;AACzB,MAAM,KAAK;AACX,MAAM,KAAK;AACX,MAAM,GAAG;AACT,MAAM,GAAG,EAAE,IAAI,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AACjE,KAAK,CAAC;AACN,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;AAC3B,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AAC9B,IAAI,OAAO,OAAO,CAAC;AACnB,GAAG;AACH,EAAE,SAAS,GAAG;AACd,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACtC,IAAI,MAAM,QAAQ,GAAG,EAAE,CAAC;AACxB,IAAI,IAAI;AACR,MAAM,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AAC3C,QAAQ,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACzD,QAAQ,QAAQ,EAAE;AAClB,UAAU,KAAK,EAAE,CAAC;AAClB,UAAU,KAAK,GAAG,CAAC;AACnB,UAAU,KAAK,CAAC;AAChB,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC7B,YAAY,MAAM;AAClB,UAAU,KAAK,EAAE;AACjB,YAAY,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AAClE,cAAc,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC/B,aAAa;AACb,UAAU,KAAK,EAAE,CAAC;AAClB,UAAU,KAAK,IAAI,CAAC;AACpB,UAAU,KAAK,IAAI;AACnB,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC7B,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;AACjC,YAAY,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAClD,YAAY,MAAM;AAClB,UAAU,KAAK,EAAE;AACjB,YAAY,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AAC7D,cAAc,KAAK,EAAE,EAAE;AACvB,gBAAgB,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAC5D,gBAAgB,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;AACxC,kBAAkB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAC3C,kBAAkB,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa;AAChD,oBAAoB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3C,iBAAiB;AACjB,gBAAgB,MAAM;AACtB,eAAe;AACf,cAAc,KAAK,EAAE,EAAE;AACvB,gBAAgB,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AACxD,gBAAgB,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;AACxC,kBAAkB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAC3C,kBAAkB,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa;AAChD,oBAAoB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3C,iBAAiB;AACjB,gBAAgB,MAAM;AACtB,eAAe;AACf,cAAc;AACd,gBAAgB,MAAM,IAAI,CAAC;AAC3B,aAAa;AACb,YAAY,MAAM;AAClB,UAAU;AACV,YAAY,IAAI,YAAY,CAAC,EAAE,CAAC,EAAE;AAClC,cAAc,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC/B,aAAa,MAAM,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AAC3E,cAAc,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,UAAU,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,UAAU,CAAC,EAAE;AAC7J,gBAAgB,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AACxD,gBAAgB,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;AACxC,kBAAkB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAC3C,kBAAkB,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa;AAChD,oBAAoB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3C,iBAAiB;AACjB,eAAe,MAAM;AACrB,gBAAgB,MAAM,IAAI,CAAC;AAC3B,eAAe;AACf,aAAa,MAAM,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AAC3E,cAAc,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AAC3I,gBAAgB,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AACxD,gBAAgB,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE;AACxC,kBAAkB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAC3C,kBAAkB,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa;AAChD,oBAAoB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3C,iBAAiB;AACjB,eAAe,MAAM;AACrB,gBAAgB,MAAM,IAAI,CAAC;AAC3B,eAAe;AACf,aAAa,MAAM;AACnB,cAAc,MAAM,IAAI,CAAC;AACzB,aAAa;AACb,SAAS;AACT,OAAO;AACP,IAAI,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7B,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACjC,MAAM,MAAM,iBAAiB,GAAG;AAChC,QAAQ,KAAK,EAAE,UAAU;AACzB,QAAQ,GAAG;AACX,QAAQ,QAAQ;AAChB,QAAQ,WAAW,EAAE,IAAI;AACzB,QAAQ,YAAY,EAAE,IAAI;AAC1B,QAAQ,cAAc,EAAE,IAAI;AAC5B,OAAO,CAAC;AACR,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;AACtD,KAAK;AACL,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,GAAG,EAAE;AACzB,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACpC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AACjD,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;AACrC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;AAC3B,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC;AAC3B,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;AAC3B,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AACnC,KAAK;AACL,GAAG;AACH,EAAE,YAAY,CAAC,IAAI,EAAE;AACrB,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;AAC3B,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;AACzB,GAAG;AACH,EAAE,oBAAoB,GAAG;AACzB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC,qBAAqB,EAAE,EAAE;AAC9D,MAAM,OAAO;AACb,KAAK;AACL,IAAI,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AACvC,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;AAC9C,IAAI,IAAI,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,EAAE;AAClC,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,wBAAwB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAClF,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,EAAE;AACzE,MAAM,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC;AAC1C,MAAM,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;AAC1E,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,GAAG,GAAG,MAAM,CAAC,4CAA4C,GAAG,MAAM,CAAC,2CAA2C,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC5K,OAAO;AACP,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AACxB,QAAQ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC5B,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC5B,OAAO;AACP,KAAK,MAAM,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;AACxC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;AAClD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,EAAE;AAC5B,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;AAC9C,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,aAAa,GAAG;AAClB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,EAAE;AAClC,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAC5B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AACzE,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC3B,KAAK,MAAM;AACX,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,eAAe,GAAG;AACpB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,qBAAqB,GAAG;AAC1B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;AAC/C,MAAM,OAAO,KAAK,CAAC;AACnB,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACvD,IAAI,IAAI,EAAE,KAAK,EAAE;AACjB,MAAM,OAAO,KAAK,CAAC;AACnB,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACjC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AACxB,IAAI,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AAC7D,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC9D,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AAChC,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,qBAAqB,CAAC,KAAK,EAAE;AAC/B,IAAI,IAAI,IAAI,GAAG,KAAK,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AACtC,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC;AAClB,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACzD,IAAI,IAAI,KAAK,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AACrC,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACvD,MAAM,IAAI,GAAG,EAAE,CAAC;AAChB,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AAC3C,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,IAAI,GAAG,KAAK,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AACpC,KAAK;AACL,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC/B,GAAG;AACH,EAAE,kBAAkB,CAAC,KAAK,EAAE;AAC5B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;AACxB,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AAC5D,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;AAClD,OAAO;AACP,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,KAAK,KAAK,GAAG,EAAE;AACvB,MAAM,IAAI,IAAI,KAAK,EAAE,EAAE;AACvB,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,IAAI,KAAK,GAAG,EAAE;AAC5D,QAAQ,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;AAC5E,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,yCAAyC,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AACvG,SAAS;AACT,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC5B,QAAQ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC5B,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,IAAI,KAAK,EAAE,EAAE;AAC3D,QAAQ,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;AAC5E,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,wCAAwC,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AACtG,SAAS;AACT,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC5B,QAAQ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC5B,QAAQ,OAAO;AACf,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;AAC9C,GAAG;AACH,EAAE,eAAe,GAAG;AACpB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AAC3C,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,kBAAkB,EAAE;AAClE,MAAM,QAAQ,EAAE,MAAM;AACtB,MAAM,UAAU,EAAE,IAAI;AACtB,KAAK,CAAC,CAAC,EAAE;AACT,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAM,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACjE,MAAM,IAAI,WAAW,KAAK,EAAE,EAAE;AAC9B,QAAQ,IAAI,CAAC,UAAU,EAAE,CAAC;AAC1B,OAAO;AACP,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,gBAAgB,GAAG;AACrB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,kBAAkB,EAAE;AAC3D,MAAM,QAAQ,EAAE,MAAM;AACtB,MAAM,UAAU,EAAE,IAAI;AACtB,KAAK,CAAC,CAAC,EAAE;AACT,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,kBAAkB,CAAC,KAAK,EAAE;AAC5B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;AACxB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,YAAY,GAAG;AACjB,IAAI,MAAM;AACV,MAAM,GAAG;AACT,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAChD,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AACjD,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AACzB,GAAG;AACH,EAAE,YAAY,GAAG;AACjB,IAAI,MAAM;AACV,MAAM,GAAG;AACT,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAChD,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;AACjE,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE;AACpD,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;AACpC,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AAC9B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AACzB,GAAG;AACH,EAAE,iBAAiB,CAAC,KAAK,EAAE;AAC3B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAClF,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,KAAK,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AACrC,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC3B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7C,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC5D,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE;AACrB,MAAM,IAAI,KAAK,KAAK,EAAE,EAAE;AACxB,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,OAAO;AACP,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,IAAI,EAAE,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,CAAC,EAAE;AAC7D,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC3B,KAAK,MAAM;AACX,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC3B,KAAK;AACL,GAAG;AACH,EAAE,gBAAgB,CAAC,KAAK,EAAE;AAC1B,IAAI,QAAQ,KAAK;AACjB,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,aAAa,EAAE,CAAC;AAC7B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;AACnG,UAAU,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;AAC9E,YAAY,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,0CAA0C,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC1G,WAAW;AACX,UAAU,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC9B,UAAU,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9B,SAAS,MAAM;AACf,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC3B,UAAU,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9B,SAAS;AACT,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC5B,QAAQ,OAAO;AACf,MAAM,KAAK,GAAG;AACd,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;AACnG,UAAU,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;AAC9E,YAAY,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,2CAA2C,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC3G,WAAW;AACX,UAAU,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC9B,UAAU,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9B,SAAS,MAAM;AACf,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC3B,UAAU,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9B,SAAS;AACT,QAAQ,OAAO;AACf,MAAM,KAAK,GAAG;AACd,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC5B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;AAChG,UAAU,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC/B,SAAS,MAAM;AACf,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AAC3B,UAAU,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AAC/B,SAAS;AACT,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAClC,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACjC,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE,EAAE;AACf,QAAQ,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC/D,QAAQ,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,EAAE,EAAE;AACzC,UAAU,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;AACnC,UAAU,OAAO;AACjB,SAAS;AACT,QAAQ,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,EAAE,EAAE;AACzC,UAAU,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AAClC,UAAU,OAAO;AACjB,SAAS;AACT,QAAQ,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AACxC,UAAU,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AAClC,UAAU,OAAO;AACjB,SAAS;AACT,OAAO;AACP,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AAC/B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AAC/B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,eAAe,EAAE,CAAC;AAC/B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;AAC1C,QAAQ,OAAO;AACf,MAAM,KAAK,GAAG,CAAC;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AACvC,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,eAAe,EAAE,CAAC;AAC/B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AACvC,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,YAAY,EAAE,CAAC;AAC5B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,YAAY,EAAE,CAAC;AAC5B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;AACtC,QAAQ,OAAO;AACf,MAAM,KAAK,GAAG;AACd,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,gBAAgB,EAAE,CAAC;AAChC,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,oBAAoB,EAAE,CAAC;AACpC,QAAQ,OAAO;AACf,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,QAAQ,EAAE,CAAC;AACxB,QAAQ,OAAO;AACf,MAAM;AACN,QAAQ,IAAI,iBAAiB,CAAC,KAAK,CAAC,EAAE;AACtC,UAAU,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC/B,UAAU,OAAO;AACjB,SAAS;AACT,KAAK;AACL,IAAI,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,wBAAwB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,EAAE;AAChF,MAAM,UAAU,EAAE,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC;AAC7C,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE;AACvB,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;AACxE,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC;AAC3B,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AAChC,GAAG;AACH,EAAE,UAAU,GAAG;AACf,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACzC,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;AACvC,IAAI,IAAI,OAAO,EAAE,OAAO,CAAC;AACzB,IAAI,IAAI;AACR,MAAM,GAAG;AACT,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,SAAS,EAAE,GAAG,EAAE;AACpB,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,EAAE,8BAA8B,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AACjG,OAAO;AACP,MAAM,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC5C,MAAM,IAAI,SAAS,CAAC,EAAE,CAAC,EAAE;AACzB,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,kBAAkB,EAAE,8BAA8B,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AACjG,OAAO;AACP,MAAM,IAAI,OAAO,EAAE;AACnB,QAAQ,OAAO,GAAG,KAAK,CAAC;AACxB,OAAO,MAAM;AACb,QAAQ,IAAI,EAAE,KAAK,EAAE,EAAE;AACvB,UAAU,OAAO,GAAG,IAAI,CAAC;AACzB,SAAS,MAAM,IAAI,EAAE,KAAK,EAAE,IAAI,OAAO,EAAE;AACzC,UAAU,OAAO,GAAG,KAAK,CAAC;AAC1B,SAAS,MAAM,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE;AAC1C,UAAU,MAAM;AAChB,SAAS;AACT,QAAQ,OAAO,GAAG,EAAE,KAAK,EAAE,CAAC;AAC5B,OAAO;AACP,KAAK;AACL,IAAI,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AACjD,IAAI,EAAE,GAAG,CAAC;AACV,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;AAClB,IAAI,MAAM,OAAO,GAAG,MAAM,8BAA8B,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC;AACpF,IAAI,OAAO,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AAC9B,MAAM,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;AAC1C,MAAM,MAAM,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;AAC3C,MAAM,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACrC,QAAQ,IAAI,EAAE,KAAK,GAAG,EAAE;AACxB,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AAClC,YAAY,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,yBAAyB,EAAE,OAAO,EAAE,CAAC,CAAC;AACpE,WAAW;AACX,SAAS,MAAM,IAAI,EAAE,KAAK,GAAG,EAAE;AAC/B,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AAClC,YAAY,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,yBAAyB,EAAE,OAAO,EAAE,CAAC,CAAC;AACpE,WAAW;AACX,SAAS;AACT,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACjC,UAAU,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,EAAE,OAAO,EAAE,CAAC,CAAC;AAC7D,SAAS;AACT,OAAO,MAAM,IAAI,gBAAgB,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;AACpD,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,EAAE,OAAO,EAAE,CAAC,CAAC;AAC3D,OAAO,MAAM;AACb,QAAQ,MAAM;AACd,OAAO;AACP,MAAM,EAAE,GAAG,CAAC;AACZ,MAAM,IAAI,IAAI,IAAI,CAAC;AACnB,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AACzB,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE;AAC1B,MAAM,OAAO,EAAE,OAAO;AACtB,MAAM,KAAK,EAAE,IAAI;AACjB,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE,QAAQ,GAAG,KAAK,EAAE,iBAAiB,GAAG,IAAI,EAAE;AAClE,IAAI,MAAM;AACV,MAAM,CAAC;AACP,MAAM,GAAG;AACT,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,QAAQ,EAAE,iBAAiB,EAAE,IAAI,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC;AAClK,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AACzB,IAAI,OAAO,CAAC,CAAC;AACb,GAAG;AACH,EAAE,eAAe,CAAC,KAAK,EAAE;AACzB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AAC9C,IAAI,IAAI,QAAQ,GAAG,KAAK,CAAC;AACzB,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AACxB,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACpC,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE;AACrB,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,EAAE,8BAA8B,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE;AACnF,QAAQ,KAAK;AACb,OAAO,CAAC,CAAC;AACT,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACvD,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE;AACtB,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,QAAQ,GAAG,IAAI,CAAC;AACtB,KAAK,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AAC7B,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,IAAI,iBAAiB,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;AAChE,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC1E,KAAK;AACL,IAAI,IAAI,QAAQ,EAAE;AAClB,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;AACxF,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACjC,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAC/B,GAAG;AACH,EAAE,UAAU,CAAC,aAAa,EAAE;AAC5B,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACjC,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AAC9C,IAAI,IAAI,OAAO,GAAG,KAAK,CAAC;AACxB,IAAI,IAAI,QAAQ,GAAG,KAAK,CAAC;AACzB,IAAI,IAAI,SAAS,GAAG,KAAK,CAAC;AAC1B,IAAI,IAAI,WAAW,GAAG,KAAK,CAAC;AAC5B,IAAI,IAAI,OAAO,GAAG,KAAK,CAAC;AACxB,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;AACrD,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AACjE,KAAK;AACL,IAAI,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;AAC9F,IAAI,IAAI,cAAc,EAAE;AACxB,MAAM,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC9D,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,kBAAkB,EAAE,QAAQ,CAAC,CAAC;AACvE,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,aAAa,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACnD,QAAQ,IAAI,aAAa,GAAG,CAAC,EAAE;AAC/B,UAAU,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,yBAAyB,EAAE,8BAA8B,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC,CAAC;AAChH,SAAS;AACT,OAAO;AACP,MAAM,OAAO,GAAG,cAAc,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACrD,IAAI,IAAI,IAAI,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE;AACjC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;AACvB,MAAM,OAAO,GAAG,IAAI,CAAC;AACrB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,IAAI,CAAC,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,OAAO,EAAE;AACnD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACrD,MAAM,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AACtC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;AACrC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,wBAAwB,EAAE,QAAQ,CAAC,CAAC;AAC9D,OAAO;AACP,MAAM,OAAO,GAAG,IAAI,CAAC;AACrB,MAAM,WAAW,GAAG,IAAI,CAAC;AACzB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE;AACtB,MAAM,IAAI,OAAO,IAAI,cAAc,EAAE;AACrC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,EAAE,QAAQ,CAAC,CAAC;AAC1D,OAAO;AACP,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,QAAQ,GAAG,IAAI,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE;AACtB,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC7D,MAAM,IAAI,WAAW,IAAI,cAAc,EAAE;AACzC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;AACpD,OAAO;AACP,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,SAAS,GAAG,IAAI,CAAC;AACvB,KAAK;AACL,IAAI,IAAI,iBAAiB,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;AAChE,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC1E,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAC9E,IAAI,IAAI,QAAQ,EAAE;AAClB,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACjC,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,SAAS,EAAE;AACnB,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACjC,MAAM,OAAO;AACb,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,OAAO,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;AAC7D,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAC/B,GAAG;AACH,EAAE,aAAa,CAAC,cAAc,EAAE;AAChC,IAAI,MAAM;AACV,MAAM,IAAI,EAAE,KAAK;AACjB,MAAM,GAAG;AACT,KAAK,GAAG,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,cAAc,EAAE,IAAI,CAAC,2BAA2B,CAAC,CAAC;AAC9I,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AACzB,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,UAAU,CAAC,KAAK,EAAE;AACpB,IAAI,MAAM;AACV,MAAM,GAAG;AACT,MAAM,GAAG;AACT,MAAM,OAAO;AACb,MAAM,SAAS;AACf,KAAK,GAAG,kBAAkB,CAAC,KAAK,KAAK,EAAE,GAAG,QAAQ,GAAG,QAAQ,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,uCAAuC,CAAC,CAAC;AACvL,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AAC7B,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;AACrC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;AACjC,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAC/B,GAAG;AACH,EAAE,wBAAwB,GAAG;AAC7B,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AAC/B,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC7B,GAAG;AACH,EAAE,iBAAiB,GAAG;AACtB,IAAI,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC/C,IAAI,MAAM;AACV,MAAM,GAAG;AACT,MAAM,eAAe;AACrB,MAAM,GAAG;AACT,MAAM,OAAO;AACb,MAAM,SAAS;AACf,KAAK,GAAG,kBAAkB,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,yCAAyC,CAAC,CAAC;AACjK,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AAC7B,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;AACrC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;AACjC,IAAI,IAAI,eAAe,EAAE;AACzB,MAAM,IAAI,CAAC,KAAK,CAAC,6BAA6B,GAAG,IAAI,QAAQ,CAAC,eAAe,CAAC,OAAO,EAAE,eAAe,CAAC,GAAG,GAAG,eAAe,CAAC,SAAS,EAAE,eAAe,CAAC,GAAG,CAAC,CAAC;AAC7J,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;AAC5C,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,eAAe,GAAG,IAAI,GAAG,OAAO,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AACzE,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AACvB,MAAM,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,eAAe,GAAG,IAAI,GAAG,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;AAC1E,KAAK;AACL,GAAG;AACH,EAAE,sBAAsB,CAAC,YAAY,EAAE,EAAE,EAAE;AAC3C,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC;AAC3B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;AAClE,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AACnC,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7D,KAAK;AACL,GAAG;AACH,EAAE,SAAS,CAAC,SAAS,EAAE;AACvB,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC;AACnC,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;AAClB,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACjC,IAAI,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACpC,IAAI,IAAI,SAAS,KAAK,KAAK,CAAC,EAAE;AAC9B,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,SAAS,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AACzC,MAAM,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACrD,MAAM,IAAI,gBAAgB,CAAC,EAAE,CAAC,EAAE;AAChC,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,EAAE,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;AAC9C,OAAO,MAAM,IAAI,EAAE,KAAK,EAAE,EAAE;AAC5B,QAAQ,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC;AACtC,QAAQ,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC7D,QAAQ,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AAClD,QAAQ,MAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,KAAK,GAAG,iBAAiB,GAAG,gBAAgB,CAAC;AAChG,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;AAC7D,UAAU,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC5E,UAAU,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AAC1C,UAAU,SAAS;AACnB,SAAS;AACT,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzB,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;AAC7C,QAAQ,IAAI,GAAG,KAAK,IAAI,EAAE;AAC1B,UAAU,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE;AACrC,YAAY,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,0BAA0B,EAAE,QAAQ,CAAC,CAAC;AACpE,WAAW;AACX,UAAU,IAAI,IAAI,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;AAC5C,SAAS;AACT,QAAQ,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACpC,OAAO,MAAM;AACb,QAAQ,MAAM;AACd,OAAO;AACP,KAAK;AACL,IAAI,OAAO,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC/D,GAAG;AACH,EAAE,QAAQ,CAAC,SAAS,EAAE;AACtB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;AAC3C,IAAI,MAAM,IAAI,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACtC,IAAI,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;AACzB,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;AACnD,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAClC,KAAK;AACL,GAAG;AACH,EAAE,mBAAmB,GAAG;AACxB,IAAI,MAAM;AACV,MAAM,IAAI;AACV,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;AACxD,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,0BAA0B,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AACzE,QAAQ,YAAY,EAAE,cAAc,CAAC,IAAI,CAAC;AAC1C,OAAO,CAAC,CAAC;AACT,KAAK;AACL,GAAG;AACH,EAAE,KAAK,CAAC,YAAY,EAAE,EAAE,EAAE,OAAO,GAAG,EAAE,EAAE;AACxC,IAAI,MAAM,GAAG,GAAG,EAAE,YAAY,QAAQ,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC;AAC3D,IAAI,MAAM,KAAK,GAAG,YAAY,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC7C,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa;AACnC,MAAM,MAAM,KAAK,CAAC;AAClB,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW;AACzB,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACpC,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,cAAc,CAAC,YAAY,EAAE,EAAE,EAAE,OAAO,GAAG,EAAE,EAAE;AACjD,IAAI,MAAM,GAAG,GAAG,EAAE,YAAY,QAAQ,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC;AAC3D,IAAI,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC;AAC1B,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACjD,MAAM,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC9B,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,KAAK,GAAG,EAAE;AACnC,QAAQ,OAAO,MAAM,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AACtD,OAAO;AACP,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG;AAC/B,QAAQ,MAAM;AACd,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,aAAa,CAAC,QAAQ,EAAE;AAC1B,GAAG;AACH,EAAE,UAAU,CAAC,GAAG,EAAE,IAAI,EAAE;AACxB,IAAI,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,eAAe,EAAE,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AACtF,MAAM,QAAQ,EAAE,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI;AAClD,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,YAAY,CAAC,UAAU,EAAE,GAAG,EAAE;AAChC,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;AACpC,MAAM,OAAO,IAAI,CAAC;AAClB,KAAK;AACL,IAAI,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AACpF,MAAM,aAAa,EAAE,CAAC,UAAU,CAAC;AACjC,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,eAAe,CAAC,WAAW,EAAE;AAC/B,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE;AAC3D,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,mBAAmB,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AACxE,QAAQ,aAAa,EAAE,WAAW;AAClC,OAAO,CAAC,CAAC;AACT,KAAK;AACL,GAAG;AACH,EAAE,YAAY,CAAC,KAAK,EAAE;AACtB,IAAI,OAAO,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,KAAK;AACxC,MAAM,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,aAAa,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;AAChE,KAAK,CAAC;AACN,GAAG;AACH,CAAC;AACD,MAAM,UAAU,CAAC;AACjB,EAAE,WAAW,GAAG;AAChB,IAAI,IAAI,CAAC,YAAY,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AAClD,IAAI,IAAI,CAAC,aAAa,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AACnD,IAAI,IAAI,CAAC,qBAAqB,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AAC3D,GAAG;AACH,CAAC;AACD,MAAM,iBAAiB,CAAC;AACxB,EAAE,WAAW,CAAC,MAAM,EAAE;AACtB,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;AACzB,IAAI,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,CAAC,qBAAqB,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AAC3D,IAAI,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,GAAG;AACH,EAAE,OAAO,GAAG;AACZ,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC7C,GAAG;AACH,EAAE,KAAK,GAAG;AACV,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,UAAU,EAAE,CAAC,CAAC;AACtC,GAAG;AACH,EAAE,IAAI,GAAG;AACT,IAAI,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AAC3C,IAAI,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;AACnC,IAAI,KAAK,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,EAAE;AAC/E,MAAM,IAAI,OAAO,EAAE;AACnB,QAAQ,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACtD,UAAU,OAAO,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACvD,SAAS;AACT,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,6BAA6B,EAAE,GAAG,EAAE;AACrE,UAAU,cAAc,EAAE,IAAI;AAC9B,SAAS,CAAC,CAAC;AACX,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,EAAE;AAC7C,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,MAAM,aAAa;AACnB,MAAM,qBAAqB;AAC3B,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;AACvB,IAAI,IAAI,SAAS,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC3C,IAAI,IAAI,WAAW,GAAG,CAAC,EAAE;AACzB,MAAM,MAAM,QAAQ,GAAG,SAAS,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC5D,MAAM,IAAI,QAAQ,EAAE;AACpB,QAAQ,MAAM,SAAS,GAAG,QAAQ,GAAG,CAAC,CAAC;AACvC,QAAQ,MAAM,SAAS,GAAG,WAAW,GAAG,CAAC,CAAC;AAC1C,QAAQ,MAAM,OAAO,GAAG,QAAQ,GAAG,CAAC,CAAC;AACrC,QAAQ,MAAM,OAAO,GAAG,WAAW,GAAG,CAAC,CAAC;AACxC,QAAQ,SAAS,GAAG,OAAO,KAAK,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;AACnE,QAAQ,IAAI,CAAC,SAAS;AACtB,UAAU,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACrC,OAAO,MAAM,IAAI,CAAC,SAAS,EAAE;AAC7B,QAAQ,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;AAC7C,OAAO;AACP,KAAK;AACL,IAAI,IAAI,SAAS,EAAE;AACnB,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,wBAAwB,EAAE,GAAG,EAAE;AAC9D,QAAQ,cAAc,EAAE,IAAI;AAC5B,OAAO,CAAC,CAAC;AACT,KAAK;AACL,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC3B,IAAI,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACvC,GAAG;AACH,EAAE,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE;AAC5B,IAAI,IAAI,UAAU,CAAC;AACnB,IAAI,KAAK,UAAU,IAAI,IAAI,CAAC,KAAK,EAAE;AACnC,MAAM,IAAI,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC;AAC3C,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,IAAI,UAAU,EAAE;AACpB,MAAM,UAAU,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACtD,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,6BAA6B,EAAE,GAAG,EAAE;AACnE,QAAQ,cAAc,EAAE,IAAI;AAC5B,OAAO,CAAC,CAAC;AACT,KAAK;AACL,GAAG;AACH,CAAC;AACD,MAAM,eAAe,CAAC;AACtB,EAAE,WAAW,CAAC,IAAI,GAAG,CAAC,EAAE;AACxB,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,GAAG;AACH,EAAE,8BAA8B,GAAG;AACnC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC;AAC9C,GAAG;AACH,EAAE,+BAA+B,GAAG;AACpC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC;AAC3B,GAAG;AACH,CAAC;AACD,MAAM,qBAAqB,SAAS,eAAe,CAAC;AACpD,EAAE,WAAW,CAAC,IAAI,EAAE;AACpB,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;AAChB,IAAI,IAAI,CAAC,iBAAiB,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AACvD,GAAG;AACH,EAAE,sBAAsB,CAAC,iBAAiB,EAAE,EAAE,EAAE;AAChD,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC;AAC3B,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC,CAAC;AAC/D,GAAG;AACH,EAAE,qBAAqB,CAAC,KAAK,EAAE;AAC/B,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACzC,GAAG;AACH,EAAE,aAAa,CAAC,QAAQ,EAAE;AAC1B,IAAI,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;AAC7C,GAAG;AACH,CAAC;AACD,MAAM,sBAAsB,CAAC;AAC7B,EAAE,WAAW,CAAC,MAAM,EAAE;AACtB,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;AACzB,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,eAAe,EAAE,CAAC,CAAC;AACzC,IAAI,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,GAAG;AACH,EAAE,KAAK,CAAC,KAAK,EAAE;AACf,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3B,GAAG;AACH,EAAE,IAAI,GAAG;AACT,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AACrB,GAAG;AACH,EAAE,+BAA+B,CAAC,YAAY,EAAE,IAAI,EAAE;AACtD,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;AAClC,IAAI,MAAM;AACV,MAAM,KAAK;AACX,KAAK,GAAG,IAAI,CAAC;AACb,IAAI,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAC7B,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AACzB,IAAI,OAAO,CAAC,KAAK,CAAC,+BAA+B,EAAE,EAAE;AACrD,MAAM,IAAI,KAAK,CAAC,8BAA8B,EAAE,EAAE;AAClD,QAAQ,KAAK,CAAC,sBAAsB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;AAC3D,OAAO,MAAM;AACb,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;AACzB,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;AAC5C,GAAG;AACH,EAAE,gCAAgC,CAAC,KAAK,EAAE,IAAI,EAAE;AAChD,IAAI,MAAM;AACV,MAAM,KAAK;AACX,KAAK,GAAG,IAAI,CAAC;AACb,IAAI,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC1C,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;AAClC,IAAI,IAAI,KAAK,CAAC,+BAA+B,EAAE,EAAE;AACjD,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACvC,KAAK,MAAM,IAAI,KAAK,CAAC,8BAA8B,EAAE,EAAE;AACvD,MAAM,KAAK,CAAC,sBAAsB,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AAClD,KAAK,MAAM;AACX,MAAM,OAAO;AACb,KAAK;AACL,GAAG;AACH,EAAE,+BAA+B,CAAC,EAAE,EAAE;AACtC,IAAI,MAAM;AACV,MAAM,KAAK;AACX,KAAK,GAAG,IAAI,CAAC;AACb,IAAI,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAC7B,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AACzB,IAAI,OAAO,KAAK,CAAC,8BAA8B,EAAE,EAAE;AACnD,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE;AAC5B,QAAQ,KAAK,CAAC,sBAAsB,CAAC,MAAM,CAAC,sBAAsB,EAAE,EAAE,CAAC,CAAC;AACxE,OAAO;AACP,MAAM,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;AACzB,KAAK;AACL,GAAG;AACH,EAAE,iBAAiB,GAAG;AACtB,IAAI,MAAM;AACV,MAAM,KAAK;AACX,KAAK,GAAG,IAAI,CAAC;AACb,IAAI,MAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACjD,IAAI,IAAI,CAAC,YAAY,CAAC,8BAA8B,EAAE;AACtD,MAAM,OAAO;AACb,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,YAAY,EAAE,GAAG,CAAC,KAAK;AACxD,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;AAC3C,MAAM,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAC/B,MAAM,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAC3B,MAAM,OAAO,KAAK,CAAC,8BAA8B,EAAE,EAAE;AACrD,QAAQ,KAAK,CAAC,qBAAqB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC/C,QAAQ,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3B,OAAO;AACP,KAAK,CAAC,CAAC;AACP,GAAG;AACH,CAAC;AACD,SAAS,4BAA4B,GAAG;AACxC,EAAE,OAAO,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC;AACD,SAAS,iBAAiB,GAAG;AAC7B,EAAE,OAAO,IAAI,qBAAqB,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC;AACD,SAAS,kBAAkB,GAAG;AAC9B,EAAE,OAAO,IAAI,qBAAqB,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC;AACD,SAAS,kBAAkB,GAAG;AAC9B,EAAE,OAAO,IAAI,eAAe,EAAE,CAAC;AAC/B,CAAC;AACD,MAAM,0BAA0B,CAAC;AACjC,EAAE,WAAW,GAAG;AAChB,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,GAAG;AACH,EAAE,KAAK,CAAC,KAAK,EAAE;AACf,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC5B,GAAG;AACH,EAAE,IAAI,GAAG;AACT,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;AACtB,GAAG;AACH,EAAE,YAAY,GAAG;AACjB,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/C,GAAG;AACH,EAAE,IAAI,QAAQ,GAAG;AACjB,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,GAAG;AACH,EAAE,IAAI,QAAQ,GAAG;AACjB,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,GAAG;AACH,EAAE,IAAI,SAAS,GAAG;AAClB,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,GAAG;AACH,EAAE,IAAI,KAAK,GAAG;AACd,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,GAAG;AACH,CAAC;AACD,SAAS,aAAa,CAAC,OAAO,EAAE,WAAW,EAAE;AAC7C,EAAE,OAAO,CAAC,OAAO,GAAG,CAAC,GAAG,CAAC,KAAK,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AACnD,CAAC;AACD,MAAM,UAAU,SAAS,SAAS,CAAC;AACnC,EAAE,QAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,UAAU,GAAG,IAAI,EAAE;AAChD,IAAI,IAAI,CAAC,IAAI;AACb,MAAM,OAAO;AACb,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;AAChD,IAAI,IAAI,UAAU,EAAE;AACpB,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;AACzB,KAAK,MAAM;AACX,MAAM,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,GAAG,EAAE;AACxC,QAAQ,UAAU;AAClB,QAAQ,KAAK;AACb,OAAO,CAAC,CAAC;AACT,KAAK;AACL,GAAG;AACH,EAAE,YAAY,CAAC,KAAK,EAAE;AACtB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;AAChE,GAAG;AACH,EAAE,oBAAoB,CAAC,SAAS,EAAE,IAAI,EAAE;AACxC,IAAI,MAAM,OAAO,GAAG,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;AAC5C,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE;AACvD,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AACpD,MAAM,OAAO,EAAE,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM,KAAK,CAAC,CAAC;AACvE,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,qBAAqB,CAAC,IAAI,EAAE;AAC9B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;AACvC,IAAI,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,aAAa,CAAC,KAAK,EAAE;AACvB,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;AAClC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC;AAClB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,gBAAgB,CAAC,KAAK,EAAE,YAAY,EAAE;AACxC,IAAI,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;AACpC,MAAM,IAAI,YAAY,IAAI,IAAI,EAAE;AAChC,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC5D,OAAO;AACP,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACnC,KAAK;AACL,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;AAC5E,GAAG;AACH,EAAE,qBAAqB,GAAG;AAC1B,IAAI,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AAC9F,GAAG;AACH,EAAE,qBAAqB,GAAG;AAC1B,IAAI,yBAAyB,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;AACzD,IAAI,OAAO,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACtD,GAAG;AACH,EAAE,gBAAgB,GAAG;AACrB,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;AACrD,GAAG;AACH,EAAE,SAAS,CAAC,QAAQ,GAAG,IAAI,EAAE;AAC7B,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,gBAAgB,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;AACzD,MAAM,OAAO;AACb,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AAClE,GAAG;AACH,EAAE,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE;AACpB,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,QAAQ,CAAC,EAAE,EAAE,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE;AAC9C,IAAI,MAAM,WAAW,GAAG;AACxB,MAAM,IAAI,EAAE,IAAI;AAChB,KAAK,CAAC;AACN,IAAI,IAAI;AACR,MAAM,MAAM,IAAI,GAAG,EAAE,CAAC,CAAC,KAAK,GAAG,IAAI,KAAK;AACxC,QAAQ,WAAW,CAAC,IAAI,GAAG,KAAK,CAAC;AACjC,QAAQ,MAAM,WAAW,CAAC;AAC1B,OAAO,CAAC,CAAC;AACT,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AAC7D,QAAQ,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;AACrC,QAAQ,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;AAC9B,QAAQ,IAAI,CAAC,KAAK,CAAC,YAAY,GAAG,SAAS,CAAC,YAAY,CAAC;AACzD,QAAQ,OAAO;AACf,UAAU,IAAI;AACd,UAAU,KAAK,EAAE,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;AACzD,UAAU,MAAM,EAAE,KAAK;AACvB,UAAU,OAAO,EAAE,KAAK;AACxB,UAAU,SAAS;AACnB,SAAS,CAAC;AACV,OAAO;AACP,MAAM,OAAO;AACb,QAAQ,IAAI;AACZ,QAAQ,KAAK,EAAE,IAAI;AACnB,QAAQ,MAAM,EAAE,KAAK;AACrB,QAAQ,OAAO,EAAE,KAAK;AACtB,QAAQ,SAAS,EAAE,IAAI;AACvB,OAAO,CAAC;AACR,KAAK,CAAC,OAAO,KAAK,EAAE;AACpB,MAAM,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;AACnC,MAAM,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;AAC5B,MAAM,IAAI,KAAK,YAAY,WAAW,EAAE;AACxC,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,IAAI;AACpB,UAAU,KAAK;AACf,UAAU,MAAM,EAAE,IAAI;AACtB,UAAU,OAAO,EAAE,KAAK;AACxB,UAAU,SAAS;AACnB,SAAS,CAAC;AACV,OAAO;AACP,MAAM,IAAI,KAAK,KAAK,WAAW,EAAE;AACjC,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,WAAW,CAAC,IAAI;AAChC,UAAU,KAAK,EAAE,IAAI;AACrB,UAAU,MAAM,EAAE,KAAK;AACvB,UAAU,OAAO,EAAE,IAAI;AACvB,UAAU,SAAS;AACnB,SAAS,CAAC;AACV,OAAO;AACP,MAAM,MAAM,KAAK,CAAC;AAClB,KAAK;AACL,GAAG;AACH,EAAE,qBAAqB,CAAC,mBAAmB,EAAE,QAAQ,EAAE;AACvD,IAAI,IAAI,CAAC,mBAAmB;AAC5B,MAAM,OAAO,KAAK,CAAC;AACnB,IAAI,MAAM;AACV,MAAM,kBAAkB;AACxB,MAAM,cAAc;AACpB,MAAM,aAAa;AACnB,MAAM,qBAAqB;AAC3B,KAAK,GAAG,mBAAmB,CAAC;AAC5B,IAAI,MAAM,SAAS,GAAG,CAAC,CAAC,kBAAkB,IAAI,CAAC,CAAC,cAAc,IAAI,CAAC,CAAC,qBAAqB,IAAI,CAAC,CAAC,aAAa,CAAC;AAC7G,IAAI,IAAI,CAAC,QAAQ,EAAE;AACnB,MAAM,OAAO,SAAS,CAAC;AACvB,KAAK;AACL,IAAI,IAAI,kBAAkB,IAAI,IAAI,EAAE;AACpC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,2BAA2B,EAAE,kBAAkB,CAAC,CAAC;AACzE,KAAK;AACL,IAAI,IAAI,cAAc,IAAI,IAAI,EAAE;AAChC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,IAAI,aAAa,IAAI,IAAI,EAAE;AAC/B,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,sBAAsB,EAAE,aAAa,CAAC,CAAC;AAC/D,KAAK;AACL,IAAI,IAAI,qBAAqB,IAAI,IAAI,EAAE;AACvC,MAAM,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,CAAC;AAC7C,KAAK;AACL,GAAG;AACH,EAAE,qBAAqB,GAAG;AAC1B,IAAI,OAAO,0BAA0B,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACvD,GAAG;AACH,EAAE,aAAa,CAAC,IAAI,EAAE;AACtB,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,aAAa,CAAC;AACvC,GAAG;AACH,EAAE,gBAAgB,CAAC,IAAI,EAAE;AACzB,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC;AACxB,GAAG;AACH,EAAE,wBAAwB,CAAC,IAAI,EAAE;AACjC,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,KAAK,kBAAkB,IAAI,IAAI,CAAC,IAAI,KAAK,0BAA0B,KAAK,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/H,GAAG;AACH,EAAE,gBAAgB,CAAC,IAAI,EAAE;AACzB,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,gBAAgB,CAAC;AAC1C,GAAG;AACH,EAAE,cAAc,CAAC,IAAI,EAAE;AACvB,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,cAAc,CAAC;AACxC,GAAG;AACH,EAAE,gBAAgB,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ,EAAE;AACpE,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,EAAE,CAAC;AAC3B,IAAI,MAAM,sBAAsB,GAAG,IAAI,CAAC,mBAAmB,CAAC;AAC5D,IAAI,IAAI,CAAC,mBAAmB,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AACzD,IAAI,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC;AACtC,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC7B,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;AAChC,IAAI,MAAM,aAAa,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACjD,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACnD,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC;AACxC,IAAI,IAAI,CAAC,SAAS,GAAG,IAAI,0BAA0B,EAAE,CAAC;AACtD,IAAI,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC;AAC1C,IAAI,IAAI,CAAC,UAAU,GAAG,IAAI,iBAAiB,CAAC,IAAI,CAAC,CAAC;AAClD,IAAI,MAAM,kBAAkB,GAAG,IAAI,CAAC,eAAe,CAAC;AACpD,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,CAAC;AAC5D,IAAI,OAAO,MAAM;AACjB,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AACpC,MAAM,IAAI,CAAC,mBAAmB,GAAG,sBAAsB,CAAC;AACxD,MAAM,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC;AAClC,MAAM,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;AAC5B,MAAM,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC;AACpC,MAAM,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC;AACtC,MAAM,IAAI,CAAC,eAAe,GAAG,kBAAkB,CAAC;AAChD,KAAK,CAAC;AACN,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,IAAI,UAAU,GAAG,CAAC,CAAC;AACvB,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE;AACvB,MAAM,UAAU,IAAI,CAAC,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACxB,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AACrC,GAAG;AACH,EAAE,yBAAyB,CAAC,mBAAmB,EAAE;AACjD,IAAI,MAAM;AACV,MAAM,aAAa;AACnB,KAAK,GAAG,mBAAmB,CAAC;AAC5B,IAAI,IAAI,aAAa,KAAK,IAAI,EAAE;AAChC,MAAM,IAAI,CAAC,YAAY,CAAC,sBAAsB,EAAE,aAAa,CAAC,CAAC;AAC/D,KAAK;AACL,GAAG;AACH,CAAC;AACD,MAAM,gBAAgB,CAAC;AACvB,EAAE,WAAW,GAAG;AAChB,IAAI,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;AACnC,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AAC/B,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;AAC9B,IAAI,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;AACtC,GAAG;AACH,CAAC;AACD,MAAM,IAAI,CAAC;AACX,EAAE,WAAW,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE;AAChC,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC;AACrB,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AACjB,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,cAAc,CAAC,GAAG,CAAC,CAAC;AACvC,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM;AAC/C,MAAM,IAAI,CAAC,KAAK,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAC5B,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,CAAC,QAAQ;AACzC,MAAM,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;AAC1C,GAAG;AACH,CAAC;AACD,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC;AACrC;AACA,EAAE,aAAa,CAAC,OAAO,GAAG,WAAW;AACrC,IAAI,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACjE,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACnC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3D,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1B,MAAM,IAAI,GAAG,KAAK,iBAAiB,IAAI,GAAG,KAAK,kBAAkB,IAAI,GAAG,KAAK,eAAe,EAAE;AAC9F,QAAQ,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AACjC,OAAO;AACP,KAAK;AACL,IAAI,OAAO,OAAO,CAAC;AACnB,GAAG,CAAC;AACJ,CAAC;AACD,SAAS,gBAAgB,CAAC,IAAI,EAAE;AAChC,EAAE,OAAO,eAAe,CAAC,IAAI,CAAC,CAAC;AAC/B,CAAC;AACD,SAAS,eAAe,CAAC,IAAI,EAAE;AAC/B,EAAE,MAAM;AACR,IAAI,IAAI;AACR,IAAI,KAAK;AACT,IAAI,GAAG;AACP,IAAI,GAAG;AACP,IAAI,KAAK;AACT,IAAI,KAAK;AACT,IAAI,IAAI;AACR,GAAG,GAAG,IAAI,CAAC;AACX,EAAE,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;AAC9C,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,EAAE,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;AACnB,EAAE,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;AACnB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,EAAE,IAAI,IAAI,KAAK,aAAa,EAAE;AAC9B,IAAI,MAAM,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;AAC5C,GAAG;AACH,EAAE,OAAO,MAAM,CAAC;AAChB,CAAC;AACD,SAAS,kBAAkB,CAAC,IAAI,EAAE;AAClC,EAAE,MAAM;AACR,IAAI,IAAI;AACR,IAAI,KAAK;AACT,IAAI,GAAG;AACP,IAAI,GAAG;AACP,IAAI,KAAK;AACT,IAAI,KAAK;AACT,GAAG,GAAG,IAAI,CAAC;AACX,EAAE,IAAI,IAAI,KAAK,aAAa,EAAE;AAC9B,IAAI,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAClC,GAAG;AACH,EAAE,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;AAC9C,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,EAAE,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;AACnB,EAAE,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;AACnB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,EAAE,IAAI,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC,EAAE;AAC3B,IAAI,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;AAC1B,GAAG,MAAM;AACT,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AACzB,GAAG;AACH,EAAE,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AAC5B,EAAE,OAAO,MAAM,CAAC;AAChB,CAAC;AACD,MAAM,SAAS,SAAS,UAAU,CAAC;AACnC,EAAE,SAAS,GAAG;AACd,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACpC,IAAI,OAAO,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAC1C,GAAG;AACH,EAAE,WAAW,CAAC,GAAG,EAAE;AACnB,IAAI,OAAO,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAC1C,GAAG;AACH,EAAE,eAAe,CAAC,IAAI,EAAE;AACxB,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC5C,GAAG;AACH,EAAE,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE;AACzB,IAAI,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AACnE,GAAG;AACH,EAAE,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE;AACnC,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC;AAC5B,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,MAAM,CAAC;AAC1B,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;AAC3B,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC;AACnC,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa;AAClC,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;AAChC,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE,QAAQ,EAAE;AACrC,IAAI,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;AAChC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,QAAQ,CAAC;AAC9B,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;AAC3B,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC;AACrC,GAAG;AACH,EAAE,gBAAgB,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE;AAC5D,IAAI,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC;AAC5B,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,MAAM,CAAC;AAC1B,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;AAC3B,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC;AACnC,GAAG;AACH,EAAE,0BAA0B,CAAC,IAAI,EAAE,YAAY,EAAE;AACjD,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC1D,GAAG;AACH,CAAC;AACD,MAAM,aAAa,GAAG,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;AAClM,MAAM,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;AACxC,EAAE,yBAAyB,EAAE,gFAAgF;AAC7G,EAAE,0BAA0B,EAAE,wKAAwK;AACtM,EAAE,kBAAkB,EAAE,CAAC;AACvB,IAAI,YAAY;AAChB,GAAG,KAAK,CAAC,+BAA+B,EAAE,YAAY,CAAC,CAAC,CAAC;AACzD,EAAE,mBAAmB,EAAE,yDAAyD;AAChF,EAAE,4BAA4B,EAAE,qEAAqE;AACrG,EAAE,6BAA6B,EAAE,+CAA+C;AAChF,EAAE,+BAA+B,EAAE,CAAC;AACpC,IAAI,UAAU;AACd,IAAI,QAAQ;AACZ,GAAG,KAAK,CAAC,0DAA0D,EAAE,UAAU,CAAC,gBAAgB,EAAE,UAAU,CAAC,sBAAsB,EAAE,QAAQ,CAAC,GAAG,CAAC;AAClJ,EAAE,uBAAuB,EAAE,CAAC;AAC5B,IAAI,UAAU;AACd,IAAI,QAAQ;AACZ,GAAG,KAAK,CAAC,oDAAoD,EAAE,UAAU,CAAC,0CAA0C,EAAE,QAAQ,CAAC,GAAG,CAAC;AACnI,EAAE,4BAA4B,EAAE,CAAC;AACjC,IAAI,QAAQ;AACZ,GAAG,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,qKAAqK,CAAC;AACjM,EAAE,uBAAuB,EAAE,CAAC;AAC5B,IAAI,eAAe;AACnB,IAAI,QAAQ;AACZ,GAAG,KAAK,CAAC,YAAY,EAAE,eAAe,CAAC,yFAAyF,EAAE,QAAQ,CAAC,GAAG,CAAC;AAC/I,EAAE,sCAAsC,EAAE,CAAC;AAC3C,IAAI,QAAQ;AACZ,GAAG,KAAK,CAAC,yGAAyG,EAAE,QAAQ,CAAC,GAAG,CAAC;AACjI,EAAE,uCAAuC,EAAE,CAAC;AAC5C,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,IAAI,YAAY;AAChB,GAAG,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,cAAc,EAAE,YAAY,CAAC,4BAA4B,EAAE,UAAU,CAAC,iBAAiB,EAAE,YAAY,CAAC,SAAS,CAAC;AAC3I,EAAE,sCAAsC,EAAE,CAAC;AAC3C,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,GAAG,KAAK,CAAC,iDAAiD,EAAE,UAAU,CAAC,cAAc,EAAE,QAAQ,CAAC,GAAG,CAAC;AACpG,EAAE,uCAAuC,EAAE,CAAC;AAC5C,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,GAAG,KAAK,CAAC,kCAAkC,EAAE,UAAU,CAAC,yEAAyE,EAAE,QAAQ,CAAC,GAAG,CAAC;AAChJ,EAAE,qBAAqB,EAAE,CAAC;AAC1B,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,IAAI,UAAU;AACd,GAAG,KAAK,CAAC,kFAAkF,EAAE,UAAU,CAAC,qBAAqB,EAAE,UAAU,CAAC,cAAc,EAAE,QAAQ,CAAC,GAAG,CAAC;AACvK,EAAE,8BAA8B,EAAE,CAAC;AACnC,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,GAAG,KAAK,CAAC,mDAAmD,EAAE,UAAU,CAAC,iBAAiB,EAAE,QAAQ,CAAC,GAAG,CAAC;AACzG,EAAE,yCAAyC,EAAE,CAAC;AAC9C,IAAI,QAAQ;AACZ,GAAG,KAAK,CAAC,wGAAwG,EAAE,QAAQ,CAAC,GAAG,CAAC;AAChI,EAAE,yBAAyB,EAAE,0CAA0C;AACvE,EAAE,6BAA6B,EAAE,wEAAwE;AACzG,EAAE,mCAAmC,EAAE,wKAAwK;AAC/M,EAAE,kBAAkB,EAAE,6EAA6E;AACnG,EAAE,sBAAsB,EAAE,0EAA0E;AACpG,EAAE,eAAe,EAAE,+CAA+C;AAClE,EAAE,mCAAmC,EAAE,yFAAyF;AAChI,EAAE,uBAAuB,EAAE,yGAAyG;AACpI,EAAE,mBAAmB,EAAE,kEAAkE;AACzF,EAAE,iBAAiB,EAAE,yDAAyD;AAC9E,EAAE,iBAAiB,EAAE,MAAM,CAAC,MAAM,CAAC;AACnC,IAAI,OAAO,EAAE,gFAAgF;AAC7F,GAAG,EAAE;AACL,IAAI,UAAU,EAAE,wBAAwB;AACxC,GAAG,CAAC;AACJ,EAAE,yBAAyB,EAAE,0CAA0C;AACvE,EAAE,cAAc,EAAE,yCAAyC;AAC3D,EAAE,2BAA2B,EAAE,yDAAyD;AACxF,EAAE,4BAA4B,EAAE,mGAAmG;AACnI,EAAE,yBAAyB,EAAE,0CAA0C;AACvE,EAAE,oBAAoB,EAAE,4DAA4D;AACpF,EAAE,kBAAkB,EAAE,oDAAoD;AAC1E,EAAE,qBAAqB,EAAE,mHAAmH;AAC5I,EAAE,iBAAiB,EAAE,sEAAsE;AAC3F,EAAE,iCAAiC,EAAE,sEAAsE;AAC3G,EAAE,sBAAsB,EAAE,CAAC;AAC3B,IAAI,YAAY;AAChB,GAAG,KAAK,CAAC,yBAAyB,EAAE,YAAY,CAAC,CAAC,CAAC;AACnD,EAAE,4BAA4B,EAAE,wDAAwD;AACxF,EAAE,kCAAkC,EAAE,uDAAuD;AAC7F,EAAE,oBAAoB,EAAE,kEAAkE;AAC1F,EAAE,4BAA4B,EAAE,kDAAkD;AAClF,EAAE,iCAAiC,EAAE,mEAAmE;AACxG,EAAE,+CAA+C,EAAE,mHAAmH;AACtK,EAAE,4BAA4B,EAAE,CAAC;AACjC,IAAI,qBAAqB;AACzB,IAAI,UAAU;AACd,GAAG,KAAK,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,2BAA2B,EAAE,UAAU,CAAC,WAAW,CAAC;AACtG,EAAE,mCAAmC,EAAE,mEAAmE;AAC1G,EAAE,uBAAuB,EAAE,4BAA4B;AACvD,CAAC,CAAC,CAAC;AACH,SAAS,cAAc,CAAC,WAAW,EAAE;AACrC,EAAE,OAAO,WAAW,CAAC,IAAI,KAAK,6BAA6B,IAAI,WAAW,CAAC,IAAI,KAAK,0BAA0B,KAAK,CAAC,WAAW,CAAC,WAAW,IAAI,WAAW,CAAC,WAAW,CAAC,IAAI,KAAK,WAAW,IAAI,WAAW,CAAC,WAAW,CAAC,IAAI,KAAK,sBAAsB,CAAC,CAAC;AACxP,CAAC;AACD,SAAS,iBAAiB,CAAC,IAAI,EAAE;AACjC,EAAE,OAAO,IAAI,CAAC,UAAU,KAAK,MAAM,IAAI,IAAI,CAAC,UAAU,KAAK,QAAQ,CAAC;AACpE,CAAC;AACD,MAAM,iBAAiB,GAAG;AAC1B,EAAE,KAAK,EAAE,oBAAoB;AAC7B,EAAE,GAAG,EAAE,oBAAoB;AAC3B,EAAE,IAAI,EAAE,aAAa;AACrB,EAAE,SAAS,EAAE,kBAAkB;AAC/B,CAAC,CAAC;AACF,SAAS,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE;AAC/B,EAAE,MAAM,KAAK,GAAG,EAAE,CAAC;AACnB,EAAE,MAAM,KAAK,GAAG,EAAE,CAAC;AACnB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACxC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,KAAK,GAAG,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3D,GAAG;AACH,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACxB,CAAC;AACD,MAAM,iBAAiB,GAAG,wBAAwB,CAAC;AACnD,IAAI,IAAI,GAAG,CAAC,UAAU,KAAK,MAAM,eAAe,SAAS,UAAU,CAAC;AACpE,EAAE,WAAW,CAAC,GAAG,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC;AAC7B,GAAG;AACH,EAAE,eAAe,GAAG;AACpB,IAAI,OAAO,gBAAgB,CAAC;AAC5B,GAAG;AACH,EAAE,gBAAgB,GAAG;AACrB,IAAI,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,CAAC;AAC7E,GAAG;AACH,EAAE,gBAAgB,GAAG;AACrB,IAAI,OAAO,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,GAAG,EAAE;AACzB,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AACpD,MAAM,IAAI,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,EAAE;AACtC,QAAQ,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AAC/B,OAAO;AACP,KAAK;AACL,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACjC,GAAG;AACH,EAAE,UAAU,CAAC,OAAO,EAAE;AACtB,IAAI,IAAI,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,EAAE;AACpC,MAAM,MAAM,OAAO,GAAG,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAC5D,MAAM,IAAI,CAAC,OAAO;AAClB,QAAQ,CAAC;AACT,WAAW,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;AACtC,QAAQ,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;AACjC,OAAO,MAAM,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;AAC1C,QAAQ,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC;AACnC,OAAO,MAAM;AACb,QAAQ,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;AAClD,OAAO;AACP,KAAK;AACL,IAAI,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAC9B,GAAG;AACH,EAAE,wBAAwB,CAAC,GAAG,EAAE;AAChC,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;AAC3B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AACtC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AAClC,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AAC1C,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;AAC/B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,CAAC,EAAE;AAChE,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,kCAAkC,EAAE,SAAS,CAAC,CAAC;AAC3E,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,eAAe,EAAE,CAAC;AAC3C,MAAM,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACtB,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AACxD,KAAK,MAAM;AACX,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AACxD,KAAK;AACL,GAAG;AACH,EAAE,oCAAoC,GAAG;AACzC,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC;AACpB,IAAI,IAAI,SAAS,GAAG,IAAI,CAAC;AACzB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AACpC,MAAM,SAAS,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC5C,KAAK,MAAM;AACX,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAClC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AACpC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC1B,QAAQ,SAAS,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC9C,OAAO;AACP,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAC7B,GAAG;AACH,EAAE,qBAAqB,CAAC,IAAI,EAAE;AAC9B,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3C,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,wBAAwB,CAAC,IAAI,EAAE;AACjC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AAChD,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACtC,IAAI,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC3C,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACzE,KAAK,MAAM;AACX,MAAM,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC;AACrC,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,2BAA2B,EAAE,CAAC;AACnD,IAAI,QAAQ,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;AACjC,IAAI,QAAQ,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;AAC7B,IAAI,QAAQ,CAAC,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC;AAC9B,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,oCAAoC,EAAE,CAAC;AACxF,IAAI,aAAa,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,wBAAwB,CAAC,CAAC;AACvF,IAAI,EAAE,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;AACzE,IAAI,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;AAC9B,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAClE,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;AACpD,GAAG;AACH,EAAE,gBAAgB,CAAC,IAAI,EAAE,YAAY,EAAE;AACvC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;AAC9C,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC/B,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;AACjD,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC/B,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;AACjD,KAAK,MAAM,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE;AACxC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC1B,QAAQ,OAAO,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;AACxD,OAAO,MAAM;AACb,QAAQ,IAAI,YAAY,EAAE;AAC1B,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,mBAAmB,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AACjF,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;AACjD,OAAO;AACP,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACvC,MAAM,OAAO,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;AAClD,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACvC,MAAM,OAAO,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;AACnD,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACvC,MAAM,OAAO,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;AAClD,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC/B,MAAM,OAAO,IAAI,CAAC,iCAAiC,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;AACxE,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;AACxB,KAAK;AACL,GAAG;AACH,EAAE,wBAAwB,CAAC,IAAI,EAAE;AACjC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,kCAAkC,CAAC,IAAI,CAAC,CAAC;AAC5D,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC/D,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;AACpD,GAAG;AACH,EAAE,sBAAsB,CAAC,IAAI,EAAE;AAC/B,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACxB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AACzB,MAAM,IAAI,CAAC,EAAE,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC;AACtC,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACvC,KAAK;AACL,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClD,IAAI,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,EAAE,CAAC;AACpC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AAC3B,MAAM,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACvC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC1B,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxD,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,mCAAmC,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AACjG,SAAS;AACT,QAAQ,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;AACrC,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,gBAAgB,CAAC,GAAG,EAAE,UAAU,CAAC,mCAAmC,CAAC,CAAC;AACnF,QAAQ,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;AAC3D,OAAO;AACP,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAC3B,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACtB,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC;AAChD,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC;AACpB,IAAI,IAAI,eAAe,GAAG,KAAK,CAAC;AAChC,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,WAAW,KAAK;AAClC,MAAM,IAAI,cAAc,CAAC,WAAW,CAAC,EAAE;AACvC,QAAQ,IAAI,IAAI,KAAK,UAAU,EAAE;AACjC,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,0BAA0B,EAAE,WAAW,CAAC,CAAC;AACzE,SAAS;AACT,QAAQ,IAAI,GAAG,IAAI,CAAC;AACpB,OAAO,MAAM,IAAI,WAAW,CAAC,IAAI,KAAK,sBAAsB,EAAE;AAC9D,QAAQ,IAAI,eAAe,EAAE;AAC7B,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,6BAA6B,EAAE,WAAW,CAAC,CAAC;AAC5E,SAAS;AACT,QAAQ,IAAI,IAAI,KAAK,IAAI,EAAE;AAC3B,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,0BAA0B,EAAE,WAAW,CAAC,CAAC;AACzE,SAAS;AACT,QAAQ,IAAI,GAAG,UAAU,CAAC;AAC1B,QAAQ,eAAe,GAAG,IAAI,CAAC;AAC/B,OAAO;AACP,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,UAAU,CAAC;AACnC,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;AAClD,GAAG;AACH,EAAE,iCAAiC,CAAC,IAAI,EAAE,YAAY,EAAE;AACxD,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC5C,QAAQ,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;AACnE,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAChD,QAAQ,IAAI,CAAC,SAAS,EAAE,CAAC;AACzB,OAAO;AACP,MAAM,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;AAC1B,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,0BAA0B,CAAC,CAAC;AAC/D,KAAK,MAAM;AACX,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,YAAY,EAAE;AACjH,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;AACvC,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AACvF,UAAU,qBAAqB,EAAE,KAAK;AACtC,UAAU,UAAU,EAAE,iBAAiB,CAAC,KAAK,CAAC;AAC9C,SAAS,CAAC,CAAC;AACX,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACxF,QAAQ,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;AACnE,QAAQ,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;AAC7B,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,0BAA0B,CAAC,CAAC;AACjE,OAAO,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAChI,QAAQ,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC5C,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,wBAAwB,EAAE;AACpD,UAAU,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC;AAC1C,UAAU,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;AAC/B,UAAU,OAAO,IAAI,CAAC,UAAU,CAAC;AACjC,SAAS;AACT,QAAQ,IAAI,CAAC,IAAI,GAAG,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC;AAC1C,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;AACtB,GAAG;AACH,EAAE,6BAA6B,CAAC,IAAI,EAAE;AACtC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;AAC/B,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AACzD,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AACzD,GAAG;AACH,EAAE,yBAAyB,CAAC,IAAI,EAAE;AAClC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;AACnD,IAAI,QAAQ,CAAC,IAAI,GAAG,kBAAkB,CAAC;AACvC,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH,EAAE,0BAA0B,CAAC,IAAI,EAAE;AACnC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC1D,IAAI,QAAQ,CAAC,IAAI,GAAG,mBAAmB,CAAC;AACxC,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH,EAAE,yBAAyB,CAAC,IAAI,EAAE;AAClC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC5C,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;AACrD,GAAG;AACH,EAAE,qBAAqB,CAAC,IAAI,EAAE,OAAO,EAAE;AACvC,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,6BAA6B,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACjE,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,OAAO,GAAG,EAAE,GAAG,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACjF,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACrE,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACjC,KAAK;AACL,IAAI,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AACtB,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,GAAG;AACT,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,CAAC,CAAC;AAC5D,OAAO,QAAQ,CAAC,OAAO,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACzC,KAAK;AACL,IAAI,IAAI,OAAO,EAAE;AACjB,MAAM,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;AAC3B,MAAM,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACvB,MAAM,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE;AACnC,QAAQ,GAAG;AACX,UAAU,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,CAAC,CAAC;AAC7D,SAAS,QAAQ,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAC/B,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE;AACnC,QAAQ,GAAG;AACX,UAAU,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,CAAC,CAAC;AACjE,SAAS,QAAQ,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAC/B,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC;AACzC,MAAM,WAAW,EAAE,OAAO;AAC1B,MAAM,UAAU,EAAE,KAAK;AACvB,MAAM,WAAW,EAAE,KAAK;AACxB,MAAM,UAAU,EAAE,OAAO;AACzB,MAAM,YAAY,EAAE,KAAK;AACzB,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,yBAAyB,GAAG;AAC9B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,gCAAgC,EAAE,CAAC;AACtD,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,mCAAmC,EAAE,CAAC;AACvE,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACjC,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;AACrD,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE;AAC3B,IAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC5C,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AACzD,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE;AAC3B,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE;AACtB,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC/E,KAAK;AACL,GAAG;AACH,EAAE,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE;AACjD,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC;AAChC,MAAM,OAAO;AACb,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,UAAU,CAAC,kBAAkB,GAAG,UAAU,CAAC,sBAAsB,EAAE,QAAQ,EAAE;AAC1G,MAAM,YAAY,EAAE,IAAI;AACxB,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,6BAA6B,CAAC,OAAO,EAAE,WAAW,EAAE;AACtD,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;AAC/E,IAAI,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;AACzC,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE;AAC3B,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC9D,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAClE,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACrE,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACjC,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;AACnD,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;AAC9C,GAAG;AACH,EAAE,mBAAmB,CAAC,IAAI,EAAE,OAAO,EAAE;AACrC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;AAC/B,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC7D,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAClE,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACrE,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACjC,KAAK;AACL,IAAI,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AAC1B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;AACzD,KAAK;AACL,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AACzB,IAAI,IAAI,CAAC,OAAO,EAAE;AAClB,MAAM,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;AACrB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;AAC/C,GAAG;AACH,EAAE,sBAAsB,CAAC,cAAc,GAAG,KAAK,EAAE;AACjD,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AAC7C,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC9C,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,kCAAkC,EAAE,CAAC;AAC5D,IAAI,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;AAC3B,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC7B,IAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,cAAc,CAAC;AACtC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;AACnB,MAAM,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC1C,KAAK,MAAM;AACX,MAAM,IAAI,cAAc,EAAE;AAC1B,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,uBAAuB,EAAE,YAAY,CAAC,CAAC;AACrE,OAAO;AACP,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;AAClD,GAAG;AACH,EAAE,iCAAiC,GAAG;AACtC,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC3C,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;AACxB,KAAK;AACL,IAAI,IAAI,eAAe,GAAG,KAAK,CAAC;AAChC,IAAI,GAAG;AACP,MAAM,MAAM,aAAa,GAAG,IAAI,CAAC,sBAAsB,CAAC,eAAe,CAAC,CAAC;AACzE,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AACtC,MAAM,IAAI,aAAa,CAAC,OAAO,EAAE;AACjC,QAAQ,eAAe,GAAG,IAAI,CAAC;AAC/B,OAAO;AACP,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC9B,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AAClC,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,0BAA0B,CAAC,CAAC;AAC7D,GAAG;AACH,EAAE,mCAAmC,GAAG;AACxC,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;AAChE,IAAI,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC;AAC1C,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC5B,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;AAC7C,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,qBAAqB,CAAC;AAC1D,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AAClC,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,4BAA4B,CAAC,CAAC;AAC/D,GAAG;AACH,EAAE,4CAA4C,GAAG;AACjD,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC5B,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,oCAAoC,EAAE,CAAC,CAAC;AACpE,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AAClC,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,4BAA4B,CAAC,CAAC;AAC/D,GAAG;AACH,EAAE,sBAAsB,GAAG;AAC3B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;AAC/B,IAAI,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AACtB,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,GAAG;AACT,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,CAAC,CAAC;AAC5D,OAAO,QAAQ,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAC7B,KAAK;AACL,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC;AACzC,MAAM,WAAW,EAAE,KAAK;AACxB,MAAM,UAAU,EAAE,KAAK;AACvB,MAAM,WAAW,EAAE,KAAK;AACxB,MAAM,UAAU,EAAE,KAAK;AACvB,MAAM,YAAY,EAAE,KAAK;AACzB,KAAK,CAAC,CAAC;AACP,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,yBAAyB,CAAC,CAAC;AAC5D,GAAG;AACH,EAAE,0BAA0B,GAAG;AAC/B,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,aAAa,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AACnG,GAAG;AACH,EAAE,0BAA0B,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE;AACvD,IAAI,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC3B,IAAI,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,KAAK,EAAE,EAAE;AACtC,MAAM,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AAClD,MAAM,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACjD,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC;AACrB,MAAM,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AACtC,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACjD,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC7B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AACtD,GAAG;AACH,EAAE,+BAA+B,CAAC,IAAI,EAAE,QAAQ,EAAE;AAClD,IAAI,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC3B,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AAChD,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC1C,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACzB,MAAM,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AAC5B,MAAM,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;AACvF,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;AAC1B,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACxB,QAAQ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC7B,OAAO;AACP,MAAM,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACnD,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC3D,GAAG;AACH,EAAE,4BAA4B,CAAC,IAAI,EAAE;AACrC,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;AACrB,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AAC/B,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACrE,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;AACxD,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AAC5B,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC/C,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/D,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;AACzD,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACtD,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC3D,GAAG;AACH,EAAE,+BAA+B,CAAC,IAAI,EAAE,QAAQ,EAAE;AAClD,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACvC,IAAI,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC3B,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAC;AAC9D,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC3D,GAAG;AACH,EAAE,mBAAmB,CAAC;AACtB,IAAI,WAAW;AACf,IAAI,UAAU;AACd,IAAI,WAAW;AACf,IAAI,UAAU;AACd,IAAI,YAAY;AAChB,GAAG,EAAE;AACL,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACvC,IAAI,SAAS,CAAC,cAAc,GAAG,EAAE,CAAC;AAClC,IAAI,SAAS,CAAC,UAAU,GAAG,EAAE,CAAC;AAC9B,IAAI,SAAS,CAAC,QAAQ,GAAG,EAAE,CAAC;AAC5B,IAAI,SAAS,CAAC,aAAa,GAAG,EAAE,CAAC;AACjC,IAAI,IAAI,QAAQ,CAAC;AACjB,IAAI,IAAI,KAAK,CAAC;AACd,IAAI,IAAI,OAAO,GAAG,KAAK,CAAC;AACxB,IAAI,IAAI,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AACrC,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACrB,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,KAAK,GAAG,IAAI,CAAC;AACnB,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACrB,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,KAAK,GAAG,KAAK,CAAC;AACpB,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,GAAG,KAAK,CAAC;AAC5B,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE;AAClC,MAAM,IAAI,QAAQ,GAAG,KAAK,CAAC;AAC3B,MAAM,IAAI,aAAa,GAAG,IAAI,CAAC;AAC/B,MAAM,IAAI,eAAe,GAAG,IAAI,CAAC;AACjC,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACpC,MAAM,IAAI,UAAU,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAChD,QAAQ,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC3C,QAAQ,IAAI,SAAS,CAAC,IAAI,KAAK,EAAE,IAAI,SAAS,CAAC,IAAI,KAAK,EAAE,EAAE;AAC5D,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC;AACtB,UAAU,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AAC9C,UAAU,WAAW,GAAG,KAAK,CAAC;AAC9B,SAAS;AACT,OAAO;AACP,MAAM,IAAI,WAAW,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACjD,QAAQ,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC3C,QAAQ,IAAI,SAAS,CAAC,IAAI,KAAK,EAAE,IAAI,SAAS,CAAC,IAAI,KAAK,EAAE,EAAE;AAC5D,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC;AACtB,UAAU,QAAQ,GAAG,IAAI,CAAC;AAC1B,SAAS;AACT,OAAO;AACP,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAChD,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;AACvB,QAAQ,IAAI,aAAa,IAAI,IAAI,EAAE;AACnC,UAAU,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;AACzB,UAAU,IAAI,QAAQ,EAAE;AACxB,YAAY,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAChD,WAAW;AACX,UAAU,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,+BAA+B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC7F,SAAS,MAAM;AACf,UAAU,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC7F,SAAS;AACT,OAAO,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACnD,QAAQ,IAAI,aAAa,IAAI,IAAI,EAAE;AACnC,UAAU,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,IAAI,QAAQ,EAAE;AACtB,UAAU,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC9C,SAAS;AACT,QAAQ,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,+BAA+B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC5F,OAAO,MAAM;AACb,QAAQ,IAAI,IAAI,GAAG,MAAM,CAAC;AAC1B,QAAQ,IAAI,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAC7D,UAAU,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC7C,UAAU,IAAI,0BAA0B,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;AAC1D,YAAY,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;AACpC,YAAY,IAAI,CAAC,IAAI,EAAE,CAAC;AACxB,WAAW;AACX,SAAS;AACT,QAAQ,MAAM,aAAa,GAAG,IAAI,CAAC,2BAA2B,CAAC,IAAI,EAAE,QAAQ,EAAE,aAAa,EAAE,QAAQ,EAAE,IAAI,EAAE,WAAW,EAAE,YAAY,IAAI,IAAI,GAAG,YAAY,GAAG,CAAC,KAAK,CAAC,CAAC;AACzK,QAAQ,IAAI,aAAa,KAAK,IAAI,EAAE;AACpC,UAAU,OAAO,GAAG,IAAI,CAAC;AACzB,UAAU,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;AACvD,SAAS,MAAM;AACf,UAAU,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AACnD,SAAS;AACT,OAAO;AACP,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAC;AACrC,MAAM,IAAI,eAAe,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AAC/D,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,iCAAiC,EAAE,eAAe,CAAC,CAAC;AAClF,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC1B,IAAI,IAAI,WAAW,EAAE;AACrB,MAAM,SAAS,CAAC,OAAO,GAAG,OAAO,CAAC;AAClC,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,sBAAsB,CAAC,CAAC;AACnE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AAClC,IAAI,OAAO,GAAG,CAAC;AACf,GAAG;AACH,EAAE,2BAA2B,CAAC,IAAI,EAAE,QAAQ,EAAE,aAAa,EAAE,QAAQ,EAAE,IAAI,EAAE,WAAW,EAAE,YAAY,EAAE;AACxG,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAChG,MAAM,IAAI,cAAc,EAAE;AAC1B,QAAQ,IAAI,CAAC,WAAW,EAAE;AAC1B,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,sBAAsB,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AACpF,SAAS,MAAM,IAAI,CAAC,YAAY,EAAE;AAClC,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,kBAAkB,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AAChF,SAAS;AACT,QAAQ,IAAI,QAAQ,EAAE;AACtB,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;AAC3D,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,MAAM,IAAI,CAAC,WAAW,EAAE;AACxB,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,oBAAoB,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AAChF,OAAO;AACP,MAAM,IAAI,aAAa,IAAI,IAAI,EAAE;AACjC,QAAQ,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACvC,OAAO;AACP,MAAM,IAAI,QAAQ,EAAE;AACpB,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;AACxD,OAAO;AACP,MAAM,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC3C,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,0BAA0B,CAAC,CAAC;AAC/D,KAAK,MAAM;AACX,MAAM,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AACnD,MAAM,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC7B,MAAM,IAAI,CAAC,KAAK,GAAG,aAAa,IAAI,IAAI,CAAC;AACzC,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACvB,MAAM,IAAI,QAAQ,GAAG,KAAK,CAAC;AAC3B,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC5C,QAAQ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AAC3B,QAAQ,IAAI,aAAa,IAAI,IAAI,EAAE;AACnC,UAAU,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,IAAI,QAAQ,EAAE;AACtB,UAAU,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC9C,SAAS;AACT,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;AACzF,QAAQ,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,EAAE;AAC9C,UAAU,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;AACjD,SAAS;AACT,QAAQ,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;AAChF,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAC/E,SAAS;AACT,OAAO,MAAM;AACb,QAAQ,IAAI,IAAI,KAAK,MAAM;AAC3B,UAAU,IAAI,CAAC,UAAU,EAAE,CAAC;AAC5B,QAAQ,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;AAC5B,QAAQ,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAC1B,UAAU,QAAQ,GAAG,IAAI,CAAC;AAC1B,SAAS;AACT,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACrD,QAAQ,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACjC,OAAO;AACP,MAAM,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC/B,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,oBAAoB,CAAC,CAAC;AACzD,KAAK;AACL,GAAG;AACH,EAAE,2BAA2B,CAAC,QAAQ,EAAE;AACxC,IAAI,MAAM,UAAU,GAAG,QAAQ,CAAC,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;AACvD,IAAI,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAChF,IAAI,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;AAC7B,MAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,KAAK,KAAK,GAAG,UAAU,CAAC,yBAAyB,GAAG,UAAU,CAAC,yBAAyB,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAC7I,KAAK;AACL,IAAI,IAAI,MAAM,KAAK,UAAU,EAAE;AAC/B,MAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,KAAK,KAAK,GAAG,MAAM,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;AACpG,KAAK;AACL,IAAI,IAAI,QAAQ,CAAC,IAAI,KAAK,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;AACxD,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,sBAAsB,EAAE,QAAQ,CAAC,CAAC;AAC1D,KAAK;AACL,GAAG;AACH,EAAE,uBAAuB,GAAG;AAC5B,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AAC5E,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;AACxB,KAAK;AACL,GAAG;AACH,EAAE,gCAAgC,CAAC,QAAQ,EAAE,EAAE,EAAE;AACjD,IAAI,IAAI,SAAS,CAAC;AAClB,IAAI,CAAC,SAAS,GAAG,QAAQ,KAAK,IAAI,GAAG,SAAS,GAAG,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AAChF,IAAI,IAAI,IAAI,GAAG,EAAE,IAAI,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;AAC9D,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACzB,MAAM,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC/C,MAAM,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;AACjC,MAAM,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;AAC1D,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,yBAAyB,CAAC,CAAC;AAC/D,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,oBAAoB,CAAC,QAAQ,EAAE,EAAE,EAAE;AACrC,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC5C,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AAC/B,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,gCAAgC,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAClE,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,mCAAmC,EAAE,CAAC;AACvE,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;AAC1D,GAAG;AACH,EAAE,mBAAmB,GAAG;AACxB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;AAChD,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AACzD,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AAC3D,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;AAC5C,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AACvB,QAAQ,MAAM;AACd,MAAM,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;AACxD,GAAG;AACH,EAAE,0BAA0B,CAAC,KAAK,EAAE;AACpC,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC;AACpB,IAAI,IAAI,QAAQ,GAAG,KAAK,CAAC;AACzB,IAAI,IAAI,cAAc,GAAG,IAAI,CAAC;AAC9B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAChC,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE,CAAC;AAC1C,IAAI,IAAI,EAAE,CAAC,IAAI,KAAK,EAAE,IAAI,EAAE,CAAC,IAAI,KAAK,EAAE,EAAE;AAC1C,MAAM,IAAI,MAAM,IAAI,CAAC,KAAK,EAAE;AAC5B,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;AAC1D,OAAO;AACP,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;AAC1C,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACxB,QAAQ,QAAQ,GAAG,IAAI,CAAC;AACxB,QAAQ,IAAI,MAAM,EAAE;AACpB,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,EAAE,IAAI,CAAC,CAAC;AACjE,SAAS;AACT,OAAO;AACP,MAAM,cAAc,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACvD,KAAK,MAAM;AACX,MAAM,cAAc,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC5C,KAAK;AACL,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC7B,IAAI,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;AACzC,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AACtD,GAAG;AACH,EAAE,kCAAkC,CAAC,IAAI,EAAE;AAC3C,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAClD,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AAC1B,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AAC/B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AACtD,GAAG;AACH,EAAE,2BAA2B,CAAC,MAAM,GAAG,EAAE,EAAE;AAC3C,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC;AACpB,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,KAAK,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;AACpD,MAAM,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;AACxB,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC/C,MAAM,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC,CAAC;AAC1D,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,GAAG,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;AACpD,KAAK;AACL,IAAI,OAAO;AACX,MAAM,MAAM;AACZ,MAAM,IAAI;AACV,MAAM,KAAK;AACX,KAAK,CAAC;AACN,GAAG;AACH,EAAE,yBAAyB,CAAC,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE;AAChD,IAAI,QAAQ,EAAE,CAAC,IAAI;AACnB,MAAM,KAAK,KAAK;AAChB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AAC1D,MAAM,KAAK,MAAM,CAAC;AAClB,MAAM,KAAK,SAAS;AACpB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;AAC9D,MAAM,KAAK,OAAO;AAClB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;AAC5D,MAAM,KAAK,OAAO;AAClB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;AAC5D,MAAM,KAAK,QAAQ;AACnB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AAC7D,MAAM,KAAK,QAAQ;AACnB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AAC7D,MAAM,KAAK,QAAQ;AACnB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AAC7D,MAAM;AACN,QAAQ,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;AACzC,QAAQ,OAAO,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AACvD,KAAK;AACL,GAAG;AACH,EAAE,oBAAoB,GAAG;AACzB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACzC,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,GAAG,CAAC;AACZ,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,IAAI,aAAa,GAAG,KAAK,CAAC;AAC9B,IAAI,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;AAChE,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI;AAC3B,MAAM,KAAK,CAAC;AACZ,QAAQ,OAAO,IAAI,CAAC,mBAAmB,CAAC;AACxC,UAAU,WAAW,EAAE,KAAK;AAC5B,UAAU,UAAU,EAAE,KAAK;AAC3B,UAAU,WAAW,EAAE,IAAI;AAC3B,UAAU,UAAU,EAAE,KAAK;AAC3B,UAAU,YAAY,EAAE,IAAI;AAC5B,SAAS,CAAC,CAAC;AACX,MAAM,KAAK,CAAC;AACZ,QAAQ,OAAO,IAAI,CAAC,mBAAmB,CAAC;AACxC,UAAU,WAAW,EAAE,KAAK;AAC5B,UAAU,UAAU,EAAE,IAAI;AAC1B,UAAU,WAAW,EAAE,IAAI;AAC3B,UAAU,UAAU,EAAE,KAAK;AAC3B,UAAU,YAAY,EAAE,KAAK;AAC7B,SAAS,CAAC,CAAC;AACX,MAAM,KAAK,CAAC;AACZ,QAAQ,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC;AAC9C,QAAQ,IAAI,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AACzC,QAAQ,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,qBAAqB,CAAC;AAC9D,QAAQ,OAAO,IAAI,CAAC;AACpB,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACvE,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,QAAQ,GAAG,GAAG,IAAI,CAAC,2BAA2B,EAAE,CAAC;AACjD,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;AACjC,QAAQ,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;AAC7B,QAAQ,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC;AAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,QAAQ,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC/C,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC/D,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAChD,UAAU,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACpE,YAAY,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC;AAChD,YAAY,aAAa,GAAG,KAAK,KAAK,EAAE,IAAI,KAAK,KAAK,EAAE,CAAC;AACzD,WAAW,MAAM;AACjB,YAAY,aAAa,GAAG,IAAI,CAAC;AACjC,WAAW;AACX,SAAS;AACT,QAAQ,IAAI,aAAa,EAAE;AAC3B,UAAU,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC;AAChD,UAAU,IAAI,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AACtC,UAAU,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,qBAAqB,CAAC;AAChE,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,kBAAkB,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,EAAE;AACpH,YAAY,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AAC5B,YAAY,OAAO,IAAI,CAAC;AACxB,WAAW,MAAM;AACjB,YAAY,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;AACzB,WAAW;AACX,SAAS;AACT,QAAQ,IAAI,IAAI,EAAE;AAClB,UAAU,GAAG,GAAG,IAAI,CAAC,2BAA2B,CAAC,CAAC,IAAI,CAAC,kCAAkC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClG,SAAS,MAAM;AACf,UAAU,GAAG,GAAG,IAAI,CAAC,2BAA2B,EAAE,CAAC;AACnD,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;AACjC,QAAQ,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;AAC7B,QAAQ,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC;AAC9B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,QAAQ,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC/C,QAAQ,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACnC,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC/D,MAAM,KAAK,GAAG;AACd,QAAQ,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,6BAA6B,CAAC,CAAC;AAClF,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;AACpC,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,8BAA8B,CAAC,CAAC;AACrE,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,GAAG,EAAE;AACtC,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC;AACtB,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC/B,YAAY,OAAO,IAAI,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,6BAA6B,EAAE,IAAI,CAAC,CAAC;AACnG,WAAW;AACX,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC/B,YAAY,OAAO,IAAI,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,6BAA6B,EAAE,IAAI,CAAC,CAAC;AACnG,WAAW;AACX,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AACzF,SAAS;AACT,QAAQ,IAAI,CAAC,UAAU,EAAE,CAAC;AAC1B,QAAQ,OAAO;AACf,MAAM,KAAK,GAAG;AACd,QAAQ,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,6BAA6B,CAAC,CAAC;AAClF,MAAM,KAAK,GAAG;AACd,QAAQ,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,6BAA6B,CAAC,CAAC;AAClF,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,oBAAoB,CAAC,CAAC;AAC3D,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,2BAA2B,CAAC,CAAC;AAClE,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,oBAAoB,CAAC,CAAC;AAC3D,MAAM,KAAK,EAAE;AACb,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;AAC7D,MAAM,KAAK,EAAE;AACb,QAAQ,OAAO,IAAI,CAAC,mBAAmB,EAAE,CAAC;AAC1C,MAAM;AACN,QAAQ,IAAI,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC7C,UAAU,MAAM,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACxD,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC;AACtB,UAAU,OAAO,KAAK,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACrD,SAAS,MAAM,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACvD,UAAU,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACtC,YAAY,OAAO,IAAI,CAAC,sBAAsB,EAAE,CAAC;AACjD,WAAW;AACX,UAAU,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;AACxF,SAAS;AACT,KAAK;AACL,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;AACtB,GAAG;AACH,EAAE,oBAAoB,GAAG;AACzB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACzC,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;AAC3C,IAAI,IAAI,yBAAyB,GAAG,KAAK,CAAC;AAC1C,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,EAAE,EAAE;AAC5E,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC9C,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;AACpC,MAAM,yBAAyB,GAAG,yBAAyB,IAAI,QAAQ,CAAC;AACxE,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACrB,MAAM,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AACtC,QAAQ,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;AAChC,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;AAC5D,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AAC/B,QAAQ,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC9C,QAAQ,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,QAAQ,IAAI,yBAAyB,EAAE;AACvC,UAAU,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACnC,UAAU,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,2BAA2B,CAAC,CAAC;AACpE,SAAS,MAAM;AACf,UAAU,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;AAC5D,SAAS;AACT,OAAO;AACP,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,mBAAmB,GAAG;AACxB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACvD,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC7D,KAAK,MAAM;AACX,MAAM,OAAO,IAAI,CAAC,oBAAoB,EAAE,CAAC;AACzC,KAAK;AACL,GAAG;AACH,EAAE,kCAAkC,GAAG;AACvC,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AAC7C,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACxD,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACrD,MAAM,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,kCAAkC,CAAC,KAAK,CAAC,CAAC,CAAC;AACrE,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACvB,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACvB,MAAM,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AAC7C,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACjC,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;AAC7D,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,yBAAyB,GAAG;AAC9B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;AACjB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,kCAAkC,EAAE,CAAC;AAC3D,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AACxB,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACzB,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,kCAAkC,EAAE,CAAC,CAAC;AACjE,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,4BAA4B,CAAC,CAAC;AAChG,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;AACjB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;AAClD,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AACxB,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACzB,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,qBAAqB,CAAC,CAAC;AACzF,GAAG;AACH,EAAE,aAAa,GAAG;AAClB,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACxC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;AAC7B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;AAC3C,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;AAClC,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,oCAAoC,GAAG;AACzC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,GAAG,EAAE;AAC7D,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AAC3C,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AAC1C,MAAM,OAAO,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AACvD,KAAK,MAAM;AACX,MAAM,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;AAClC,KAAK;AACL,GAAG;AACH,EAAE,uBAAuB,GAAG;AAC5B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;AAC1D,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,kCAAkC,CAAC,sBAAsB,EAAE;AAC7D,IAAI,MAAM,KAAK,GAAG,sBAAsB,GAAG,IAAI,CAAC,eAAe,EAAE,GAAG,IAAI,CAAC,6BAA6B,EAAE,CAAC;AACzG,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AAC5D,MAAM,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;AACnC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,mBAAmB,CAAC,IAAI,EAAE;AAC5B,IAAI,IAAI,CAAC,UAAU,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;AACzD,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACxE,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC;AAC3B,GAAG;AACH,EAAE,iBAAiB,GAAG;AACtB,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC;AACxB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAClC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,GAAG,EAAE;AACpC,QAAQ,QAAQ,CAAC,IAAI,GAAG,MAAM,CAAC;AAC/B,OAAO,MAAM;AACb,QAAQ,QAAQ,CAAC,IAAI,GAAG,OAAO,CAAC;AAChC,OAAO;AACP,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH,EAAE,iBAAiB,CAAC,IAAI,EAAE,mBAAmB,EAAE,QAAQ,GAAG,KAAK,EAAE;AACjE,IAAI,IAAI,mBAAmB,EAAE;AAC7B,MAAM,IAAI,CAAC,gCAAgC,CAAC,IAAI,EAAE,MAAM,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;AACvG,MAAM,OAAO;AACb,KAAK;AACL,IAAI,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,0BAA0B,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,GAAG,KAAK,EAAE;AAC3D,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACxC,MAAM,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,oCAAoC,EAAE,CAAC;AAC9F,MAAM,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,IAAI,CAAC;AACrG,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,0BAA0B,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;AAClE,GAAG;AACH,EAAE,kBAAkB,CAAC,KAAK,EAAE;AAC5B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACrD,MAAM,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACzC,MAAM,IAAI,0BAA0B,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;AACtD,QAAQ,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACtC,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;AACpB,QAAQ,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;AAC7C,OAAO;AACP,KAAK,MAAM,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAClE,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACpC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,KAAK,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AACjD,IAAI,IAAI,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;AACpE,MAAM,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AAC7B,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,wBAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE;AACnD,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,EAAE;AACpC,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE;AACnC,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxH,UAAU,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAC7C,SAAS;AACT,OAAO,MAAM,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACrD,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;AACvC,UAAU,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;AAC/C,SAAS,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE;AACzC,UAAU,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;AAC/C,SAAS,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;AAC3C,UAAU,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACvD,SAAS;AACT,OAAO;AACP,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,wBAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;AAClE,GAAG;AACH,EAAE,4BAA4B,GAAG;AACjC,IAAI,MAAM;AACV,MAAM,IAAI;AACV,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,kCAAkC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,KAAK,GAAG,EAAE;AAC7F,MAAM,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;AACrC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,4BAA4B,EAAE,CAAC;AAChD,GAAG;AACH,EAAE,wBAAwB,GAAG;AAC7B,IAAI,MAAM;AACV,MAAM,IAAI;AACV,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,kCAAkC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,KAAK,GAAG,EAAE;AAC7F,MAAM,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;AACpC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,wBAAwB,EAAE,CAAC;AAC5C,GAAG;AACH,EAAE,4BAA4B,GAAG;AACjC,IAAI,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAC3D,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACpC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,4BAA4B,EAAE,CAAC;AAChD,GAAG;AACH,EAAE,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,mBAAmB,EAAE;AACxD,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;AACvB,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,sBAAsB,EAAE;AAC3C,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC9C,MAAM,IAAI,MAAM,KAAK,EAAE,IAAI,MAAM,KAAK,EAAE,IAAI,MAAM,KAAK,EAAE,IAAI,MAAM,KAAK,EAAE,EAAE;AAC5E,QAAQ,IAAI,CAAC,0BAA0B,CAAC,mBAAmB,CAAC,CAAC;AAC7D,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;AACrC,IAAI,MAAM,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;AACnD,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC5C,IAAI,IAAI;AACR,MAAM,UAAU;AAChB,MAAM,MAAM;AACZ,KAAK,GAAG,IAAI,CAAC,6BAA6B,EAAE,CAAC;AAC7C,IAAI,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC;AACpE,IAAI,IAAI,MAAM,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AACtC,MAAM,MAAM,SAAS,GAAG,CAAC,GAAG,iBAAiB,CAAC,CAAC;AAC/C,MAAM,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AAC9B,QAAQ,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AAC3B,QAAQ,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;AACzC,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACjD,UAAU,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAC3C,SAAS;AACT,QAAQ,CAAC;AACT,UAAU,UAAU;AACpB,UAAU,MAAM;AAChB,SAAS,GAAG,IAAI,CAAC,6BAA6B,EAAE,EAAE;AAClD,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC;AACpE,OAAO;AACP,MAAM,IAAI,MAAM,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACtC,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;AACzE,OAAO;AACP,MAAM,IAAI,MAAM,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AACxC,QAAQ,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AAC3B,QAAQ,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AACvC,QAAQ,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;AACzC,QAAQ,CAAC;AACT,UAAU,UAAU;AACpB,UAAU,MAAM;AAChB,SAAS,GAAG,IAAI,CAAC,6BAA6B,EAAE,EAAE;AAClD,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,uBAAuB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AACnD,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,iBAAiB,CAAC;AAC7C,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpB,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;AACjC,IAAI,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,gCAAgC,CAAC,IAAI,EAAE,MAAM,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;AAC9G,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;AAC1D,GAAG;AACH,EAAE,6BAA6B,GAAG;AAClC,IAAI,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAChE,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AACtD,IAAI,MAAM,MAAM,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;AACnC,IAAI,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC;AAC/C,IAAI,OAAO;AACX,MAAM,UAAU;AAChB,MAAM,MAAM;AACZ,KAAK,CAAC;AACN,GAAG;AACH,EAAE,uBAAuB,CAAC,IAAI,EAAE,eAAe,EAAE;AACjD,IAAI,MAAM,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AACzB,IAAI,MAAM,MAAM,GAAG,EAAE,CAAC;AACtB,IAAI,OAAO,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AAC/B,MAAM,MAAM,KAAK,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;AAChC,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,yBAAyB,EAAE;AACpD,QAAQ,IAAI,KAAK,CAAC,cAAc,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;AACvD,UAAU,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;AAC5C,SAAS,MAAM;AACf,UAAU,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC7B,SAAS;AACT,QAAQ,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAC/B,OAAO,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,uBAAuB,EAAE;AACzD,QAAQ,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AACrC,QAAQ,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AACpC,OAAO;AACP,KAAK;AACL,IAAI,IAAI,eAAe,EAAE;AACzB,MAAM,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC,CAAC;AACnE,MAAM,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;AAC1B,KAAK;AACL,IAAI,OAAO,SAAS,CAAC,MAAM,EAAE,CAAC,KAAK,KAAK,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AACvG,GAAG;AACH,EAAE,qBAAqB,CAAC,IAAI,EAAE;AAC9B,IAAI,IAAI,WAAW,CAAC;AACpB,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,WAAW,CAAC,gBAAgB,EAAE,KAAK,CAAC,CAAC;AAC1H,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5B,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AACzC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACtB,GAAG;AACH,EAAE,gCAAgC,CAAC,IAAI,EAAE,MAAM,EAAE;AACjD,IAAI,IAAI,MAAM,CAAC;AACf,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;AACzE,MAAM,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClE,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC;AACxB,MAAM,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC;AACjD,KAAK,MAAM;AACX,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC;AACxB,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,GAAG;AACH,EAAE,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;AACjC,IAAI,IAAI,GAAG,KAAK,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AAChD,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC3B,MAAM,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AACtD,MAAM,YAAY,CAAC,UAAU,GAAG,IAAI,CAAC;AACrC,MAAM,YAAY,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AACnE,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,oBAAoB,CAAC,CAAC;AACjE,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,uBAAuB,CAAC,IAAI,EAAE;AAChC,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,mBAAmB,KAAK,IAAI,CAAC,UAAU,KAAK,MAAM,IAAI,IAAI,CAAC,UAAU,KAAK,QAAQ,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,wBAAwB,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,sBAAsB,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,EAAE;AACzP,MAAM,OAAO;AACb,KAAK;AACL,IAAI,KAAK,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;AACxC,GAAG;AACH,EAAE,sBAAsB,CAAC,IAAI,EAAE;AAC/B,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;AAC/B,MAAM,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC/C,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AACzB,QAAQ,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;AAC3D,QAAQ,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AACpC,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO,MAAM;AACb,QAAQ,OAAO,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;AACxD,OAAO;AACP,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACvC,MAAM,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;AAC/B,MAAM,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC/C,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC,mBAAmB,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC;AAC9D,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AACvC,MAAM,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;AAC/B,MAAM,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC/C,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;AACtD,KAAK,MAAM,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAClE,MAAM,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;AAChC,MAAM,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC/C,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC,eAAe,CAAC,CAAC;AAC5D,KAAK,MAAM;AACX,MAAM,OAAO,KAAK,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;AAChD,KAAK;AACL,GAAG;AACH,EAAE,aAAa,CAAC,IAAI,EAAE;AACtB,IAAI,IAAI,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC;AACjC,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,KAAK,EAAE,EAAE;AAChE,MAAM,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;AAC/B,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,OAAO,IAAI,CAAC;AAClB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,kCAAkC,CAAC,IAAI,EAAE;AAC3C,IAAI,MAAM;AACV,MAAM,QAAQ;AACd,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,MAAM,YAAY,GAAG,KAAK,CAAC,kCAAkC,CAAC,IAAI,CAAC,CAAC;AACxE,IAAI,IAAI,YAAY,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,EAAE;AACpD,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,YAAY,CAAC;AACxB,GAAG;AACH,EAAE,YAAY,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE;AAC9C,IAAI,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;AACtD,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACrE,KAAK;AACL,GAAG;AACH,EAAE,gBAAgB,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE;AAC7C,IAAI,MAAM;AACV,MAAM,QAAQ;AACd,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,SAAS,EAAE,MAAM,CAAC,EAAE;AACjE,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;AAC5B,KAAK;AACL,IAAI,KAAK,CAAC,gBAAgB,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;AACrD,IAAI,IAAI,MAAM,CAAC,OAAO,EAAE;AACxB,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,eAAe,IAAI,MAAM,CAAC,IAAI,KAAK,sBAAsB,IAAI,MAAM,CAAC,IAAI,KAAK,oBAAoB,EAAE;AAC7H,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,mBAAmB,EAAE,QAAQ,CAAC,CAAC;AAC7D,OAAO,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE;AAC/B,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;AAC1E,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,UAAU,CAAC,IAAI,EAAE;AACnB,IAAI,OAAO,IAAI,KAAK,UAAU,IAAI,IAAI,KAAK,eAAe,CAAC;AAC3D,GAAG;AACH,EAAE,YAAY,GAAG;AACjB,IAAI,MAAM,IAAI,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC;AACnC,IAAI,MAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC;AACjC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AACtD,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,EAAE;AACrE,QAAQ,cAAc,EAAE,QAAQ;AAChC,OAAO,CAAC,CAAC;AACT,KAAK;AACL,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AACpC,GAAG;AACH,EAAE,gBAAgB,CAAC,KAAK,EAAE;AAC1B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,KAAK,KAAK,GAAG,IAAI,IAAI,KAAK,GAAG,EAAE;AACvC,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1B,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,KAAK,KAAK,EAAE,IAAI,KAAK,KAAK,EAAE,CAAC,EAAE;AACpE,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;AAC/C,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,KAAK,KAAK,EAAE,EAAE;AAClD,MAAM,IAAI,IAAI,KAAK,EAAE,EAAE;AACvB,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7B,OAAO;AACP,KAAK,MAAM,IAAI,eAAe,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE;AACxF,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;AAC1B,KAAK,MAAM;AACX,MAAM,KAAK,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;AACpC,KAAK;AACL,GAAG;AACH,EAAE,YAAY,CAAC,IAAI,EAAE,SAAS,EAAE;AAChC,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,oBAAoB,EAAE;AAC5C,MAAM,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;AAC3D,KAAK,MAAM;AACX,MAAM,OAAO,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AACjD,KAAK;AACL,GAAG;AACH,EAAE,YAAY,CAAC,IAAI,EAAE,KAAK,GAAG,KAAK,EAAE;AACpC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,KAAK,sBAAsB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,oBAAoB,EAAE;AACnG,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACtD,KAAK;AACL,IAAI,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACpC,GAAG;AACH,EAAE,gBAAgB,CAAC,QAAQ,EAAE,gBAAgB,EAAE,KAAK,EAAE;AACtD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC9C,MAAM,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC/B,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,MAAM,oBAAoB,EAAE;AACxE,QAAQ,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;AACrD,OAAO;AACP,KAAK;AACL,IAAI,KAAK,CAAC,gBAAgB,CAAC,QAAQ,EAAE,gBAAgB,EAAE,KAAK,CAAC,CAAC;AAC9D,GAAG;AACH,EAAE,gBAAgB,CAAC,QAAQ,EAAE,mBAAmB,EAAE;AAClD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC9C,MAAM,IAAI,WAAW,CAAC;AACtB,MAAM,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC/B,MAAM,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,oBAAoB,IAAI,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,WAAW,CAAC,aAAa,CAAC,KAAK,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE;AAC7K,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,iBAAiB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;AACtE,OAAO;AACP,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH,EAAE,cAAc,CAAC,KAAK,EAAE,YAAY,EAAE,OAAO,EAAE,mBAAmB,EAAE;AACpE,IAAI,MAAM,IAAI,GAAG,KAAK,CAAC,cAAc,CAAC,KAAK,EAAE,YAAY,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;AACzF,IAAI,IAAI,YAAY,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,sBAAsB,EAAE;AAC5D,MAAM,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC3C,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,eAAe,EAAE,OAAO,EAAE;AAC9C,IAAI,OAAO,IAAI,KAAK,oBAAoB,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;AAC9F,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE;AAC3B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AAC3D,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;AAC1C,GAAG;AACH,EAAE,yBAAyB,CAAC,IAAI,EAAE;AAClC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AAC3D,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;AACjD,GAAG;AACH,EAAE,aAAa,GAAG;AAClB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,aAAa,EAAE,CAAC;AACnD,GAAG;AACH,EAAE,eAAe,GAAG;AACpB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,eAAe,EAAE,CAAC;AACrD,GAAG;AACH,EAAE,sBAAsB,CAAC,MAAM,EAAE;AACjC,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;AACnE,GAAG;AACH,EAAE,eAAe,CAAC,SAAS,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,aAAa,EAAE,iBAAiB,EAAE;AAC7F,IAAI,IAAI,MAAM,CAAC,QAAQ,EAAE;AACzB,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,QAAQ,CAAC;AAC3B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACvE,KAAK;AACL,IAAI,KAAK,CAAC,eAAe,CAAC,SAAS,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,aAAa,EAAE,iBAAiB,CAAC,CAAC;AACrG,IAAI,IAAI,MAAM,CAAC,MAAM,IAAI,aAAa,EAAE;AACxC,MAAM,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;AACnC,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;AAC5D,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,MAAM,CAAC,CAAC;AACpE,OAAO;AACP,KAAK,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,kBAAkB,IAAI,aAAa,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE;AAC3F,MAAM,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;AACzC,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;AAC5D,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,MAAM,CAAC,CAAC;AACpE,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,sBAAsB,CAAC,SAAS,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE;AAClE,IAAI,IAAI,MAAM,CAAC,QAAQ,EAAE;AACzB,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,QAAQ,CAAC;AAC3B,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACvE,KAAK;AACL,IAAI,KAAK,CAAC,sBAAsB,CAAC,SAAS,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;AAC1E,GAAG;AACH,EAAE,eAAe,CAAC,IAAI,EAAE;AACxB,IAAI,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AAChC,IAAI,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC3C,MAAM,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,mCAAmC,EAAE,CAAC;AAC5E,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;AAC/C,MAAM,GAAG;AACT,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AACvC,QAAQ,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC;AAC5D,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC5B,UAAU,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,mCAAmC,EAAE,CAAC;AAC5E,SAAS,MAAM;AACf,UAAU,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC;AACtC,SAAS;AACT,QAAQ,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC,CAAC;AACpE,OAAO,QAAQ,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAC7B,KAAK;AACL,GAAG;AACH,EAAE,uBAAuB,CAAC,MAAM,EAAE;AAClC,IAAI,KAAK,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;AAC1C,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,4BAA4B,CAAC,MAAM,CAAC,CAAC;AAC7D,IAAI,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;AAC3B,MAAM,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC9B,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,IAAI,KAAK,KAAK,EAAE;AAC5D,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC;AAChE,OAAO,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;AAC1C,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC;AAChE,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,+BAA+B,CAAC,IAAI,EAAE;AACxC,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC7C,GAAG;AACH,EAAE,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,mBAAmB,EAAE;AACtG,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE;AACvB,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC/C,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,QAAQ,CAAC;AACzB,IAAI,IAAI,cAAc,CAAC;AACvB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE;AACvC,MAAM,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AAChE,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;AACzB,QAAQ,IAAI,CAAC,UAAU,EAAE,CAAC;AAC1B,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,mBAAmB,CAAC,CAAC;AAC7H,IAAI,IAAI,cAAc,EAAE;AACxB,MAAM,CAAC,MAAM,CAAC,KAAK,IAAI,MAAM,EAAE,cAAc,GAAG,cAAc,CAAC;AAC/D,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,GAAG;AACH,EAAE,4BAA4B,CAAC,KAAK,EAAE;AACtC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACtB,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;AACvC,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;AACxD,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;AACnC,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC;AAChE,OAAO;AACP,MAAM,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC5B,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AAC5D,KAAK,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;AACxC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,2BAA2B,EAAE,KAAK,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;AACnD,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,kBAAkB,EAAE,KAAK,CAAC,CAAC;AACvD,KAAK;AACL,IAAI,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;AACjC,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,iBAAiB,CAAC,QAAQ,EAAE,IAAI,EAAE;AACpC,IAAI,MAAM,IAAI,GAAG,KAAK,CAAC,iBAAiB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AACzD,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,mBAAmB,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE;AAClH,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,qBAAqB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;AACxE,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,qBAAqB,CAAC,IAAI,EAAE;AAC9B,IAAI,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;AACtC,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,KAAK,OAAO,EAAE;AACpD,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,6BAA6B,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACzF,KAAK;AACL,GAAG;AACH,EAAE,yBAAyB,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;AACnD,IAAI,SAAS,CAAC,KAAK,GAAG,iBAAiB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACxH,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;AACtE,GAAG;AACH,EAAE,sBAAsB,CAAC,QAAQ,EAAE;AACnC,IAAI,IAAI,KAAK,CAAC,sBAAsB,CAAC,QAAQ,CAAC;AAC9C,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,IAAI,CAAC,QAAQ;AACnB,QAAQ,OAAO,IAAI,CAAC;AACpB,MAAM,MAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC1C,MAAM,OAAO,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,EAAE,CAAC;AACrC,KAAK;AACL,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;AAC9C,GAAG;AACH,EAAE,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE;AAC/C,IAAI,KAAK,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AACvD,IAAI,IAAI,QAAQ,EAAE;AAClB,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACpC,QAAQ,OAAO;AACf,OAAO;AACP,MAAM,IAAI,CAAC,UAAU,GAAG,KAAK,KAAK,MAAM,GAAG,KAAK,GAAG,OAAO,CAAC;AAC3D,KAAK,MAAM;AACX,MAAM,IAAI,KAAK,KAAK,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;AAC5C,QAAQ,IAAI,CAAC,UAAU,EAAE,CAAC;AAC1B,MAAM,IAAI,CAAC,UAAU,GAAG,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG,OAAO,CAAC;AACjF,KAAK;AACL,GAAG;AACH,EAAE,oBAAoB,CAAC,SAAS,EAAE,gBAAgB,EAAE,kBAAkB,EAAE,eAAe,EAAE,WAAW,EAAE;AACtG,IAAI,MAAM,UAAU,GAAG,SAAS,CAAC,QAAQ,CAAC;AAC1C,IAAI,IAAI,iBAAiB,GAAG,IAAI,CAAC;AACjC,IAAI,IAAI,UAAU,CAAC,IAAI,KAAK,YAAY,EAAE;AAC1C,MAAM,IAAI,UAAU,CAAC,IAAI,KAAK,MAAM,EAAE;AACtC,QAAQ,iBAAiB,GAAG,MAAM,CAAC;AACnC,OAAO,MAAM,IAAI,UAAU,CAAC,IAAI,KAAK,QAAQ,EAAE;AAC/C,QAAQ,iBAAiB,GAAG,QAAQ,CAAC;AACrC,OAAO;AACP,KAAK;AACL,IAAI,IAAI,SAAS,GAAG,KAAK,CAAC;AAC1B,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,EAAE;AACpE,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AAClD,MAAM,IAAI,iBAAiB,KAAK,IAAI,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACtF,QAAQ,SAAS,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACtC,QAAQ,SAAS,CAAC,UAAU,GAAG,iBAAiB,CAAC;AACjD,QAAQ,SAAS,CAAC,KAAK,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;AACpD,OAAO,MAAM;AACb,QAAQ,SAAS,CAAC,QAAQ,GAAG,UAAU,CAAC;AACxC,QAAQ,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;AACpC,QAAQ,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACjD,OAAO;AACP,KAAK,MAAM;AACX,MAAM,IAAI,iBAAiB,KAAK,IAAI,IAAI,0BAA0B,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACrF,QAAQ,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AACxD,QAAQ,SAAS,CAAC,UAAU,GAAG,iBAAiB,CAAC;AACjD,OAAO,MAAM;AACb,QAAQ,IAAI,gBAAgB,EAAE;AAC9B,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,qBAAqB,EAAE,SAAS,EAAE;AACpE,YAAY,UAAU,EAAE,UAAU,CAAC,KAAK;AACxC,WAAW,CAAC,CAAC;AACb,SAAS;AACT,QAAQ,SAAS,CAAC,QAAQ,GAAG,UAAU,CAAC;AACxC,QAAQ,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;AACpC,OAAO;AACP,MAAM,IAAI,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,EAAE;AAClC,QAAQ,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACjD,OAAO,MAAM;AACb,QAAQ,SAAS,GAAG,IAAI,CAAC;AACzB,QAAQ,SAAS,CAAC,KAAK,GAAG,eAAe,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAC9D,OAAO;AACP,KAAK;AACL,IAAI,MAAM,qBAAqB,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC;AAC/D,IAAI,IAAI,kBAAkB,IAAI,qBAAqB,EAAE;AACrD,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,mCAAmC,EAAE,SAAS,CAAC,CAAC;AAC5E,KAAK;AACL,IAAI,IAAI,kBAAkB,IAAI,qBAAqB,EAAE;AACrD,MAAM,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACpF,KAAK;AACL,IAAI,IAAI,SAAS,IAAI,CAAC,kBAAkB,IAAI,CAAC,qBAAqB,EAAE;AACpE,MAAM,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACpF,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;AACpE,GAAG;AACH,EAAE,gBAAgB,GAAG;AACrB,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI;AAC3B,MAAM,KAAK,EAAE;AACb,QAAQ,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AAC1C,MAAM;AACN,QAAQ,OAAO,KAAK,CAAC,gBAAgB,EAAE,CAAC;AACxC,KAAK;AACL,GAAG;AACH,EAAE,mBAAmB,CAAC,IAAI,EAAE,aAAa,EAAE;AAC3C,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AAC3B,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC5D,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AACrE,KAAK;AACL,IAAI,KAAK,CAAC,mBAAmB,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;AACnD,GAAG;AACH,EAAE,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE;AACzB,IAAI,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACjC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,IAAI,CAAC,EAAE,CAAC,cAAc,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AAC9D,MAAM,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACrC,KAAK;AACL,GAAG;AACH,EAAE,iCAAiC,CAAC,IAAI,EAAE,IAAI,EAAE;AAChD,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;AAClE,MAAM,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,IAAI,CAAC;AAC3C,MAAM,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;AACvD,MAAM,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,qBAAqB,CAAC;AAC5D,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,iCAAiC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC/D,GAAG;AACH,EAAE,qBAAqB,GAAG;AAC1B,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,qBAAqB,EAAE,CAAC;AAC3D,GAAG;AACH,EAAE,gBAAgB,CAAC,mBAAmB,EAAE,cAAc,EAAE;AACxD,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;AACtE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;AACjC,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,cAAc,CAAC,EAAE,KAAK,CAAC,CAAC;AACrG,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK;AACrB,QAAQ,OAAO,IAAI,CAAC,IAAI,CAAC;AACzB,MAAM,MAAM;AACZ,QAAQ,OAAO;AACf,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;AACrB,MAAM,MAAM,cAAc,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACzD,MAAM,IAAI,cAAc,KAAK,KAAK,CAAC,MAAM,IAAI,cAAc,KAAK,KAAK,CAAC,MAAM,EAAE;AAC9E,QAAQ,OAAO,CAAC,GAAG,EAAE,CAAC;AACtB,OAAO;AACP,KAAK;AACL,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC/D,MAAM,IAAI,KAAK,EAAE,KAAK,CAAC;AACvB,MAAM,KAAK,GAAG,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;AAC1C,MAAM,IAAI,cAAc,CAAC;AACzB,MAAM,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,KAAK;AAC7C,QAAQ,IAAI,qBAAqB,CAAC;AAClC,QAAQ,cAAc,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;AAClE,QAAQ,MAAM,gBAAgB,GAAG,IAAI,CAAC,gCAAgC,CAAC,cAAc,EAAE,MAAM;AAC7F,UAAU,MAAM,MAAM,GAAG,KAAK,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC;AACrF,UAAU,IAAI,CAAC,0BAA0B,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;AAClE,UAAU,OAAO,MAAM,CAAC;AACxB,SAAS,CAAC,CAAC;AACX,QAAQ,IAAI,CAAC,qBAAqB,GAAG,gBAAgB,CAAC,KAAK,KAAK,IAAI,IAAI,qBAAqB,CAAC,aAAa;AAC3G,UAAU,KAAK,EAAE,CAAC;AAClB,QAAQ,MAAM,IAAI,GAAG,IAAI,CAAC,6BAA6B,CAAC,gBAAgB,CAAC,CAAC;AAC1E,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,yBAAyB;AACnD,UAAU,KAAK,EAAE,CAAC;AAClB,QAAQ,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;AAC7C,QAAQ,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;AAC9D,QAAQ,OAAO,gBAAgB,CAAC;AAChC,OAAO,EAAE,KAAK,CAAC,CAAC;AAChB,MAAM,IAAI,eAAe,GAAG,IAAI,CAAC;AACjC,MAAM,IAAI,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,6BAA6B,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,yBAAyB,EAAE;AAC3G,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AAC5C,UAAU,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE;AAChC,YAAY,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,+CAA+C,EAAE,cAAc,CAAC,CAAC;AACnG,WAAW;AACX,UAAU,OAAO,KAAK,CAAC,IAAI,CAAC;AAC5B,SAAS;AACT,QAAQ,eAAe,GAAG,KAAK,CAAC,IAAI,CAAC;AACrC,OAAO;AACP,MAAM,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,IAAI,EAAE;AAChD,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;AACpC,QAAQ,OAAO,IAAI,CAAC,IAAI,CAAC;AACzB,OAAO;AACP,MAAM,IAAI,eAAe,EAAE;AAC3B,QAAQ,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;AACrC,QAAQ,OAAO,eAAe,CAAC;AAC/B,OAAO;AACP,MAAM,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,MAAM;AAChD,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC;AACzB,MAAM,IAAI,KAAK,CAAC,MAAM;AACtB,QAAQ,MAAM,KAAK,CAAC,KAAK,CAAC;AAC1B,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,iCAAiC,EAAE,cAAc,CAAC,CAAC;AACrF,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC;AACvE,GAAG;AACH,EAAE,UAAU,CAAC,IAAI,EAAE;AACnB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM;AACzC,QAAQ,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;AACpE,QAAQ,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,IAAI,CAAC;AAC7C,QAAQ,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC1C,QAAQ,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,oCAAoC,EAAE,CAAC;AAChG,QAAQ,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,qBAAqB,CAAC;AAC9D,QAAQ,IAAI,IAAI,CAAC,kBAAkB,EAAE;AACrC,UAAU,IAAI,CAAC,UAAU,EAAE,CAAC;AAC5B,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;AAC3B,UAAU,IAAI,CAAC,UAAU,EAAE,CAAC;AAC5B,QAAQ,OAAO,QAAQ,CAAC;AACxB,OAAO,CAAC,CAAC;AACT,MAAM,IAAI,MAAM,CAAC,MAAM;AACvB,QAAQ,OAAO,IAAI,CAAC;AACpB,MAAM,IAAI,MAAM,CAAC,KAAK;AACtB,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;AACtC,MAAM,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,EAAE,gBAAgB,CAAC,GAAG,IAAI,CAAC;AAC3G,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAClC,GAAG;AACH,EAAE,gBAAgB,CAAC,MAAM,EAAE;AAC3B,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;AAC5D,GAAG;AACH,EAAE,0BAA0B,CAAC,IAAI,EAAE,MAAM,EAAE;AAC3C,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;AACzE,MAAM,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AAC3B,KAAK,MAAM;AACX,MAAM,KAAK,CAAC,0BAA0B,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AACrD,KAAK;AACL,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,eAAe,EAAE,eAAe,EAAE,iBAAiB,GAAG,IAAI,EAAE;AAChF,IAAI,IAAI,eAAe,IAAI,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;AAC5F,MAAM,OAAO;AACb,KAAK;AACL,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACjD,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;AACrD,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,oBAAoB,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACpE,OAAO;AACP,KAAK;AACL,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,eAAe,EAAE,eAAe,EAAE,iBAAiB,CAAC,CAAC;AACjF,GAAG;AACH,EAAE,kCAAkC,CAAC,UAAU,EAAE;AACjD,IAAI,OAAO,KAAK,CAAC,kCAAkC,CAAC,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACzH,GAAG;AACH,EAAE,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC3C,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;AACpH,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC9C,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACzB,MAAM,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,4BAA4B,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AACrE,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACrD,KAAK,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACtF,MAAM,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;AACvC,MAAM,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,iCAAiC,CAAC,QAAQ,CAAC,IAAI,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC;AACjH,MAAM,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO;AACxC,QAAQ,OAAO,KAAK,CAAC,IAAI,CAAC;AAC1B,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;AAChG,MAAM,IAAI,MAAM,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK;AACtC,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC;AAC3B,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE;AACtB,QAAQ,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;AACrC,QAAQ,OAAO,KAAK,CAAC,IAAI,CAAC;AAC1B,OAAO;AACP,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AACvB,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;AACtC,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC;AAC3B,OAAO;AACP,MAAM,MAAM,KAAK,CAAC,KAAK,IAAI,MAAM,CAAC,KAAK,CAAC;AACxC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC1D,GAAG;AACH,EAAE,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,cAAc,EAAE;AAC1D,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,mBAAmB,EAAE,EAAE;AACtD,MAAM,cAAc,CAAC,mBAAmB,GAAG,IAAI,CAAC;AAChD,MAAM,IAAI,OAAO,EAAE;AACnB,QAAQ,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC;AACnC,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC9C,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACzB,MAAM,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,mCAAmC,EAAE,CAAC;AACtE,MAAM,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACtB,MAAM,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,4BAA4B,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AACpE,MAAM,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC3B,MAAM,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACnD,KAAK,MAAM,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACtE,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC9C,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACzB,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM;AACzC,QAAQ,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,4CAA4C,EAAE,CAAC;AACjF,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,QAAQ,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,4BAA4B,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AACvE,QAAQ,IAAI,cAAc,CAAC,mBAAmB,EAAE;AAChD,UAAU,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AAChC,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,cAAc,CAAC,mBAAmB,CAAC,CAAC;AACnF,OAAO,CAAC,CAAC;AACT,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AACvB,QAAQ,IAAI,MAAM,CAAC,KAAK;AACxB,UAAU,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;AACxC,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC;AAC3B,OAAO;AACP,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,cAAc,CAAC,CAAC;AACzE,GAAG;AACH,EAAE,cAAc,CAAC,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;AAC/B,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACnD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,CAAC,4CAA4C,EAAE,CAAC,CAAC,IAAI,CAAC;AAC5F,KAAK;AACL,IAAI,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;AAC/B,GAAG;AACH,EAAE,iCAAiC,CAAC,QAAQ,EAAE;AAC9C,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC5C,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC1C,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;AAC9B,MAAM,OAAO;AACb,IAAI,OAAO,KAAK,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;AAC1D,GAAG;AACH,EAAE,qBAAqB,CAAC,KAAK,EAAE;AAC/B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,KAAK,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;AAClE,MAAM,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,KAAK,CAAC;AACxC,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;AAC1B,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC;AACvB,MAAM,OAAO;AACb,KAAK;AACL,IAAI,KAAK,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;AACvC,GAAG;AACH,EAAE,kBAAkB,CAAC,KAAK,EAAE;AAC5B,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3D,IAAI,IAAI,KAAK,KAAK,GAAG,IAAI,IAAI,KAAK,GAAG,EAAE;AACvC,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,KAAK,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AACpC,GAAG;AACH,EAAE,aAAa,CAAC,IAAI,EAAE,OAAO,EAAE;AAC/B,IAAI,MAAM,QAAQ,GAAG,KAAK,CAAC,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACxD,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;AACnC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,uBAAuB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC/E,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH,EAAE,gBAAgB,GAAG;AACrB,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC,eAAe,EAAE,EAAE;AAClE,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;AACrC,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,iBAAiB,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC5E,OAAO;AACP,MAAM,IAAI,CAAC,wBAAwB,EAAE,CAAC;AACtC,MAAM,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACjD,MAAM,IAAI,WAAW,EAAE;AACvB,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,WAAW,CAAC;AACtC,QAAQ,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC;AACzC,OAAO;AACP,MAAM,OAAO;AACb,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,KAAK,GAAG,IAAI,CAAC,CAAC;AAC5E,GAAG;AACH,EAAE,eAAe,GAAG;AACpB,IAAI,MAAM;AACV,MAAM,GAAG;AACT,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,yBAAyB,GAAG,CAAC,CAAC;AACtC,IAAI,OAAO,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,GAAG,yBAAyB,CAAC,CAAC,EAAE;AACrF,MAAM,yBAAyB,EAAE,CAAC;AAClC,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,GAAG,GAAG,CAAC,CAAC;AACvE,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yBAAyB,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;AAC3E,IAAI,IAAI,GAAG,KAAK,EAAE,IAAI,GAAG,KAAK,EAAE,EAAE;AAClC,MAAM,OAAO,yBAAyB,GAAG,CAAC,CAAC;AAC3C,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,yBAAyB,GAAG,GAAG,EAAE,yBAAyB,GAAG,GAAG,GAAG,EAAE,CAAC,KAAK,cAAc,EAAE;AACpH,MAAM,OAAO,yBAAyB,GAAG,EAAE,CAAC;AAC5C,KAAK;AACL,IAAI,IAAI,GAAG,KAAK,EAAE,IAAI,GAAG,KAAK,EAAE,EAAE;AAClC,MAAM,OAAO,yBAAyB,CAAC;AACvC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,wBAAwB,GAAG;AAC7B,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACzD,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE;AACpB,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,mBAAmB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AAC7E,KAAK;AACL,GAAG;AACH,EAAE,wCAAwC,CAAC,GAAG,EAAE;AAChD,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,GAAG,EAAE;AACL,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,+BAA+B,EAAE,GAAG,EAAE;AAChE,MAAM,UAAU;AAChB,MAAM,QAAQ;AACd,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,qCAAqC,CAAC,GAAG,EAAE,WAAW,EAAE;AAC1D,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,YAAY,GAAG,UAAU,CAAC,uCAAuC,GAAG,WAAW,CAAC,YAAY,KAAK,QAAQ,GAAG,UAAU,CAAC,sCAAsC,GAAG,UAAU,CAAC,uCAAuC,EAAE,GAAG,EAAE,WAAW,CAAC,CAAC;AACzQ,GAAG;AACH,EAAE,uCAAuC,CAAC,GAAG,EAAE,OAAO,EAAE;AACxD,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,8BAA8B,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;AACxE,GAAG;AACH,EAAE,kDAAkD,CAAC,IAAI,EAAE,OAAO,EAAE;AACpE,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,yCAAyC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AACpF,GAAG;AACH,EAAE,kBAAkB,GAAG;AACvB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACzC,IAAI,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC5D,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI;AAC3B,MAAM,KAAK,GAAG,EAAE;AAChB,QAAQ,MAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACnE,QAAQ,IAAI,SAAS,EAAE,EAAE;AACzB,UAAU,OAAO;AACjB,YAAY,IAAI,EAAE,QAAQ;AAC1B,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK;AAClC,YAAY,KAAK,EAAE,OAAO;AAC1B,WAAW,CAAC;AACZ,SAAS;AACT,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,SAAS;AACzB,UAAU,GAAG,EAAE,QAAQ;AACvB,SAAS,CAAC;AACV,OAAO;AACP,MAAM,KAAK,GAAG,EAAE;AAChB,QAAQ,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClE,QAAQ,IAAI,SAAS,EAAE,EAAE;AACzB,UAAU,OAAO;AACjB,YAAY,IAAI,EAAE,QAAQ;AAC1B,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK;AAClC,YAAY,KAAK,EAAE,OAAO;AAC1B,WAAW,CAAC;AACZ,SAAS;AACT,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,SAAS;AACzB,UAAU,GAAG,EAAE,QAAQ;AACvB,SAAS,CAAC;AACV,OAAO;AACP,MAAM,KAAK,EAAE,CAAC;AACd,MAAM,KAAK,EAAE,EAAE;AACf,QAAQ,MAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;AACjE,QAAQ,IAAI,SAAS,EAAE,EAAE;AACzB,UAAU,OAAO;AACjB,YAAY,IAAI,EAAE,SAAS;AAC3B,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK;AAClC,YAAY,KAAK,EAAE,OAAO;AAC1B,WAAW,CAAC;AACZ,SAAS;AACT,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,SAAS;AACzB,UAAU,GAAG,EAAE,QAAQ;AACvB,SAAS,CAAC;AACV,OAAO;AACP,MAAM;AACN,QAAQ,OAAO;AACf,UAAU,IAAI,EAAE,SAAS;AACzB,UAAU,GAAG,EAAE,QAAQ;AACvB,SAAS,CAAC;AACV,KAAK;AACL,GAAG;AACH,EAAE,iBAAiB,GAAG;AACtB,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;AACpC,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AAC1C,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,kBAAkB,EAAE,GAAG;AAC5D,MAAM,IAAI,EAAE,MAAM;AAClB,MAAM,GAAG;AACT,KAAK,CAAC;AACN,IAAI,OAAO;AACX,MAAM,EAAE;AACR,MAAM,IAAI;AACV,KAAK,CAAC;AACN,GAAG;AACH,EAAE,iCAAiC,CAAC,GAAG,EAAE,OAAO,EAAE,YAAY,EAAE;AAChE,IAAI,MAAM;AACV,MAAM,YAAY;AAClB,KAAK,GAAG,OAAO,CAAC;AAChB,IAAI,IAAI,YAAY,KAAK,IAAI,EAAE;AAC/B,MAAM,OAAO;AACb,KAAK;AACL,IAAI,IAAI,YAAY,KAAK,YAAY,EAAE;AACvC,MAAM,IAAI,CAAC,qCAAqC,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC/D,KAAK;AACL,GAAG;AACH,EAAE,eAAe,CAAC;AAClB,IAAI,QAAQ;AACZ,IAAI,YAAY;AAChB,GAAG,EAAE;AACL,IAAI,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,GAAG,EAAE,CAAC;AAChD,IAAI,MAAM,OAAO,GAAG;AACpB,MAAM,cAAc,EAAE,EAAE;AACxB,MAAM,aAAa,EAAE,EAAE;AACvB,MAAM,aAAa,EAAE,EAAE;AACvB,MAAM,gBAAgB,EAAE,EAAE;AAC1B,KAAK,CAAC;AACN,IAAI,IAAI,iBAAiB,GAAG,KAAK,CAAC;AAClC,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AAC3B,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AACxB,QAAQ,iBAAiB,GAAG,IAAI,CAAC;AACjC,QAAQ,MAAM;AACd,OAAO;AACP,MAAM,MAAM,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;AAC1C,MAAM,MAAM;AACZ,QAAQ,EAAE;AACV,QAAQ,IAAI;AACZ,OAAO,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACnC,MAAM,MAAM,UAAU,GAAG,EAAE,CAAC,IAAI,CAAC;AACjC,MAAM,IAAI,UAAU,KAAK,EAAE,EAAE;AAC7B,QAAQ,SAAS;AACjB,OAAO;AACP,MAAM,IAAI,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;AACrC,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,qBAAqB,EAAE,EAAE,EAAE;AACzD,UAAU,UAAU;AACpB,UAAU,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;AACvE,UAAU,QAAQ;AAClB,SAAS,CAAC,CAAC;AACX,OAAO;AACP,MAAM,IAAI,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;AACrC,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,uBAAuB,EAAE,EAAE,EAAE;AAC3D,UAAU,UAAU;AACpB,UAAU,QAAQ;AAClB,SAAS,CAAC,CAAC;AACX,OAAO;AACP,MAAM,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AAChC,MAAM,MAAM,OAAO,GAAG;AACtB,QAAQ,QAAQ;AAChB,QAAQ,YAAY;AACpB,QAAQ,UAAU;AAClB,OAAO,CAAC;AACR,MAAM,UAAU,CAAC,EAAE,GAAG,EAAE,CAAC;AACzB,MAAM,QAAQ,IAAI,CAAC,IAAI;AACvB,QAAQ,KAAK,SAAS,EAAE;AACxB,UAAU,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;AAC/E,UAAU,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;AACvC,UAAU,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,mBAAmB,CAAC,CAAC,CAAC;AACxF,UAAU,MAAM;AAChB,SAAS;AACT,QAAQ,KAAK,QAAQ,EAAE;AACvB,UAAU,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;AAC9E,UAAU,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;AACvC,UAAU,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC,CAAC;AACtF,UAAU,MAAM;AAChB,SAAS;AACT,QAAQ,KAAK,QAAQ,EAAE;AACvB,UAAU,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;AAC9E,UAAU,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;AACvC,UAAU,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC,CAAC;AACtF,UAAU,MAAM;AAChB,SAAS;AACT,QAAQ,KAAK,SAAS,EAAE;AACxB,UAAU,MAAM,IAAI,CAAC,qCAAqC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC9E,SAAS;AACT,QAAQ,KAAK,MAAM,EAAE;AACrB,UAAU,QAAQ,YAAY;AAC9B,YAAY,KAAK,SAAS;AAC1B,cAAc,IAAI,CAAC,wCAAwC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC/E,cAAc,MAAM;AACpB,YAAY,KAAK,QAAQ;AACzB,cAAc,IAAI,CAAC,uCAAuC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAC9E,cAAc,MAAM;AACpB,YAAY;AACZ,cAAc,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,qBAAqB,CAAC,CAAC,CAAC;AAChG,WAAW;AACX,SAAS;AACT,OAAO;AACP,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AAC1B,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACxB,OAAO;AACP,KAAK;AACL,IAAI,OAAO;AACX,MAAM,OAAO;AACb,MAAM,iBAAiB;AACvB,KAAK,CAAC;AACN,GAAG;AACH,EAAE,qBAAqB,CAAC,kBAAkB,EAAE,gBAAgB,EAAE;AAC9D,IAAI,QAAQ;AACZ,GAAG,EAAE;AACL,IAAI,IAAI,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE;AACzC,MAAM,OAAO,gBAAgB,CAAC;AAC9B,KAAK,MAAM,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;AAC9C,MAAM,OAAO,kBAAkB,CAAC;AAChC,KAAK,MAAM,IAAI,gBAAgB,CAAC,MAAM,GAAG,kBAAkB,CAAC,MAAM,EAAE;AACpE,MAAM,KAAK,MAAM,MAAM,IAAI,kBAAkB,EAAE;AAC/C,QAAQ,IAAI,CAAC,kDAAkD,CAAC,MAAM,EAAE;AACxE,UAAU,QAAQ;AAClB,SAAS,CAAC,CAAC;AACX,OAAO;AACP,MAAM,OAAO,gBAAgB,CAAC;AAC9B,KAAK,MAAM;AACX,MAAM,KAAK,MAAM,MAAM,IAAI,gBAAgB,EAAE;AAC7C,QAAQ,IAAI,CAAC,kDAAkD,CAAC,MAAM,EAAE;AACxE,UAAU,QAAQ;AAClB,SAAS,CAAC,CAAC;AACX,OAAO;AACP,MAAM,OAAO,kBAAkB,CAAC;AAChC,KAAK;AACL,GAAG;AACH,EAAE,yBAAyB,CAAC;AAC5B,IAAI,QAAQ;AACZ,GAAG,EAAE;AACL,IAAI,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC;AAChC,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC7C,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,sCAAsC,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AAC/F,QAAQ,QAAQ;AAChB,OAAO,CAAC,CAAC;AACT,KAAK;AACL,IAAI,MAAM;AACV,MAAM,KAAK;AACX,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACnB,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;AAChB,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,QAAQ,EAAE;AAC/F,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,uBAAuB,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AAC1E,QAAQ,QAAQ;AAChB,QAAQ,eAAe,EAAE,KAAK;AAC9B,OAAO,CAAC,CAAC;AACT,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,YAAY,CAAC,IAAI,EAAE,EAAE,EAAE;AACzB,IAAI,MAAM,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC;AAC7B,IAAI,MAAM,OAAO,GAAG,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC;AACjC,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,yBAAyB,CAAC;AACxD,MAAM,QAAQ;AACd,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,MAAM;AACV,MAAM,OAAO;AACb,MAAM,iBAAiB;AACvB,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC;AAC7B,MAAM,QAAQ;AACd,MAAM,YAAY;AAClB,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AAC/C,IAAI,QAAQ,YAAY;AACxB,MAAM,KAAK,SAAS;AACpB,QAAQ,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACjC,QAAQ,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,cAAc,CAAC;AAC9C,QAAQ,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;AACxD,MAAM,KAAK,QAAQ;AACnB,QAAQ,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACjC,QAAQ,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC;AAC7C,QAAQ,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACvD,MAAM,KAAK,QAAQ;AACnB,QAAQ,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACjC,QAAQ,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,gBAAgB,EAAE;AACnG,UAAU,QAAQ;AAClB,SAAS,CAAC,CAAC;AACX,QAAQ,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACvD,MAAM,KAAK,QAAQ;AACnB,QAAQ,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,gBAAgB,CAAC;AAChD,QAAQ,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACvD,MAAM,SAAS;AACf,QAAQ,MAAM,KAAK,GAAG,MAAM;AAC5B,UAAU,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAC5B,UAAU,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,UAAU,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACzD,SAAS,CAAC;AACV,QAAQ,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;AAClC,QAAQ,MAAM,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC;AACvD,QAAQ,MAAM,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC;AACrD,QAAQ,MAAM,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC;AACrD,QAAQ,MAAM,YAAY,GAAG,OAAO,CAAC,gBAAgB,CAAC,MAAM,CAAC;AAC7D,QAAQ,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,IAAI,CAAC,YAAY,EAAE;AAChE,UAAU,OAAO,KAAK,EAAE,CAAC;AACzB,SAAS,MAAM,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO,EAAE;AAC1C,UAAU,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,gBAAgB,EAAE;AACrG,YAAY,QAAQ;AACpB,WAAW,CAAC,CAAC;AACb,UAAU,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,UAAU,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACzD,SAAS,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,IAAI,QAAQ,IAAI,YAAY,EAAE;AACrE,UAAU,KAAK,MAAM,MAAM,IAAI,OAAO,CAAC,gBAAgB,EAAE;AACzD,YAAY,IAAI,CAAC,wCAAwC,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE;AAC5E,cAAc,QAAQ;AACtB,cAAc,UAAU,EAAE,MAAM,CAAC,EAAE,CAAC,IAAI;AACxC,aAAa,CAAC,CAAC;AACf,WAAW;AACX,UAAU,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,cAAc,CAAC;AAChD,UAAU,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,UAAU,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;AAC1D,SAAS,MAAM,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO,IAAI,OAAO,IAAI,YAAY,EAAE;AACrE,UAAU,KAAK,MAAM,MAAM,IAAI,OAAO,CAAC,gBAAgB,EAAE;AACzD,YAAY,IAAI,CAAC,uCAAuC,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE;AAC3E,cAAc,QAAQ;AACtB,cAAc,UAAU,EAAE,MAAM,CAAC,EAAE,CAAC,IAAI;AACxC,aAAa,CAAC,CAAC;AACf,WAAW;AACX,UAAU,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC;AAC/C,UAAU,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,UAAU,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;AACzD,SAAS,MAAM;AACf,UAAU,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,4BAA4B,EAAE,OAAO,EAAE;AACvE,YAAY,QAAQ;AACpB,WAAW,CAAC,CAAC;AACb,UAAU,OAAO,KAAK,EAAE,CAAC;AACzB,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,wBAAwB,CAAC,IAAI,EAAE;AACjC,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AACtC,IAAI,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;AACjB,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,EAAE,CAAC,CAAC;AACxD,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;AACpD,GAAG;AACH,EAAE,mBAAmB,GAAG;AACxB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;AACvC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE;AAC5C,MAAM,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;AACxD,MAAM,OAAO,SAAS,KAAK,EAAE,IAAI,SAAS,KAAK,EAAE,CAAC;AAClD,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,GAAG;AACH,EAAE,6BAA6B,CAAC,IAAI,EAAE;AACtC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,oBAAoB,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AACvE,GAAG;AACH,CAAC,CAAC;AACF,MAAM,QAAQ,GAAG;AACjB,EAAE,SAAS,EAAE,IAAI;AACjB,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,EAAE,EAAE,GAAG;AACT,EAAE,EAAE,EAAE,GAAG;AACT,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,GAAG,EAAE,GAAG;AACV,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,EAAE,GAAG;AACZ,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,EAAE,GAAG;AACX,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,MAAM,EAAE,GAAG;AACb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"
      }
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1727610131524,
      "end": 1727610131524,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1727610131524,
      "end": 1727610131524,
      "order": "normal"
    },
    {
      "name": "unocss:transformers:post",
      "start": 1727610131524,
      "end": 1727610131525,
      "order": "post"
    },
    {
      "name": "unocss:transformers:post",
      "start": 1727610131524,
      "end": 1727610131525,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1727610131525,
      "end": 1727610131525,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1727610131525,
      "end": 1727610131525,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1727610131525,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1727610131525,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1727610131526,
      "end": 1727610131526,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1727610131526,
      "end": 1727610131531,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1727610131531,
      "end": 1727610131535,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1727610131535,
      "end": 1727610131535,
      "order": "normal"
    }
  ]
}
